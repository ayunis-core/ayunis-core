/**
 * Generated by orval v7.9.0 ðŸº
 * Do not edit manually.
 * Ayunis Core API
 * The Ayunis Core API description
 * OpenAPI spec version: 1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AcceptInviteDto,
  AcceptInviteResponseDto,
  ActiveSubscriptionResponseDto,
  AdminControllerGetModelParams,
  AgentResponseDto,
  ConfirmEmailDto,
  CreateAgentDto,
  CreateEmbeddingModelDto,
  CreateInviteDto,
  CreateLanguageModelDto,
  CreatePermittedModelDto,
  CreatePermittedProviderDto,
  CreatePromptDto,
  CreateSubscriptionRequestDto,
  CreateThreadDto,
  DeletePermittedProviderDto,
  EmbeddingModelEnabledResponseDto,
  ErrorResponseDto,
  FileSourceResponseDto,
  ForgotPasswordDto,
  GetThreadResponseDto,
  GetThreadsResponseDtoItem,
  InviteDetailResponseDto,
  InviteResponseDto,
  LoginDto,
  MeResponseDto,
  ModelProviderInfoResponseDto,
  ModelProviderWithPermittedStatusResponseDto,
  ModelWithConfigResponseDto,
  PermittedLanguageModelResponseDto,
  PermittedProviderResponseDto,
  PriceResponseDto,
  PromptResponseDto,
  RegisterDto,
  ResendEmailConfirmationDto,
  ResetPasswordDto,
  RetrieveUrlDto,
  RunsControllerConnectToStream200,
  RunsControllerSendMessage200,
  SendMessageDto,
  SetOrgDefaultModelDto,
  SetUserDefaultModelDto,
  SourceResponseDto,
  StorageControllerUploadFileBody,
  SubscriptionResponseDto,
  SuccessResponseDto,
  ThreadsControllerAddFileSourceBody,
  UpdateAgentDto,
  UpdateBillingInfoDto,
  UpdateEmbeddingModelDto,
  UpdateLanguageModelDto,
  UpdatePasswordDto,
  UpdatePromptDto,
  UpdateSeatsDto,
  UpdateThreadAgentDto,
  UpdateThreadModelDto,
  UpdateUserNameDto,
  UpdateUserRoleDto,
  UserResponseDto,
  UsersListResponseDto
} from './ayunisCoreAPI.schemas';

import { customAxiosInstance } from '../client';




export const appControllerGetHello = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<void>(
      {url: `/`, method: 'GET', signal
    },
      );
    }
  

export const getAppControllerGetHelloQueryKey = () => {
    return [`/`] as const;
    }

    
export const getAppControllerGetHelloQueryOptions = <TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAppControllerGetHelloQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof appControllerGetHello>>> = ({ signal }) => appControllerGetHello(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AppControllerGetHelloQueryResult = NonNullable<Awaited<ReturnType<typeof appControllerGetHello>>>
export type AppControllerGetHelloQueryError = unknown


export function useAppControllerGetHello<TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof appControllerGetHello>>,
          TError,
          Awaited<ReturnType<typeof appControllerGetHello>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAppControllerGetHello<TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof appControllerGetHello>>,
          TError,
          Awaited<ReturnType<typeof appControllerGetHello>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAppControllerGetHello<TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAppControllerGetHello<TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAppControllerGetHelloQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get all available models
 */
export const modelsControllerGetAvailableModelsWithConfig = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<ModelWithConfigResponseDto[]>(
      {url: `/models/available`, method: 'GET', signal
    },
      );
    }
  

export const getModelsControllerGetAvailableModelsWithConfigQueryKey = () => {
    return [`/models/available`] as const;
    }

    
export const getModelsControllerGetAvailableModelsWithConfigQueryOptions = <TData = Awaited<ReturnType<typeof modelsControllerGetAvailableModelsWithConfig>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetAvailableModelsWithConfig>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getModelsControllerGetAvailableModelsWithConfigQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsControllerGetAvailableModelsWithConfig>>> = ({ signal }) => modelsControllerGetAvailableModelsWithConfig(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetAvailableModelsWithConfig>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ModelsControllerGetAvailableModelsWithConfigQueryResult = NonNullable<Awaited<ReturnType<typeof modelsControllerGetAvailableModelsWithConfig>>>
export type ModelsControllerGetAvailableModelsWithConfigQueryError = void


export function useModelsControllerGetAvailableModelsWithConfig<TData = Awaited<ReturnType<typeof modelsControllerGetAvailableModelsWithConfig>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetAvailableModelsWithConfig>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof modelsControllerGetAvailableModelsWithConfig>>,
          TError,
          Awaited<ReturnType<typeof modelsControllerGetAvailableModelsWithConfig>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useModelsControllerGetAvailableModelsWithConfig<TData = Awaited<ReturnType<typeof modelsControllerGetAvailableModelsWithConfig>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetAvailableModelsWithConfig>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof modelsControllerGetAvailableModelsWithConfig>>,
          TError,
          Awaited<ReturnType<typeof modelsControllerGetAvailableModelsWithConfig>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useModelsControllerGetAvailableModelsWithConfig<TData = Awaited<ReturnType<typeof modelsControllerGetAvailableModelsWithConfig>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetAvailableModelsWithConfig>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all available models
 */

export function useModelsControllerGetAvailableModelsWithConfig<TData = Awaited<ReturnType<typeof modelsControllerGetAvailableModelsWithConfig>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetAvailableModelsWithConfig>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getModelsControllerGetAvailableModelsWithConfigQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a permitted model
 */
export const modelsControllerCreatePermittedModel = (
    createPermittedModelDto: CreatePermittedModelDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<void>(
      {url: `/models/permitted`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createPermittedModelDto, signal
    },
      );
    }
  


export const getModelsControllerCreatePermittedModelMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsControllerCreatePermittedModel>>, TError,{data: CreatePermittedModelDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof modelsControllerCreatePermittedModel>>, TError,{data: CreatePermittedModelDto}, TContext> => {

const mutationKey = ['modelsControllerCreatePermittedModel'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof modelsControllerCreatePermittedModel>>, {data: CreatePermittedModelDto}> = (props) => {
          const {data} = props ?? {};

          return  modelsControllerCreatePermittedModel(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ModelsControllerCreatePermittedModelMutationResult = NonNullable<Awaited<ReturnType<typeof modelsControllerCreatePermittedModel>>>
    export type ModelsControllerCreatePermittedModelMutationBody = CreatePermittedModelDto
    export type ModelsControllerCreatePermittedModelMutationError = void

    /**
 * @summary Create a permitted model
 */
export const useModelsControllerCreatePermittedModel = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsControllerCreatePermittedModel>>, TError,{data: CreatePermittedModelDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof modelsControllerCreatePermittedModel>>,
        TError,
        {data: CreatePermittedModelDto},
        TContext
      > => {

      const mutationOptions = getModelsControllerCreatePermittedModelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Delete a permitted model
 */
export const modelsControllerDeletePermittedModel = (
    id: string,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/models/permitted/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getModelsControllerDeletePermittedModelMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsControllerDeletePermittedModel>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof modelsControllerDeletePermittedModel>>, TError,{id: string}, TContext> => {

const mutationKey = ['modelsControllerDeletePermittedModel'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof modelsControllerDeletePermittedModel>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  modelsControllerDeletePermittedModel(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ModelsControllerDeletePermittedModelMutationResult = NonNullable<Awaited<ReturnType<typeof modelsControllerDeletePermittedModel>>>
    
    export type ModelsControllerDeletePermittedModelMutationError = void

    /**
 * @summary Delete a permitted model
 */
export const useModelsControllerDeletePermittedModel = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsControllerDeletePermittedModel>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof modelsControllerDeletePermittedModel>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getModelsControllerDeletePermittedModelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get all permitted language models
 */
export const modelsControllerGetPermittedLanguageModels = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<PermittedLanguageModelResponseDto[]>(
      {url: `/models/permitted/language-models`, method: 'GET', signal
    },
      );
    }
  

export const getModelsControllerGetPermittedLanguageModelsQueryKey = () => {
    return [`/models/permitted/language-models`] as const;
    }

    
export const getModelsControllerGetPermittedLanguageModelsQueryOptions = <TData = Awaited<ReturnType<typeof modelsControllerGetPermittedLanguageModels>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetPermittedLanguageModels>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getModelsControllerGetPermittedLanguageModelsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsControllerGetPermittedLanguageModels>>> = ({ signal }) => modelsControllerGetPermittedLanguageModels(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetPermittedLanguageModels>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ModelsControllerGetPermittedLanguageModelsQueryResult = NonNullable<Awaited<ReturnType<typeof modelsControllerGetPermittedLanguageModels>>>
export type ModelsControllerGetPermittedLanguageModelsQueryError = void


export function useModelsControllerGetPermittedLanguageModels<TData = Awaited<ReturnType<typeof modelsControllerGetPermittedLanguageModels>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetPermittedLanguageModels>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof modelsControllerGetPermittedLanguageModels>>,
          TError,
          Awaited<ReturnType<typeof modelsControllerGetPermittedLanguageModels>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useModelsControllerGetPermittedLanguageModels<TData = Awaited<ReturnType<typeof modelsControllerGetPermittedLanguageModels>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetPermittedLanguageModels>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof modelsControllerGetPermittedLanguageModels>>,
          TError,
          Awaited<ReturnType<typeof modelsControllerGetPermittedLanguageModels>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useModelsControllerGetPermittedLanguageModels<TData = Awaited<ReturnType<typeof modelsControllerGetPermittedLanguageModels>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetPermittedLanguageModels>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all permitted language models
 */

export function useModelsControllerGetPermittedLanguageModels<TData = Awaited<ReturnType<typeof modelsControllerGetPermittedLanguageModels>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetPermittedLanguageModels>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getModelsControllerGetPermittedLanguageModelsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns the applicable default model with fallback hierarchy: User default â†’ Org default â†’ First available model
 * @summary Get the effective default model for the user
 */
export const modelsControllerGetEffectiveDefaultModel = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<PermittedLanguageModelResponseDto>(
      {url: `/models/default`, method: 'GET', signal
    },
      );
    }
  

export const getModelsControllerGetEffectiveDefaultModelQueryKey = () => {
    return [`/models/default`] as const;
    }

    
export const getModelsControllerGetEffectiveDefaultModelQueryOptions = <TData = Awaited<ReturnType<typeof modelsControllerGetEffectiveDefaultModel>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetEffectiveDefaultModel>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getModelsControllerGetEffectiveDefaultModelQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsControllerGetEffectiveDefaultModel>>> = ({ signal }) => modelsControllerGetEffectiveDefaultModel(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetEffectiveDefaultModel>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ModelsControllerGetEffectiveDefaultModelQueryResult = NonNullable<Awaited<ReturnType<typeof modelsControllerGetEffectiveDefaultModel>>>
export type ModelsControllerGetEffectiveDefaultModelQueryError = void


export function useModelsControllerGetEffectiveDefaultModel<TData = Awaited<ReturnType<typeof modelsControllerGetEffectiveDefaultModel>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetEffectiveDefaultModel>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof modelsControllerGetEffectiveDefaultModel>>,
          TError,
          Awaited<ReturnType<typeof modelsControllerGetEffectiveDefaultModel>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useModelsControllerGetEffectiveDefaultModel<TData = Awaited<ReturnType<typeof modelsControllerGetEffectiveDefaultModel>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetEffectiveDefaultModel>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof modelsControllerGetEffectiveDefaultModel>>,
          TError,
          Awaited<ReturnType<typeof modelsControllerGetEffectiveDefaultModel>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useModelsControllerGetEffectiveDefaultModel<TData = Awaited<ReturnType<typeof modelsControllerGetEffectiveDefaultModel>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetEffectiveDefaultModel>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get the effective default model for the user
 */

export function useModelsControllerGetEffectiveDefaultModel<TData = Awaited<ReturnType<typeof modelsControllerGetEffectiveDefaultModel>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetEffectiveDefaultModel>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getModelsControllerGetEffectiveDefaultModelQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns only the organization's specific default model. Returns null if no org default is set.
 * @summary Get the organization default model
 */
export const modelsControllerGetOrgSpecificDefaultModel = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<PermittedLanguageModelResponseDto>(
      {url: `/models/org/default`, method: 'GET', signal
    },
      );
    }
  

export const getModelsControllerGetOrgSpecificDefaultModelQueryKey = () => {
    return [`/models/org/default`] as const;
    }

    
export const getModelsControllerGetOrgSpecificDefaultModelQueryOptions = <TData = Awaited<ReturnType<typeof modelsControllerGetOrgSpecificDefaultModel>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetOrgSpecificDefaultModel>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getModelsControllerGetOrgSpecificDefaultModelQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsControllerGetOrgSpecificDefaultModel>>> = ({ signal }) => modelsControllerGetOrgSpecificDefaultModel(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetOrgSpecificDefaultModel>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ModelsControllerGetOrgSpecificDefaultModelQueryResult = NonNullable<Awaited<ReturnType<typeof modelsControllerGetOrgSpecificDefaultModel>>>
export type ModelsControllerGetOrgSpecificDefaultModelQueryError = void


export function useModelsControllerGetOrgSpecificDefaultModel<TData = Awaited<ReturnType<typeof modelsControllerGetOrgSpecificDefaultModel>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetOrgSpecificDefaultModel>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof modelsControllerGetOrgSpecificDefaultModel>>,
          TError,
          Awaited<ReturnType<typeof modelsControllerGetOrgSpecificDefaultModel>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useModelsControllerGetOrgSpecificDefaultModel<TData = Awaited<ReturnType<typeof modelsControllerGetOrgSpecificDefaultModel>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetOrgSpecificDefaultModel>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof modelsControllerGetOrgSpecificDefaultModel>>,
          TError,
          Awaited<ReturnType<typeof modelsControllerGetOrgSpecificDefaultModel>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useModelsControllerGetOrgSpecificDefaultModel<TData = Awaited<ReturnType<typeof modelsControllerGetOrgSpecificDefaultModel>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetOrgSpecificDefaultModel>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get the organization default model
 */

export function useModelsControllerGetOrgSpecificDefaultModel<TData = Awaited<ReturnType<typeof modelsControllerGetOrgSpecificDefaultModel>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetOrgSpecificDefaultModel>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getModelsControllerGetOrgSpecificDefaultModelQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Sets the specified permitted model as the organization default. If a default already exists, it will be updated to the new model.
 * @summary Set or update the organization default model
 */
export const modelsControllerManageOrgDefaultModel = (
    setOrgDefaultModelDto: SetOrgDefaultModelDto,
 ) => {
      
      
      return customAxiosInstance<PermittedLanguageModelResponseDto>(
      {url: `/models/org/default`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: setOrgDefaultModelDto
    },
      );
    }
  


export const getModelsControllerManageOrgDefaultModelMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsControllerManageOrgDefaultModel>>, TError,{data: SetOrgDefaultModelDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof modelsControllerManageOrgDefaultModel>>, TError,{data: SetOrgDefaultModelDto}, TContext> => {

const mutationKey = ['modelsControllerManageOrgDefaultModel'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof modelsControllerManageOrgDefaultModel>>, {data: SetOrgDefaultModelDto}> = (props) => {
          const {data} = props ?? {};

          return  modelsControllerManageOrgDefaultModel(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ModelsControllerManageOrgDefaultModelMutationResult = NonNullable<Awaited<ReturnType<typeof modelsControllerManageOrgDefaultModel>>>
    export type ModelsControllerManageOrgDefaultModelMutationBody = SetOrgDefaultModelDto
    export type ModelsControllerManageOrgDefaultModelMutationError = void

    /**
 * @summary Set or update the organization default model
 */
export const useModelsControllerManageOrgDefaultModel = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsControllerManageOrgDefaultModel>>, TError,{data: SetOrgDefaultModelDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof modelsControllerManageOrgDefaultModel>>,
        TError,
        {data: SetOrgDefaultModelDto},
        TContext
      > => {

      const mutationOptions = getModelsControllerManageOrgDefaultModelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Returns the user's personal default model only. Returns null if no user-specific default is set.
 * @summary Get the user-specific default model
 */
export const modelsControllerGetUserSpecificDefaultModel = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<PermittedLanguageModelResponseDto>(
      {url: `/models/user/default`, method: 'GET', signal
    },
      );
    }
  

export const getModelsControllerGetUserSpecificDefaultModelQueryKey = () => {
    return [`/models/user/default`] as const;
    }

    
export const getModelsControllerGetUserSpecificDefaultModelQueryOptions = <TData = Awaited<ReturnType<typeof modelsControllerGetUserSpecificDefaultModel>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetUserSpecificDefaultModel>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getModelsControllerGetUserSpecificDefaultModelQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsControllerGetUserSpecificDefaultModel>>> = ({ signal }) => modelsControllerGetUserSpecificDefaultModel(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetUserSpecificDefaultModel>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ModelsControllerGetUserSpecificDefaultModelQueryResult = NonNullable<Awaited<ReturnType<typeof modelsControllerGetUserSpecificDefaultModel>>>
export type ModelsControllerGetUserSpecificDefaultModelQueryError = void


export function useModelsControllerGetUserSpecificDefaultModel<TData = Awaited<ReturnType<typeof modelsControllerGetUserSpecificDefaultModel>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetUserSpecificDefaultModel>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof modelsControllerGetUserSpecificDefaultModel>>,
          TError,
          Awaited<ReturnType<typeof modelsControllerGetUserSpecificDefaultModel>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useModelsControllerGetUserSpecificDefaultModel<TData = Awaited<ReturnType<typeof modelsControllerGetUserSpecificDefaultModel>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetUserSpecificDefaultModel>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof modelsControllerGetUserSpecificDefaultModel>>,
          TError,
          Awaited<ReturnType<typeof modelsControllerGetUserSpecificDefaultModel>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useModelsControllerGetUserSpecificDefaultModel<TData = Awaited<ReturnType<typeof modelsControllerGetUserSpecificDefaultModel>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetUserSpecificDefaultModel>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get the user-specific default model
 */

export function useModelsControllerGetUserSpecificDefaultModel<TData = Awaited<ReturnType<typeof modelsControllerGetUserSpecificDefaultModel>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetUserSpecificDefaultModel>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getModelsControllerGetUserSpecificDefaultModelQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Sets the specified permitted model as the user default. If a default already exists, it will be updated to the new model.
 * @summary Set or update the user default model
 */
export const modelsControllerManageUserDefaultModel = (
    setUserDefaultModelDto: SetUserDefaultModelDto,
 ) => {
      
      
      return customAxiosInstance<PermittedLanguageModelResponseDto>(
      {url: `/models/user/default`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: setUserDefaultModelDto
    },
      );
    }
  


export const getModelsControllerManageUserDefaultModelMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsControllerManageUserDefaultModel>>, TError,{data: SetUserDefaultModelDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof modelsControllerManageUserDefaultModel>>, TError,{data: SetUserDefaultModelDto}, TContext> => {

const mutationKey = ['modelsControllerManageUserDefaultModel'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof modelsControllerManageUserDefaultModel>>, {data: SetUserDefaultModelDto}> = (props) => {
          const {data} = props ?? {};

          return  modelsControllerManageUserDefaultModel(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ModelsControllerManageUserDefaultModelMutationResult = NonNullable<Awaited<ReturnType<typeof modelsControllerManageUserDefaultModel>>>
    export type ModelsControllerManageUserDefaultModelMutationBody = SetUserDefaultModelDto
    export type ModelsControllerManageUserDefaultModelMutationError = void

    /**
 * @summary Set or update the user default model
 */
export const useModelsControllerManageUserDefaultModel = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsControllerManageUserDefaultModel>>, TError,{data: SetUserDefaultModelDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof modelsControllerManageUserDefaultModel>>,
        TError,
        {data: SetUserDefaultModelDto},
        TContext
      > => {

      const mutationOptions = getModelsControllerManageUserDefaultModelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Delete the user default model
 */
export const modelsControllerDeleteUserDefaultModel = (
    
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/models/user/default`, method: 'DELETE'
    },
      );
    }
  


export const getModelsControllerDeleteUserDefaultModelMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsControllerDeleteUserDefaultModel>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof modelsControllerDeleteUserDefaultModel>>, TError,void, TContext> => {

const mutationKey = ['modelsControllerDeleteUserDefaultModel'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof modelsControllerDeleteUserDefaultModel>>, void> = () => {
          

          return  modelsControllerDeleteUserDefaultModel()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ModelsControllerDeleteUserDefaultModelMutationResult = NonNullable<Awaited<ReturnType<typeof modelsControllerDeleteUserDefaultModel>>>
    
    export type ModelsControllerDeleteUserDefaultModelMutationError = void

    /**
 * @summary Delete the user default model
 */
export const useModelsControllerDeleteUserDefaultModel = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsControllerDeleteUserDefaultModel>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof modelsControllerDeleteUserDefaultModel>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getModelsControllerDeleteUserDefaultModelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieves detailed information about a specific model provider
 * @summary Get model provider information
 */
export const modelsControllerGetModelProviderInfo = (
    provider: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<ModelProviderInfoResponseDto>(
      {url: `/models/provider/${provider}`, method: 'GET', signal
    },
      );
    }
  

export const getModelsControllerGetModelProviderInfoQueryKey = (provider: string,) => {
    return [`/models/provider/${provider}`] as const;
    }

    
export const getModelsControllerGetModelProviderInfoQueryOptions = <TData = Awaited<ReturnType<typeof modelsControllerGetModelProviderInfo>>, TError = void>(provider: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetModelProviderInfo>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getModelsControllerGetModelProviderInfoQueryKey(provider);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsControllerGetModelProviderInfo>>> = ({ signal }) => modelsControllerGetModelProviderInfo(provider, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(provider), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetModelProviderInfo>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ModelsControllerGetModelProviderInfoQueryResult = NonNullable<Awaited<ReturnType<typeof modelsControllerGetModelProviderInfo>>>
export type ModelsControllerGetModelProviderInfoQueryError = void


export function useModelsControllerGetModelProviderInfo<TData = Awaited<ReturnType<typeof modelsControllerGetModelProviderInfo>>, TError = void>(
 provider: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetModelProviderInfo>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof modelsControllerGetModelProviderInfo>>,
          TError,
          Awaited<ReturnType<typeof modelsControllerGetModelProviderInfo>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useModelsControllerGetModelProviderInfo<TData = Awaited<ReturnType<typeof modelsControllerGetModelProviderInfo>>, TError = void>(
 provider: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetModelProviderInfo>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof modelsControllerGetModelProviderInfo>>,
          TError,
          Awaited<ReturnType<typeof modelsControllerGetModelProviderInfo>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useModelsControllerGetModelProviderInfo<TData = Awaited<ReturnType<typeof modelsControllerGetModelProviderInfo>>, TError = void>(
 provider: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetModelProviderInfo>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get model provider information
 */

export function useModelsControllerGetModelProviderInfo<TData = Awaited<ReturnType<typeof modelsControllerGetModelProviderInfo>>, TError = void>(
 provider: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetModelProviderInfo>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getModelsControllerGetModelProviderInfoQueryOptions(provider,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a permitted provider (Admin only)
 */
export const modelsControllerCreatePermittedProvider = (
    createPermittedProviderDto: CreatePermittedProviderDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<PermittedProviderResponseDto>(
      {url: `/models/providers/permitted`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createPermittedProviderDto, signal
    },
      );
    }
  


export const getModelsControllerCreatePermittedProviderMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsControllerCreatePermittedProvider>>, TError,{data: CreatePermittedProviderDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof modelsControllerCreatePermittedProvider>>, TError,{data: CreatePermittedProviderDto}, TContext> => {

const mutationKey = ['modelsControllerCreatePermittedProvider'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof modelsControllerCreatePermittedProvider>>, {data: CreatePermittedProviderDto}> = (props) => {
          const {data} = props ?? {};

          return  modelsControllerCreatePermittedProvider(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ModelsControllerCreatePermittedProviderMutationResult = NonNullable<Awaited<ReturnType<typeof modelsControllerCreatePermittedProvider>>>
    export type ModelsControllerCreatePermittedProviderMutationBody = CreatePermittedProviderDto
    export type ModelsControllerCreatePermittedProviderMutationError = void

    /**
 * @summary Create a permitted provider (Admin only)
 */
export const useModelsControllerCreatePermittedProvider = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsControllerCreatePermittedProvider>>, TError,{data: CreatePermittedProviderDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof modelsControllerCreatePermittedProvider>>,
        TError,
        {data: CreatePermittedProviderDto},
        TContext
      > => {

      const mutationOptions = getModelsControllerCreatePermittedProviderMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get all permitted providers
 */
export const modelsControllerGetAllPermittedProviders = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<PermittedProviderResponseDto[]>(
      {url: `/models/providers/permitted`, method: 'GET', signal
    },
      );
    }
  

export const getModelsControllerGetAllPermittedProvidersQueryKey = () => {
    return [`/models/providers/permitted`] as const;
    }

    
export const getModelsControllerGetAllPermittedProvidersQueryOptions = <TData = Awaited<ReturnType<typeof modelsControllerGetAllPermittedProviders>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetAllPermittedProviders>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getModelsControllerGetAllPermittedProvidersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsControllerGetAllPermittedProviders>>> = ({ signal }) => modelsControllerGetAllPermittedProviders(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetAllPermittedProviders>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ModelsControllerGetAllPermittedProvidersQueryResult = NonNullable<Awaited<ReturnType<typeof modelsControllerGetAllPermittedProviders>>>
export type ModelsControllerGetAllPermittedProvidersQueryError = void


export function useModelsControllerGetAllPermittedProviders<TData = Awaited<ReturnType<typeof modelsControllerGetAllPermittedProviders>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetAllPermittedProviders>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof modelsControllerGetAllPermittedProviders>>,
          TError,
          Awaited<ReturnType<typeof modelsControllerGetAllPermittedProviders>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useModelsControllerGetAllPermittedProviders<TData = Awaited<ReturnType<typeof modelsControllerGetAllPermittedProviders>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetAllPermittedProviders>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof modelsControllerGetAllPermittedProviders>>,
          TError,
          Awaited<ReturnType<typeof modelsControllerGetAllPermittedProviders>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useModelsControllerGetAllPermittedProviders<TData = Awaited<ReturnType<typeof modelsControllerGetAllPermittedProviders>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetAllPermittedProviders>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all permitted providers
 */

export function useModelsControllerGetAllPermittedProviders<TData = Awaited<ReturnType<typeof modelsControllerGetAllPermittedProviders>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetAllPermittedProviders>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getModelsControllerGetAllPermittedProvidersQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Delete a permitted provider (Admin only)
 */
export const modelsControllerDeletePermittedProvider = (
    deletePermittedProviderDto: DeletePermittedProviderDto,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/models/providers/permitted`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: deletePermittedProviderDto
    },
      );
    }
  


export const getModelsControllerDeletePermittedProviderMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsControllerDeletePermittedProvider>>, TError,{data: DeletePermittedProviderDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof modelsControllerDeletePermittedProvider>>, TError,{data: DeletePermittedProviderDto}, TContext> => {

const mutationKey = ['modelsControllerDeletePermittedProvider'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof modelsControllerDeletePermittedProvider>>, {data: DeletePermittedProviderDto}> = (props) => {
          const {data} = props ?? {};

          return  modelsControllerDeletePermittedProvider(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ModelsControllerDeletePermittedProviderMutationResult = NonNullable<Awaited<ReturnType<typeof modelsControllerDeletePermittedProvider>>>
    export type ModelsControllerDeletePermittedProviderMutationBody = DeletePermittedProviderDto
    export type ModelsControllerDeletePermittedProviderMutationError = void

    /**
 * @summary Delete a permitted provider (Admin only)
 */
export const useModelsControllerDeletePermittedProvider = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsControllerDeletePermittedProvider>>, TError,{data: DeletePermittedProviderDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof modelsControllerDeletePermittedProvider>>,
        TError,
        {data: DeletePermittedProviderDto},
        TContext
      > => {

      const mutationOptions = getModelsControllerDeletePermittedProviderMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Returns all available model providers with information about whether each is permitted for the organization
 * @summary Get all model provider infos with permitted status (Admin only)
 */
export const modelsControllerGetAllModelProviderInfosWithPermittedStatus = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<ModelProviderWithPermittedStatusResponseDto[]>(
      {url: `/models/providers/all-with-permitted-status`, method: 'GET', signal
    },
      );
    }
  

export const getModelsControllerGetAllModelProviderInfosWithPermittedStatusQueryKey = () => {
    return [`/models/providers/all-with-permitted-status`] as const;
    }

    
export const getModelsControllerGetAllModelProviderInfosWithPermittedStatusQueryOptions = <TData = Awaited<ReturnType<typeof modelsControllerGetAllModelProviderInfosWithPermittedStatus>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetAllModelProviderInfosWithPermittedStatus>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getModelsControllerGetAllModelProviderInfosWithPermittedStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsControllerGetAllModelProviderInfosWithPermittedStatus>>> = ({ signal }) => modelsControllerGetAllModelProviderInfosWithPermittedStatus(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetAllModelProviderInfosWithPermittedStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ModelsControllerGetAllModelProviderInfosWithPermittedStatusQueryResult = NonNullable<Awaited<ReturnType<typeof modelsControllerGetAllModelProviderInfosWithPermittedStatus>>>
export type ModelsControllerGetAllModelProviderInfosWithPermittedStatusQueryError = void


export function useModelsControllerGetAllModelProviderInfosWithPermittedStatus<TData = Awaited<ReturnType<typeof modelsControllerGetAllModelProviderInfosWithPermittedStatus>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetAllModelProviderInfosWithPermittedStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof modelsControllerGetAllModelProviderInfosWithPermittedStatus>>,
          TError,
          Awaited<ReturnType<typeof modelsControllerGetAllModelProviderInfosWithPermittedStatus>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useModelsControllerGetAllModelProviderInfosWithPermittedStatus<TData = Awaited<ReturnType<typeof modelsControllerGetAllModelProviderInfosWithPermittedStatus>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetAllModelProviderInfosWithPermittedStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof modelsControllerGetAllModelProviderInfosWithPermittedStatus>>,
          TError,
          Awaited<ReturnType<typeof modelsControllerGetAllModelProviderInfosWithPermittedStatus>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useModelsControllerGetAllModelProviderInfosWithPermittedStatus<TData = Awaited<ReturnType<typeof modelsControllerGetAllModelProviderInfosWithPermittedStatus>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetAllModelProviderInfosWithPermittedStatus>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all model provider infos with permitted status (Admin only)
 */

export function useModelsControllerGetAllModelProviderInfosWithPermittedStatus<TData = Awaited<ReturnType<typeof modelsControllerGetAllModelProviderInfosWithPermittedStatus>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetAllModelProviderInfosWithPermittedStatus>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getModelsControllerGetAllModelProviderInfosWithPermittedStatusQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Check if an embedding model is enabled for this org
 */
export const modelsControllerIsEmbeddingModelEnabled = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<EmbeddingModelEnabledResponseDto>(
      {url: `/models/embedding/enabled`, method: 'GET', signal
    },
      );
    }
  

export const getModelsControllerIsEmbeddingModelEnabledQueryKey = () => {
    return [`/models/embedding/enabled`] as const;
    }

    
export const getModelsControllerIsEmbeddingModelEnabledQueryOptions = <TData = Awaited<ReturnType<typeof modelsControllerIsEmbeddingModelEnabled>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerIsEmbeddingModelEnabled>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getModelsControllerIsEmbeddingModelEnabledQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsControllerIsEmbeddingModelEnabled>>> = ({ signal }) => modelsControllerIsEmbeddingModelEnabled(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof modelsControllerIsEmbeddingModelEnabled>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ModelsControllerIsEmbeddingModelEnabledQueryResult = NonNullable<Awaited<ReturnType<typeof modelsControllerIsEmbeddingModelEnabled>>>
export type ModelsControllerIsEmbeddingModelEnabledQueryError = void


export function useModelsControllerIsEmbeddingModelEnabled<TData = Awaited<ReturnType<typeof modelsControllerIsEmbeddingModelEnabled>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerIsEmbeddingModelEnabled>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof modelsControllerIsEmbeddingModelEnabled>>,
          TError,
          Awaited<ReturnType<typeof modelsControllerIsEmbeddingModelEnabled>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useModelsControllerIsEmbeddingModelEnabled<TData = Awaited<ReturnType<typeof modelsControllerIsEmbeddingModelEnabled>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerIsEmbeddingModelEnabled>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof modelsControllerIsEmbeddingModelEnabled>>,
          TError,
          Awaited<ReturnType<typeof modelsControllerIsEmbeddingModelEnabled>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useModelsControllerIsEmbeddingModelEnabled<TData = Awaited<ReturnType<typeof modelsControllerIsEmbeddingModelEnabled>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerIsEmbeddingModelEnabled>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Check if an embedding model is enabled for this org
 */

export function useModelsControllerIsEmbeddingModelEnabled<TData = Awaited<ReturnType<typeof modelsControllerIsEmbeddingModelEnabled>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerIsEmbeddingModelEnabled>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getModelsControllerIsEmbeddingModelEnabledQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve all users that belong to the current authenticated user's organization. Returns user information without sensitive data like password hashes.
 * @summary Get users in current organization
 */
export const userControllerGetUsersInOrganization = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<UsersListResponseDto>(
      {url: `/users`, method: 'GET', signal
    },
      );
    }
  

export const getUserControllerGetUsersInOrganizationQueryKey = () => {
    return [`/users`] as const;
    }

    
export const getUserControllerGetUsersInOrganizationQueryOptions = <TData = Awaited<ReturnType<typeof userControllerGetUsersInOrganization>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerGetUsersInOrganization>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUserControllerGetUsersInOrganizationQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userControllerGetUsersInOrganization>>> = ({ signal }) => userControllerGetUsersInOrganization(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userControllerGetUsersInOrganization>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UserControllerGetUsersInOrganizationQueryResult = NonNullable<Awaited<ReturnType<typeof userControllerGetUsersInOrganization>>>
export type UserControllerGetUsersInOrganizationQueryError = void


export function useUserControllerGetUsersInOrganization<TData = Awaited<ReturnType<typeof userControllerGetUsersInOrganization>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerGetUsersInOrganization>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerGetUsersInOrganization>>,
          TError,
          Awaited<ReturnType<typeof userControllerGetUsersInOrganization>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserControllerGetUsersInOrganization<TData = Awaited<ReturnType<typeof userControllerGetUsersInOrganization>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerGetUsersInOrganization>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerGetUsersInOrganization>>,
          TError,
          Awaited<ReturnType<typeof userControllerGetUsersInOrganization>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserControllerGetUsersInOrganization<TData = Awaited<ReturnType<typeof userControllerGetUsersInOrganization>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerGetUsersInOrganization>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get users in current organization
 */

export function useUserControllerGetUsersInOrganization<TData = Awaited<ReturnType<typeof userControllerGetUsersInOrganization>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerGetUsersInOrganization>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserControllerGetUsersInOrganizationQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update the role of a user. You cannot update your own role.
 * @summary Update user role
 */
export const userControllerUpdateUserRole = (
    id: string,
    updateUserRoleDto: UpdateUserRoleDto,
 ) => {
      
      
      return customAxiosInstance<UserResponseDto>(
      {url: `/users/${id}/role`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateUserRoleDto
    },
      );
    }
  


export const getUserControllerUpdateUserRoleMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerUpdateUserRole>>, TError,{id: string;data: UpdateUserRoleDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof userControllerUpdateUserRole>>, TError,{id: string;data: UpdateUserRoleDto}, TContext> => {

const mutationKey = ['userControllerUpdateUserRole'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userControllerUpdateUserRole>>, {id: string;data: UpdateUserRoleDto}> = (props) => {
          const {id,data} = props ?? {};

          return  userControllerUpdateUserRole(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserControllerUpdateUserRoleMutationResult = NonNullable<Awaited<ReturnType<typeof userControllerUpdateUserRole>>>
    export type UserControllerUpdateUserRoleMutationBody = UpdateUserRoleDto
    export type UserControllerUpdateUserRoleMutationError = void

    /**
 * @summary Update user role
 */
export const useUserControllerUpdateUserRole = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerUpdateUserRole>>, TError,{id: string;data: UpdateUserRoleDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof userControllerUpdateUserRole>>,
        TError,
        {id: string;data: UpdateUserRoleDto},
        TContext
      > => {

      const mutationOptions = getUserControllerUpdateUserRoleMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Update the name of a user. Users can only update their own name.
 * @summary Update user name
 */
export const userControllerUpdateUserName = (
    updateUserNameDto: UpdateUserNameDto,
 ) => {
      
      
      return customAxiosInstance<UserResponseDto>(
      {url: `/users/name`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateUserNameDto
    },
      );
    }
  


export const getUserControllerUpdateUserNameMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerUpdateUserName>>, TError,{data: UpdateUserNameDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof userControllerUpdateUserName>>, TError,{data: UpdateUserNameDto}, TContext> => {

const mutationKey = ['userControllerUpdateUserName'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userControllerUpdateUserName>>, {data: UpdateUserNameDto}> = (props) => {
          const {data} = props ?? {};

          return  userControllerUpdateUserName(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserControllerUpdateUserNameMutationResult = NonNullable<Awaited<ReturnType<typeof userControllerUpdateUserName>>>
    export type UserControllerUpdateUserNameMutationBody = UpdateUserNameDto
    export type UserControllerUpdateUserNameMutationError = void

    /**
 * @summary Update user name
 */
export const useUserControllerUpdateUserName = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerUpdateUserName>>, TError,{data: UpdateUserNameDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof userControllerUpdateUserName>>,
        TError,
        {data: UpdateUserNameDto},
        TContext
      > => {

      const mutationOptions = getUserControllerUpdateUserNameMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Update the password of the current authenticated user. Requires current password for verification.
 * @summary Update user password
 */
export const userControllerUpdatePassword = (
    updatePasswordDto: UpdatePasswordDto,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/users/password`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updatePasswordDto
    },
      );
    }
  


export const getUserControllerUpdatePasswordMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerUpdatePassword>>, TError,{data: UpdatePasswordDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof userControllerUpdatePassword>>, TError,{data: UpdatePasswordDto}, TContext> => {

const mutationKey = ['userControllerUpdatePassword'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userControllerUpdatePassword>>, {data: UpdatePasswordDto}> = (props) => {
          const {data} = props ?? {};

          return  userControllerUpdatePassword(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserControllerUpdatePasswordMutationResult = NonNullable<Awaited<ReturnType<typeof userControllerUpdatePassword>>>
    export type UserControllerUpdatePasswordMutationBody = UpdatePasswordDto
    export type UserControllerUpdatePasswordMutationError = void

    /**
 * @summary Update user password
 */
export const useUserControllerUpdatePassword = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerUpdatePassword>>, TError,{data: UpdatePasswordDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof userControllerUpdatePassword>>,
        TError,
        {data: UpdatePasswordDto},
        TContext
      > => {

      const mutationOptions = getUserControllerUpdatePasswordMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Confirm a user's email address using a JWT token received via email
 * @summary Confirm user email
 */
export const userControllerConfirmEmail = (
    confirmEmailDto: ConfirmEmailDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<void>(
      {url: `/users/confirm-email`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: confirmEmailDto, signal
    },
      );
    }
  


export const getUserControllerConfirmEmailMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerConfirmEmail>>, TError,{data: ConfirmEmailDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof userControllerConfirmEmail>>, TError,{data: ConfirmEmailDto}, TContext> => {

const mutationKey = ['userControllerConfirmEmail'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userControllerConfirmEmail>>, {data: ConfirmEmailDto}> = (props) => {
          const {data} = props ?? {};

          return  userControllerConfirmEmail(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserControllerConfirmEmailMutationResult = NonNullable<Awaited<ReturnType<typeof userControllerConfirmEmail>>>
    export type UserControllerConfirmEmailMutationBody = ConfirmEmailDto
    export type UserControllerConfirmEmailMutationError = void

    /**
 * @summary Confirm user email
 */
export const useUserControllerConfirmEmail = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerConfirmEmail>>, TError,{data: ConfirmEmailDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof userControllerConfirmEmail>>,
        TError,
        {data: ConfirmEmailDto},
        TContext
      > => {

      const mutationOptions = getUserControllerConfirmEmailMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Resend a confirmation email to the specified email address. Silently succeeds even if email is already verified or user does not exist for security reasons.
 * @summary Resend email confirmation
 */
export const userControllerResendEmailConfirmation = (
    resendEmailConfirmationDto: ResendEmailConfirmationDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<void>(
      {url: `/users/resend-confirmation`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: resendEmailConfirmationDto, signal
    },
      );
    }
  


export const getUserControllerResendEmailConfirmationMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerResendEmailConfirmation>>, TError,{data: ResendEmailConfirmationDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof userControllerResendEmailConfirmation>>, TError,{data: ResendEmailConfirmationDto}, TContext> => {

const mutationKey = ['userControllerResendEmailConfirmation'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userControllerResendEmailConfirmation>>, {data: ResendEmailConfirmationDto}> = (props) => {
          const {data} = props ?? {};

          return  userControllerResendEmailConfirmation(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserControllerResendEmailConfirmationMutationResult = NonNullable<Awaited<ReturnType<typeof userControllerResendEmailConfirmation>>>
    export type UserControllerResendEmailConfirmationMutationBody = ResendEmailConfirmationDto
    export type UserControllerResendEmailConfirmationMutationError = void

    /**
 * @summary Resend email confirmation
 */
export const useUserControllerResendEmailConfirmation = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerResendEmailConfirmation>>, TError,{data: ResendEmailConfirmationDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof userControllerResendEmailConfirmation>>,
        TError,
        {data: ResendEmailConfirmationDto},
        TContext
      > => {

      const mutationOptions = getUserControllerResendEmailConfirmationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a user by their ID. Only users within the same organization can be deleted.
 * @summary Delete a user
 */
export const userControllerDeleteUser = (
    id: string,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/users/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getUserControllerDeleteUserMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerDeleteUser>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof userControllerDeleteUser>>, TError,{id: string}, TContext> => {

const mutationKey = ['userControllerDeleteUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userControllerDeleteUser>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  userControllerDeleteUser(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserControllerDeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof userControllerDeleteUser>>>
    
    export type UserControllerDeleteUserMutationError = void

    /**
 * @summary Delete a user
 */
export const useUserControllerDeleteUser = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerDeleteUser>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof userControllerDeleteUser>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getUserControllerDeleteUserMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Send a password reset email to the provided email address. If the email exists in the system, a reset link will be sent.
 * @summary Trigger password reset
 */
export const userControllerForgotPassword = (
    forgotPasswordDto: ForgotPasswordDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<void>(
      {url: `/users/forgot-password`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: forgotPasswordDto, signal
    },
      );
    }
  


export const getUserControllerForgotPasswordMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerForgotPassword>>, TError,{data: ForgotPasswordDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof userControllerForgotPassword>>, TError,{data: ForgotPasswordDto}, TContext> => {

const mutationKey = ['userControllerForgotPassword'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userControllerForgotPassword>>, {data: ForgotPasswordDto}> = (props) => {
          const {data} = props ?? {};

          return  userControllerForgotPassword(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserControllerForgotPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof userControllerForgotPassword>>>
    export type UserControllerForgotPasswordMutationBody = ForgotPasswordDto
    export type UserControllerForgotPasswordMutationError = void

    /**
 * @summary Trigger password reset
 */
export const useUserControllerForgotPassword = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerForgotPassword>>, TError,{data: ForgotPasswordDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof userControllerForgotPassword>>,
        TError,
        {data: ForgotPasswordDto},
        TContext
      > => {

      const mutationOptions = getUserControllerForgotPasswordMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Reset user password using the token received via email. The token must be valid and not expired.
 * @summary Reset password with token
 */
export const userControllerResetPassword = (
    resetPasswordDto: ResetPasswordDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<void>(
      {url: `/users/reset-password`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: resetPasswordDto, signal
    },
      );
    }
  


export const getUserControllerResetPasswordMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerResetPassword>>, TError,{data: ResetPasswordDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof userControllerResetPassword>>, TError,{data: ResetPasswordDto}, TContext> => {

const mutationKey = ['userControllerResetPassword'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userControllerResetPassword>>, {data: ResetPasswordDto}> = (props) => {
          const {data} = props ?? {};

          return  userControllerResetPassword(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserControllerResetPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof userControllerResetPassword>>>
    export type UserControllerResetPasswordMutationBody = ResetPasswordDto
    export type UserControllerResetPasswordMutationError = void

    /**
 * @summary Reset password with token
 */
export const useUserControllerResetPassword = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerResetPassword>>, TError,{data: ResetPasswordDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof userControllerResetPassword>>,
        TError,
        {data: ResetPasswordDto},
        TContext
      > => {

      const mutationOptions = getUserControllerResetPasswordMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Create a new thread
 */
export const threadsControllerCreate = (
    createThreadDto: CreateThreadDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<GetThreadResponseDto>(
      {url: `/threads`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createThreadDto, signal
    },
      );
    }
  


export const getThreadsControllerCreateMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof threadsControllerCreate>>, TError,{data: CreateThreadDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof threadsControllerCreate>>, TError,{data: CreateThreadDto}, TContext> => {

const mutationKey = ['threadsControllerCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof threadsControllerCreate>>, {data: CreateThreadDto}> = (props) => {
          const {data} = props ?? {};

          return  threadsControllerCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ThreadsControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof threadsControllerCreate>>>
    export type ThreadsControllerCreateMutationBody = CreateThreadDto
    export type ThreadsControllerCreateMutationError = void

    /**
 * @summary Create a new thread
 */
export const useThreadsControllerCreate = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof threadsControllerCreate>>, TError,{data: CreateThreadDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof threadsControllerCreate>>,
        TError,
        {data: CreateThreadDto},
        TContext
      > => {

      const mutationOptions = getThreadsControllerCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get all threads for the current user
 */
export const threadsControllerFindAll = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<GetThreadsResponseDtoItem[]>(
      {url: `/threads`, method: 'GET', signal
    },
      );
    }
  

export const getThreadsControllerFindAllQueryKey = () => {
    return [`/threads`] as const;
    }

    
export const getThreadsControllerFindAllQueryOptions = <TData = Awaited<ReturnType<typeof threadsControllerFindAll>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof threadsControllerFindAll>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getThreadsControllerFindAllQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof threadsControllerFindAll>>> = ({ signal }) => threadsControllerFindAll(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof threadsControllerFindAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ThreadsControllerFindAllQueryResult = NonNullable<Awaited<ReturnType<typeof threadsControllerFindAll>>>
export type ThreadsControllerFindAllQueryError = void


export function useThreadsControllerFindAll<TData = Awaited<ReturnType<typeof threadsControllerFindAll>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof threadsControllerFindAll>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof threadsControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof threadsControllerFindAll>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useThreadsControllerFindAll<TData = Awaited<ReturnType<typeof threadsControllerFindAll>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof threadsControllerFindAll>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof threadsControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof threadsControllerFindAll>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useThreadsControllerFindAll<TData = Awaited<ReturnType<typeof threadsControllerFindAll>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof threadsControllerFindAll>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all threads for the current user
 */

export function useThreadsControllerFindAll<TData = Awaited<ReturnType<typeof threadsControllerFindAll>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof threadsControllerFindAll>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getThreadsControllerFindAllQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get a thread by ID
 */
export const threadsControllerFindOne = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<GetThreadResponseDto>(
      {url: `/threads/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getThreadsControllerFindOneQueryKey = (id: string,) => {
    return [`/threads/${id}`] as const;
    }

    
export const getThreadsControllerFindOneQueryOptions = <TData = Awaited<ReturnType<typeof threadsControllerFindOne>>, TError = void>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof threadsControllerFindOne>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getThreadsControllerFindOneQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof threadsControllerFindOne>>> = ({ signal }) => threadsControllerFindOne(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof threadsControllerFindOne>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ThreadsControllerFindOneQueryResult = NonNullable<Awaited<ReturnType<typeof threadsControllerFindOne>>>
export type ThreadsControllerFindOneQueryError = void


export function useThreadsControllerFindOne<TData = Awaited<ReturnType<typeof threadsControllerFindOne>>, TError = void>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof threadsControllerFindOne>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof threadsControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof threadsControllerFindOne>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useThreadsControllerFindOne<TData = Awaited<ReturnType<typeof threadsControllerFindOne>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof threadsControllerFindOne>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof threadsControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof threadsControllerFindOne>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useThreadsControllerFindOne<TData = Awaited<ReturnType<typeof threadsControllerFindOne>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof threadsControllerFindOne>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a thread by ID
 */

export function useThreadsControllerFindOne<TData = Awaited<ReturnType<typeof threadsControllerFindOne>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof threadsControllerFindOne>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getThreadsControllerFindOneQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Delete a thread
 */
export const threadsControllerDelete = (
    id: string,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/threads/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getThreadsControllerDeleteMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof threadsControllerDelete>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof threadsControllerDelete>>, TError,{id: string}, TContext> => {

const mutationKey = ['threadsControllerDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof threadsControllerDelete>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  threadsControllerDelete(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ThreadsControllerDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof threadsControllerDelete>>>
    
    export type ThreadsControllerDeleteMutationError = void

    /**
 * @summary Delete a thread
 */
export const useThreadsControllerDelete = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof threadsControllerDelete>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof threadsControllerDelete>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getThreadsControllerDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Update thread model
 */
export const threadsControllerUpdateModel = (
    id: string,
    updateThreadModelDto: UpdateThreadModelDto,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/threads/${id}/model`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateThreadModelDto
    },
      );
    }
  


export const getThreadsControllerUpdateModelMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof threadsControllerUpdateModel>>, TError,{id: string;data: UpdateThreadModelDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof threadsControllerUpdateModel>>, TError,{id: string;data: UpdateThreadModelDto}, TContext> => {

const mutationKey = ['threadsControllerUpdateModel'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof threadsControllerUpdateModel>>, {id: string;data: UpdateThreadModelDto}> = (props) => {
          const {id,data} = props ?? {};

          return  threadsControllerUpdateModel(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ThreadsControllerUpdateModelMutationResult = NonNullable<Awaited<ReturnType<typeof threadsControllerUpdateModel>>>
    export type ThreadsControllerUpdateModelMutationBody = UpdateThreadModelDto
    export type ThreadsControllerUpdateModelMutationError = void

    /**
 * @summary Update thread model
 */
export const useThreadsControllerUpdateModel = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof threadsControllerUpdateModel>>, TError,{id: string;data: UpdateThreadModelDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof threadsControllerUpdateModel>>,
        TError,
        {id: string;data: UpdateThreadModelDto},
        TContext
      > => {

      const mutationOptions = getThreadsControllerUpdateModelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Update thread agent
 */
export const threadsControllerUpdateAgent = (
    id: string,
    updateThreadAgentDto: UpdateThreadAgentDto,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/threads/${id}/agent`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateThreadAgentDto
    },
      );
    }
  


export const getThreadsControllerUpdateAgentMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof threadsControllerUpdateAgent>>, TError,{id: string;data: UpdateThreadAgentDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof threadsControllerUpdateAgent>>, TError,{id: string;data: UpdateThreadAgentDto}, TContext> => {

const mutationKey = ['threadsControllerUpdateAgent'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof threadsControllerUpdateAgent>>, {id: string;data: UpdateThreadAgentDto}> = (props) => {
          const {id,data} = props ?? {};

          return  threadsControllerUpdateAgent(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ThreadsControllerUpdateAgentMutationResult = NonNullable<Awaited<ReturnType<typeof threadsControllerUpdateAgent>>>
    export type ThreadsControllerUpdateAgentMutationBody = UpdateThreadAgentDto
    export type ThreadsControllerUpdateAgentMutationError = void

    /**
 * @summary Update thread agent
 */
export const useThreadsControllerUpdateAgent = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof threadsControllerUpdateAgent>>, TError,{id: string;data: UpdateThreadAgentDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof threadsControllerUpdateAgent>>,
        TError,
        {id: string;data: UpdateThreadAgentDto},
        TContext
      > => {

      const mutationOptions = getThreadsControllerUpdateAgentMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get all sources for a thread
 */
export const threadsControllerGetThreadSources = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<SourceResponseDto[]>(
      {url: `/threads/${id}/sources`, method: 'GET', signal
    },
      );
    }
  

export const getThreadsControllerGetThreadSourcesQueryKey = (id: string,) => {
    return [`/threads/${id}/sources`] as const;
    }

    
export const getThreadsControllerGetThreadSourcesQueryOptions = <TData = Awaited<ReturnType<typeof threadsControllerGetThreadSources>>, TError = void>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof threadsControllerGetThreadSources>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getThreadsControllerGetThreadSourcesQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof threadsControllerGetThreadSources>>> = ({ signal }) => threadsControllerGetThreadSources(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof threadsControllerGetThreadSources>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ThreadsControllerGetThreadSourcesQueryResult = NonNullable<Awaited<ReturnType<typeof threadsControllerGetThreadSources>>>
export type ThreadsControllerGetThreadSourcesQueryError = void


export function useThreadsControllerGetThreadSources<TData = Awaited<ReturnType<typeof threadsControllerGetThreadSources>>, TError = void>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof threadsControllerGetThreadSources>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof threadsControllerGetThreadSources>>,
          TError,
          Awaited<ReturnType<typeof threadsControllerGetThreadSources>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useThreadsControllerGetThreadSources<TData = Awaited<ReturnType<typeof threadsControllerGetThreadSources>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof threadsControllerGetThreadSources>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof threadsControllerGetThreadSources>>,
          TError,
          Awaited<ReturnType<typeof threadsControllerGetThreadSources>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useThreadsControllerGetThreadSources<TData = Awaited<ReturnType<typeof threadsControllerGetThreadSources>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof threadsControllerGetThreadSources>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all sources for a thread
 */

export function useThreadsControllerGetThreadSources<TData = Awaited<ReturnType<typeof threadsControllerGetThreadSources>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof threadsControllerGetThreadSources>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getThreadsControllerGetThreadSourcesQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Add a file source to a thread
 */
export const threadsControllerAddFileSource = (
    id: string,
    threadsControllerAddFileSourceBody: ThreadsControllerAddFileSourceBody,
 signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`file`, threadsControllerAddFileSourceBody.file)
if(threadsControllerAddFileSourceBody.name !== undefined) {
 formData.append(`name`, threadsControllerAddFileSourceBody.name)
 }
if(threadsControllerAddFileSourceBody.description !== undefined) {
 formData.append(`description`, threadsControllerAddFileSourceBody.description)
 }

      return customAxiosInstance<FileSourceResponseDto>(
      {url: `/threads/${id}/sources/file`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      );
    }
  


export const getThreadsControllerAddFileSourceMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof threadsControllerAddFileSource>>, TError,{id: string;data: ThreadsControllerAddFileSourceBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof threadsControllerAddFileSource>>, TError,{id: string;data: ThreadsControllerAddFileSourceBody}, TContext> => {

const mutationKey = ['threadsControllerAddFileSource'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof threadsControllerAddFileSource>>, {id: string;data: ThreadsControllerAddFileSourceBody}> = (props) => {
          const {id,data} = props ?? {};

          return  threadsControllerAddFileSource(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ThreadsControllerAddFileSourceMutationResult = NonNullable<Awaited<ReturnType<typeof threadsControllerAddFileSource>>>
    export type ThreadsControllerAddFileSourceMutationBody = ThreadsControllerAddFileSourceBody
    export type ThreadsControllerAddFileSourceMutationError = unknown

    /**
 * @summary Add a file source to a thread
 */
export const useThreadsControllerAddFileSource = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof threadsControllerAddFileSource>>, TError,{id: string;data: ThreadsControllerAddFileSourceBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof threadsControllerAddFileSource>>,
        TError,
        {id: string;data: ThreadsControllerAddFileSourceBody},
        TContext
      > => {

      const mutationOptions = getThreadsControllerAddFileSourceMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Remove a source from a thread
 */
export const threadsControllerRemoveSource = (
    id: string,
    sourceId: string,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/threads/${id}/sources/${sourceId}`, method: 'DELETE'
    },
      );
    }
  


export const getThreadsControllerRemoveSourceMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof threadsControllerRemoveSource>>, TError,{id: string;sourceId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof threadsControllerRemoveSource>>, TError,{id: string;sourceId: string}, TContext> => {

const mutationKey = ['threadsControllerRemoveSource'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof threadsControllerRemoveSource>>, {id: string;sourceId: string}> = (props) => {
          const {id,sourceId} = props ?? {};

          return  threadsControllerRemoveSource(id,sourceId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ThreadsControllerRemoveSourceMutationResult = NonNullable<Awaited<ReturnType<typeof threadsControllerRemoveSource>>>
    
    export type ThreadsControllerRemoveSourceMutationError = void

    /**
 * @summary Remove a source from a thread
 */
export const useThreadsControllerRemoveSource = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof threadsControllerRemoveSource>>, TError,{id: string;sourceId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof threadsControllerRemoveSource>>,
        TError,
        {id: string;sourceId: string},
        TContext
      > => {

      const mutationOptions = getThreadsControllerRemoveSourceMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Create a new agent
 */
export const agentsControllerCreate = (
    createAgentDto: CreateAgentDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<AgentResponseDto>(
      {url: `/agents`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createAgentDto, signal
    },
      );
    }
  


export const getAgentsControllerCreateMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof agentsControllerCreate>>, TError,{data: CreateAgentDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof agentsControllerCreate>>, TError,{data: CreateAgentDto}, TContext> => {

const mutationKey = ['agentsControllerCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof agentsControllerCreate>>, {data: CreateAgentDto}> = (props) => {
          const {data} = props ?? {};

          return  agentsControllerCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AgentsControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof agentsControllerCreate>>>
    export type AgentsControllerCreateMutationBody = CreateAgentDto
    export type AgentsControllerCreateMutationError = void

    /**
 * @summary Create a new agent
 */
export const useAgentsControllerCreate = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof agentsControllerCreate>>, TError,{data: CreateAgentDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof agentsControllerCreate>>,
        TError,
        {data: CreateAgentDto},
        TContext
      > => {

      const mutationOptions = getAgentsControllerCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get all agents for the current user
 */
export const agentsControllerFindAll = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<AgentResponseDto[]>(
      {url: `/agents`, method: 'GET', signal
    },
      );
    }
  

export const getAgentsControllerFindAllQueryKey = () => {
    return [`/agents`] as const;
    }

    
export const getAgentsControllerFindAllQueryOptions = <TData = Awaited<ReturnType<typeof agentsControllerFindAll>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof agentsControllerFindAll>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAgentsControllerFindAllQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof agentsControllerFindAll>>> = ({ signal }) => agentsControllerFindAll(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof agentsControllerFindAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AgentsControllerFindAllQueryResult = NonNullable<Awaited<ReturnType<typeof agentsControllerFindAll>>>
export type AgentsControllerFindAllQueryError = void


export function useAgentsControllerFindAll<TData = Awaited<ReturnType<typeof agentsControllerFindAll>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof agentsControllerFindAll>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof agentsControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof agentsControllerFindAll>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAgentsControllerFindAll<TData = Awaited<ReturnType<typeof agentsControllerFindAll>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof agentsControllerFindAll>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof agentsControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof agentsControllerFindAll>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAgentsControllerFindAll<TData = Awaited<ReturnType<typeof agentsControllerFindAll>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof agentsControllerFindAll>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all agents for the current user
 */

export function useAgentsControllerFindAll<TData = Awaited<ReturnType<typeof agentsControllerFindAll>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof agentsControllerFindAll>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAgentsControllerFindAllQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get an agent by ID
 */
export const agentsControllerFindOne = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<AgentResponseDto>(
      {url: `/agents/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getAgentsControllerFindOneQueryKey = (id: string,) => {
    return [`/agents/${id}`] as const;
    }

    
export const getAgentsControllerFindOneQueryOptions = <TData = Awaited<ReturnType<typeof agentsControllerFindOne>>, TError = void>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof agentsControllerFindOne>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAgentsControllerFindOneQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof agentsControllerFindOne>>> = ({ signal }) => agentsControllerFindOne(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof agentsControllerFindOne>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AgentsControllerFindOneQueryResult = NonNullable<Awaited<ReturnType<typeof agentsControllerFindOne>>>
export type AgentsControllerFindOneQueryError = void


export function useAgentsControllerFindOne<TData = Awaited<ReturnType<typeof agentsControllerFindOne>>, TError = void>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof agentsControllerFindOne>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof agentsControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof agentsControllerFindOne>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAgentsControllerFindOne<TData = Awaited<ReturnType<typeof agentsControllerFindOne>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof agentsControllerFindOne>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof agentsControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof agentsControllerFindOne>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAgentsControllerFindOne<TData = Awaited<ReturnType<typeof agentsControllerFindOne>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof agentsControllerFindOne>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get an agent by ID
 */

export function useAgentsControllerFindOne<TData = Awaited<ReturnType<typeof agentsControllerFindOne>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof agentsControllerFindOne>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAgentsControllerFindOneQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update an agent
 */
export const agentsControllerUpdate = (
    id: string,
    updateAgentDto: UpdateAgentDto,
 ) => {
      
      
      return customAxiosInstance<AgentResponseDto>(
      {url: `/agents/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateAgentDto
    },
      );
    }
  


export const getAgentsControllerUpdateMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof agentsControllerUpdate>>, TError,{id: string;data: UpdateAgentDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof agentsControllerUpdate>>, TError,{id: string;data: UpdateAgentDto}, TContext> => {

const mutationKey = ['agentsControllerUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof agentsControllerUpdate>>, {id: string;data: UpdateAgentDto}> = (props) => {
          const {id,data} = props ?? {};

          return  agentsControllerUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AgentsControllerUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof agentsControllerUpdate>>>
    export type AgentsControllerUpdateMutationBody = UpdateAgentDto
    export type AgentsControllerUpdateMutationError = void

    /**
 * @summary Update an agent
 */
export const useAgentsControllerUpdate = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof agentsControllerUpdate>>, TError,{id: string;data: UpdateAgentDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof agentsControllerUpdate>>,
        TError,
        {id: string;data: UpdateAgentDto},
        TContext
      > => {

      const mutationOptions = getAgentsControllerUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Delete an agent
 */
export const agentsControllerDelete = (
    id: string,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/agents/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getAgentsControllerDeleteMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof agentsControllerDelete>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof agentsControllerDelete>>, TError,{id: string}, TContext> => {

const mutationKey = ['agentsControllerDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof agentsControllerDelete>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  agentsControllerDelete(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AgentsControllerDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof agentsControllerDelete>>>
    
    export type AgentsControllerDeleteMutationError = void

    /**
 * @summary Delete an agent
 */
export const useAgentsControllerDelete = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof agentsControllerDelete>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof agentsControllerDelete>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getAgentsControllerDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Retrieve content from a URL
 */
export const urlRetrieverControllerRetrieveUrl = (
    retrieveUrlDto: RetrieveUrlDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<void>(
      {url: `/retrievers/url`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: retrieveUrlDto, signal
    },
      );
    }
  


export const getUrlRetrieverControllerRetrieveUrlMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof urlRetrieverControllerRetrieveUrl>>, TError,{data: RetrieveUrlDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof urlRetrieverControllerRetrieveUrl>>, TError,{data: RetrieveUrlDto}, TContext> => {

const mutationKey = ['urlRetrieverControllerRetrieveUrl'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof urlRetrieverControllerRetrieveUrl>>, {data: RetrieveUrlDto}> = (props) => {
          const {data} = props ?? {};

          return  urlRetrieverControllerRetrieveUrl(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UrlRetrieverControllerRetrieveUrlMutationResult = NonNullable<Awaited<ReturnType<typeof urlRetrieverControllerRetrieveUrl>>>
    export type UrlRetrieverControllerRetrieveUrlMutationBody = RetrieveUrlDto
    export type UrlRetrieverControllerRetrieveUrlMutationError = unknown

    /**
 * @summary Retrieve content from a URL
 */
export const useUrlRetrieverControllerRetrieveUrl = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof urlRetrieverControllerRetrieveUrl>>, TError,{data: RetrieveUrlDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof urlRetrieverControllerRetrieveUrl>>,
        TError,
        {data: RetrieveUrlDto},
        TContext
      > => {

      const mutationOptions = getUrlRetrieverControllerRetrieveUrlMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Establishes a server-sent events connection and returns a session ID for sending messages. The connection includes automatic heartbeat events every 30 seconds to keep the connection alive and detect disconnected clients.
 * @summary Connect to the run stream and receive a session ID
 */
export const runsControllerConnectToStream = (
    threadId: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<RunsControllerConnectToStream200>(
      {url: `/runs/stream/${threadId}`, method: 'GET', signal
    },
      );
    }
  

export const getRunsControllerConnectToStreamQueryKey = (threadId: string,) => {
    return [`/runs/stream/${threadId}`] as const;
    }

    
export const getRunsControllerConnectToStreamQueryOptions = <TData = Awaited<ReturnType<typeof runsControllerConnectToStream>>, TError = unknown>(threadId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof runsControllerConnectToStream>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRunsControllerConnectToStreamQueryKey(threadId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof runsControllerConnectToStream>>> = ({ signal }) => runsControllerConnectToStream(threadId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(threadId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof runsControllerConnectToStream>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type RunsControllerConnectToStreamQueryResult = NonNullable<Awaited<ReturnType<typeof runsControllerConnectToStream>>>
export type RunsControllerConnectToStreamQueryError = unknown


export function useRunsControllerConnectToStream<TData = Awaited<ReturnType<typeof runsControllerConnectToStream>>, TError = unknown>(
 threadId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof runsControllerConnectToStream>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof runsControllerConnectToStream>>,
          TError,
          Awaited<ReturnType<typeof runsControllerConnectToStream>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRunsControllerConnectToStream<TData = Awaited<ReturnType<typeof runsControllerConnectToStream>>, TError = unknown>(
 threadId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof runsControllerConnectToStream>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof runsControllerConnectToStream>>,
          TError,
          Awaited<ReturnType<typeof runsControllerConnectToStream>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRunsControllerConnectToStream<TData = Awaited<ReturnType<typeof runsControllerConnectToStream>>, TError = unknown>(
 threadId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof runsControllerConnectToStream>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Connect to the run stream and receive a session ID
 */

export function useRunsControllerConnectToStream<TData = Awaited<ReturnType<typeof runsControllerConnectToStream>>, TError = unknown>(
 threadId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof runsControllerConnectToStream>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getRunsControllerConnectToStreamQueryOptions(threadId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Sends a user message to the specified session and triggers AI processing
 * @summary Send a message to an active session
 */
export const runsControllerSendMessage = (
    sendMessageDto: SendMessageDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<RunsControllerSendMessage200>(
      {url: `/runs/send-message`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: sendMessageDto, signal
    },
      );
    }
  


export const getRunsControllerSendMessageMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof runsControllerSendMessage>>, TError,{data: SendMessageDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof runsControllerSendMessage>>, TError,{data: SendMessageDto}, TContext> => {

const mutationKey = ['runsControllerSendMessage'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof runsControllerSendMessage>>, {data: SendMessageDto}> = (props) => {
          const {data} = props ?? {};

          return  runsControllerSendMessage(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RunsControllerSendMessageMutationResult = NonNullable<Awaited<ReturnType<typeof runsControllerSendMessage>>>
    export type RunsControllerSendMessageMutationBody = SendMessageDto
    export type RunsControllerSendMessageMutationError = void

    /**
 * @summary Send a message to an active session
 */
export const useRunsControllerSendMessage = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof runsControllerSendMessage>>, TError,{data: SendMessageDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof runsControllerSendMessage>>,
        TError,
        {data: SendMessageDto},
        TContext
      > => {

      const mutationOptions = getRunsControllerSendMessageMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get subscription details for the current organization
 */
export const subscriptionsControllerGetSubscription = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<SubscriptionResponseDto>(
      {url: `/subscriptions`, method: 'GET', signal
    },
      );
    }
  

export const getSubscriptionsControllerGetSubscriptionQueryKey = () => {
    return [`/subscriptions`] as const;
    }

    
export const getSubscriptionsControllerGetSubscriptionQueryOptions = <TData = Awaited<ReturnType<typeof subscriptionsControllerGetSubscription>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof subscriptionsControllerGetSubscription>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubscriptionsControllerGetSubscriptionQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof subscriptionsControllerGetSubscription>>> = ({ signal }) => subscriptionsControllerGetSubscription(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof subscriptionsControllerGetSubscription>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SubscriptionsControllerGetSubscriptionQueryResult = NonNullable<Awaited<ReturnType<typeof subscriptionsControllerGetSubscription>>>
export type SubscriptionsControllerGetSubscriptionQueryError = void


export function useSubscriptionsControllerGetSubscription<TData = Awaited<ReturnType<typeof subscriptionsControllerGetSubscription>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof subscriptionsControllerGetSubscription>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof subscriptionsControllerGetSubscription>>,
          TError,
          Awaited<ReturnType<typeof subscriptionsControllerGetSubscription>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubscriptionsControllerGetSubscription<TData = Awaited<ReturnType<typeof subscriptionsControllerGetSubscription>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof subscriptionsControllerGetSubscription>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof subscriptionsControllerGetSubscription>>,
          TError,
          Awaited<ReturnType<typeof subscriptionsControllerGetSubscription>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubscriptionsControllerGetSubscription<TData = Awaited<ReturnType<typeof subscriptionsControllerGetSubscription>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof subscriptionsControllerGetSubscription>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get subscription details for the current organization
 */

export function useSubscriptionsControllerGetSubscription<TData = Awaited<ReturnType<typeof subscriptionsControllerGetSubscription>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof subscriptionsControllerGetSubscription>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubscriptionsControllerGetSubscriptionQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a new subscription for the current organization
 */
export const subscriptionsControllerCreateSubscription = (
    createSubscriptionRequestDto: CreateSubscriptionRequestDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<SubscriptionResponseDto>(
      {url: `/subscriptions`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createSubscriptionRequestDto, signal
    },
      );
    }
  


export const getSubscriptionsControllerCreateSubscriptionMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof subscriptionsControllerCreateSubscription>>, TError,{data: CreateSubscriptionRequestDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof subscriptionsControllerCreateSubscription>>, TError,{data: CreateSubscriptionRequestDto}, TContext> => {

const mutationKey = ['subscriptionsControllerCreateSubscription'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof subscriptionsControllerCreateSubscription>>, {data: CreateSubscriptionRequestDto}> = (props) => {
          const {data} = props ?? {};

          return  subscriptionsControllerCreateSubscription(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SubscriptionsControllerCreateSubscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof subscriptionsControllerCreateSubscription>>>
    export type SubscriptionsControllerCreateSubscriptionMutationBody = CreateSubscriptionRequestDto
    export type SubscriptionsControllerCreateSubscriptionMutationError = void

    /**
 * @summary Create a new subscription for the current organization
 */
export const useSubscriptionsControllerCreateSubscription = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof subscriptionsControllerCreateSubscription>>, TError,{data: CreateSubscriptionRequestDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof subscriptionsControllerCreateSubscription>>,
        TError,
        {data: CreateSubscriptionRequestDto},
        TContext
      > => {

      const mutationOptions = getSubscriptionsControllerCreateSubscriptionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Cancel the subscription for the current organization
 */
export const subscriptionsControllerCancelSubscription = (
    
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/subscriptions`, method: 'DELETE'
    },
      );
    }
  


export const getSubscriptionsControllerCancelSubscriptionMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof subscriptionsControllerCancelSubscription>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof subscriptionsControllerCancelSubscription>>, TError,void, TContext> => {

const mutationKey = ['subscriptionsControllerCancelSubscription'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof subscriptionsControllerCancelSubscription>>, void> = () => {
          

          return  subscriptionsControllerCancelSubscription()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SubscriptionsControllerCancelSubscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof subscriptionsControllerCancelSubscription>>>
    
    export type SubscriptionsControllerCancelSubscriptionMutationError = void

    /**
 * @summary Cancel the subscription for the current organization
 */
export const useSubscriptionsControllerCancelSubscription = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof subscriptionsControllerCancelSubscription>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof subscriptionsControllerCancelSubscription>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getSubscriptionsControllerCancelSubscriptionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Check if the current organization has an active subscription
 */
export const subscriptionsControllerHasActiveSubscription = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<ActiveSubscriptionResponseDto>(
      {url: `/subscriptions/active`, method: 'GET', signal
    },
      );
    }
  

export const getSubscriptionsControllerHasActiveSubscriptionQueryKey = () => {
    return [`/subscriptions/active`] as const;
    }

    
export const getSubscriptionsControllerHasActiveSubscriptionQueryOptions = <TData = Awaited<ReturnType<typeof subscriptionsControllerHasActiveSubscription>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof subscriptionsControllerHasActiveSubscription>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubscriptionsControllerHasActiveSubscriptionQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof subscriptionsControllerHasActiveSubscription>>> = ({ signal }) => subscriptionsControllerHasActiveSubscription(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof subscriptionsControllerHasActiveSubscription>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SubscriptionsControllerHasActiveSubscriptionQueryResult = NonNullable<Awaited<ReturnType<typeof subscriptionsControllerHasActiveSubscription>>>
export type SubscriptionsControllerHasActiveSubscriptionQueryError = void


export function useSubscriptionsControllerHasActiveSubscription<TData = Awaited<ReturnType<typeof subscriptionsControllerHasActiveSubscription>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof subscriptionsControllerHasActiveSubscription>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof subscriptionsControllerHasActiveSubscription>>,
          TError,
          Awaited<ReturnType<typeof subscriptionsControllerHasActiveSubscription>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubscriptionsControllerHasActiveSubscription<TData = Awaited<ReturnType<typeof subscriptionsControllerHasActiveSubscription>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof subscriptionsControllerHasActiveSubscription>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof subscriptionsControllerHasActiveSubscription>>,
          TError,
          Awaited<ReturnType<typeof subscriptionsControllerHasActiveSubscription>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubscriptionsControllerHasActiveSubscription<TData = Awaited<ReturnType<typeof subscriptionsControllerHasActiveSubscription>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof subscriptionsControllerHasActiveSubscription>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Check if the current organization has an active subscription
 */

export function useSubscriptionsControllerHasActiveSubscription<TData = Awaited<ReturnType<typeof subscriptionsControllerHasActiveSubscription>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof subscriptionsControllerHasActiveSubscription>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubscriptionsControllerHasActiveSubscriptionQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get the current price per seat monthly
 */
export const subscriptionsControllerGetCurrentPrice = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<PriceResponseDto>(
      {url: `/subscriptions/price`, method: 'GET', signal
    },
      );
    }
  

export const getSubscriptionsControllerGetCurrentPriceQueryKey = () => {
    return [`/subscriptions/price`] as const;
    }

    
export const getSubscriptionsControllerGetCurrentPriceQueryOptions = <TData = Awaited<ReturnType<typeof subscriptionsControllerGetCurrentPrice>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof subscriptionsControllerGetCurrentPrice>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubscriptionsControllerGetCurrentPriceQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof subscriptionsControllerGetCurrentPrice>>> = ({ signal }) => subscriptionsControllerGetCurrentPrice(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof subscriptionsControllerGetCurrentPrice>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SubscriptionsControllerGetCurrentPriceQueryResult = NonNullable<Awaited<ReturnType<typeof subscriptionsControllerGetCurrentPrice>>>
export type SubscriptionsControllerGetCurrentPriceQueryError = void


export function useSubscriptionsControllerGetCurrentPrice<TData = Awaited<ReturnType<typeof subscriptionsControllerGetCurrentPrice>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof subscriptionsControllerGetCurrentPrice>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof subscriptionsControllerGetCurrentPrice>>,
          TError,
          Awaited<ReturnType<typeof subscriptionsControllerGetCurrentPrice>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubscriptionsControllerGetCurrentPrice<TData = Awaited<ReturnType<typeof subscriptionsControllerGetCurrentPrice>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof subscriptionsControllerGetCurrentPrice>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof subscriptionsControllerGetCurrentPrice>>,
          TError,
          Awaited<ReturnType<typeof subscriptionsControllerGetCurrentPrice>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubscriptionsControllerGetCurrentPrice<TData = Awaited<ReturnType<typeof subscriptionsControllerGetCurrentPrice>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof subscriptionsControllerGetCurrentPrice>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get the current price per seat monthly
 */

export function useSubscriptionsControllerGetCurrentPrice<TData = Awaited<ReturnType<typeof subscriptionsControllerGetCurrentPrice>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof subscriptionsControllerGetCurrentPrice>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubscriptionsControllerGetCurrentPriceQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update the number of seats for the current organization
 */
export const subscriptionsControllerUpdateSeats = (
    updateSeatsDto: UpdateSeatsDto,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/subscriptions/seats`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateSeatsDto
    },
      );
    }
  


export const getSubscriptionsControllerUpdateSeatsMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof subscriptionsControllerUpdateSeats>>, TError,{data: UpdateSeatsDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof subscriptionsControllerUpdateSeats>>, TError,{data: UpdateSeatsDto}, TContext> => {

const mutationKey = ['subscriptionsControllerUpdateSeats'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof subscriptionsControllerUpdateSeats>>, {data: UpdateSeatsDto}> = (props) => {
          const {data} = props ?? {};

          return  subscriptionsControllerUpdateSeats(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SubscriptionsControllerUpdateSeatsMutationResult = NonNullable<Awaited<ReturnType<typeof subscriptionsControllerUpdateSeats>>>
    export type SubscriptionsControllerUpdateSeatsMutationBody = UpdateSeatsDto
    export type SubscriptionsControllerUpdateSeatsMutationError = void

    /**
 * @summary Update the number of seats for the current organization
 */
export const useSubscriptionsControllerUpdateSeats = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof subscriptionsControllerUpdateSeats>>, TError,{data: UpdateSeatsDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof subscriptionsControllerUpdateSeats>>,
        TError,
        {data: UpdateSeatsDto},
        TContext
      > => {

      const mutationOptions = getSubscriptionsControllerUpdateSeatsMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Update the billing information for the current organization
 */
export const subscriptionsControllerUpdateBillingInfo = (
    updateBillingInfoDto: UpdateBillingInfoDto,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/subscriptions/billing-info`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateBillingInfoDto
    },
      );
    }
  


export const getSubscriptionsControllerUpdateBillingInfoMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof subscriptionsControllerUpdateBillingInfo>>, TError,{data: UpdateBillingInfoDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof subscriptionsControllerUpdateBillingInfo>>, TError,{data: UpdateBillingInfoDto}, TContext> => {

const mutationKey = ['subscriptionsControllerUpdateBillingInfo'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof subscriptionsControllerUpdateBillingInfo>>, {data: UpdateBillingInfoDto}> = (props) => {
          const {data} = props ?? {};

          return  subscriptionsControllerUpdateBillingInfo(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SubscriptionsControllerUpdateBillingInfoMutationResult = NonNullable<Awaited<ReturnType<typeof subscriptionsControllerUpdateBillingInfo>>>
    export type SubscriptionsControllerUpdateBillingInfoMutationBody = UpdateBillingInfoDto
    export type SubscriptionsControllerUpdateBillingInfoMutationError = void

    /**
 * @summary Update the billing information for the current organization
 */
export const useSubscriptionsControllerUpdateBillingInfo = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof subscriptionsControllerUpdateBillingInfo>>, TError,{data: UpdateBillingInfoDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof subscriptionsControllerUpdateBillingInfo>>,
        TError,
        {data: UpdateBillingInfoDto},
        TContext
      > => {

      const mutationOptions = getSubscriptionsControllerUpdateBillingInfoMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Uncancel the subscription for the current organization
 */
export const subscriptionsControllerUncancelSubscription = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<void>(
      {url: `/subscriptions/uncancel`, method: 'POST', signal
    },
      );
    }
  


export const getSubscriptionsControllerUncancelSubscriptionMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof subscriptionsControllerUncancelSubscription>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof subscriptionsControllerUncancelSubscription>>, TError,void, TContext> => {

const mutationKey = ['subscriptionsControllerUncancelSubscription'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof subscriptionsControllerUncancelSubscription>>, void> = () => {
          

          return  subscriptionsControllerUncancelSubscription()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SubscriptionsControllerUncancelSubscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof subscriptionsControllerUncancelSubscription>>>
    
    export type SubscriptionsControllerUncancelSubscriptionMutationError = void

    /**
 * @summary Uncancel the subscription for the current organization
 */
export const useSubscriptionsControllerUncancelSubscription = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof subscriptionsControllerUncancelSubscription>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof subscriptionsControllerUncancelSubscription>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getSubscriptionsControllerUncancelSubscriptionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Send an invitation to a user to join an organization with a specific role
 * @summary Create a new invite
 */
export const invitesControllerCreate = (
    createInviteDto: CreateInviteDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<void>(
      {url: `/invites`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createInviteDto, signal
    },
      );
    }
  


export const getInvitesControllerCreateMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invitesControllerCreate>>, TError,{data: CreateInviteDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof invitesControllerCreate>>, TError,{data: CreateInviteDto}, TContext> => {

const mutationKey = ['invitesControllerCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof invitesControllerCreate>>, {data: CreateInviteDto}> = (props) => {
          const {data} = props ?? {};

          return  invitesControllerCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InvitesControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof invitesControllerCreate>>>
    export type InvitesControllerCreateMutationBody = CreateInviteDto
    export type InvitesControllerCreateMutationError = void

    /**
 * @summary Create a new invite
 */
export const useInvitesControllerCreate = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invitesControllerCreate>>, TError,{data: CreateInviteDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof invitesControllerCreate>>,
        TError,
        {data: CreateInviteDto},
        TContext
      > => {

      const mutationOptions = getInvitesControllerCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve all invites for the organization with calculated status and sent date
 * @summary Get all invites for current user's organization
 */
export const invitesControllerGetInvites = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<InviteResponseDto[]>(
      {url: `/invites`, method: 'GET', signal
    },
      );
    }
  

export const getInvitesControllerGetInvitesQueryKey = () => {
    return [`/invites`] as const;
    }

    
export const getInvitesControllerGetInvitesQueryOptions = <TData = Awaited<ReturnType<typeof invitesControllerGetInvites>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invitesControllerGetInvites>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInvitesControllerGetInvitesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof invitesControllerGetInvites>>> = ({ signal }) => invitesControllerGetInvites(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof invitesControllerGetInvites>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type InvitesControllerGetInvitesQueryResult = NonNullable<Awaited<ReturnType<typeof invitesControllerGetInvites>>>
export type InvitesControllerGetInvitesQueryError = void


export function useInvitesControllerGetInvites<TData = Awaited<ReturnType<typeof invitesControllerGetInvites>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof invitesControllerGetInvites>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof invitesControllerGetInvites>>,
          TError,
          Awaited<ReturnType<typeof invitesControllerGetInvites>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInvitesControllerGetInvites<TData = Awaited<ReturnType<typeof invitesControllerGetInvites>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invitesControllerGetInvites>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof invitesControllerGetInvites>>,
          TError,
          Awaited<ReturnType<typeof invitesControllerGetInvites>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInvitesControllerGetInvites<TData = Awaited<ReturnType<typeof invitesControllerGetInvites>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invitesControllerGetInvites>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all invites for current user's organization
 */

export function useInvitesControllerGetInvites<TData = Awaited<ReturnType<typeof invitesControllerGetInvites>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invitesControllerGetInvites>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getInvitesControllerGetInvitesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve invite details including organization name by token
 * @summary Get a single invite by token
 */
export const invitesControllerGetInviteByToken = (
    token: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<InviteDetailResponseDto>(
      {url: `/invites/${token}`, method: 'GET', signal
    },
      );
    }
  

export const getInvitesControllerGetInviteByTokenQueryKey = (token: string,) => {
    return [`/invites/${token}`] as const;
    }

    
export const getInvitesControllerGetInviteByTokenQueryOptions = <TData = Awaited<ReturnType<typeof invitesControllerGetInviteByToken>>, TError = void>(token: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invitesControllerGetInviteByToken>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInvitesControllerGetInviteByTokenQueryKey(token);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof invitesControllerGetInviteByToken>>> = ({ signal }) => invitesControllerGetInviteByToken(token, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(token), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof invitesControllerGetInviteByToken>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type InvitesControllerGetInviteByTokenQueryResult = NonNullable<Awaited<ReturnType<typeof invitesControllerGetInviteByToken>>>
export type InvitesControllerGetInviteByTokenQueryError = void


export function useInvitesControllerGetInviteByToken<TData = Awaited<ReturnType<typeof invitesControllerGetInviteByToken>>, TError = void>(
 token: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof invitesControllerGetInviteByToken>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof invitesControllerGetInviteByToken>>,
          TError,
          Awaited<ReturnType<typeof invitesControllerGetInviteByToken>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInvitesControllerGetInviteByToken<TData = Awaited<ReturnType<typeof invitesControllerGetInviteByToken>>, TError = void>(
 token: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invitesControllerGetInviteByToken>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof invitesControllerGetInviteByToken>>,
          TError,
          Awaited<ReturnType<typeof invitesControllerGetInviteByToken>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInvitesControllerGetInviteByToken<TData = Awaited<ReturnType<typeof invitesControllerGetInviteByToken>>, TError = void>(
 token: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invitesControllerGetInviteByToken>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a single invite by token
 */

export function useInvitesControllerGetInviteByToken<TData = Awaited<ReturnType<typeof invitesControllerGetInviteByToken>>, TError = void>(
 token: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invitesControllerGetInviteByToken>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getInvitesControllerGetInviteByTokenQueryOptions(token,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Accept an invitation using the JWT token
 * @summary Accept an invite
 */
export const invitesControllerAcceptInvite = (
    acceptInviteDto: AcceptInviteDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<AcceptInviteResponseDto>(
      {url: `/invites/accept`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: acceptInviteDto, signal
    },
      );
    }
  


export const getInvitesControllerAcceptInviteMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invitesControllerAcceptInvite>>, TError,{data: AcceptInviteDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof invitesControllerAcceptInvite>>, TError,{data: AcceptInviteDto}, TContext> => {

const mutationKey = ['invitesControllerAcceptInvite'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof invitesControllerAcceptInvite>>, {data: AcceptInviteDto}> = (props) => {
          const {data} = props ?? {};

          return  invitesControllerAcceptInvite(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InvitesControllerAcceptInviteMutationResult = NonNullable<Awaited<ReturnType<typeof invitesControllerAcceptInvite>>>
    export type InvitesControllerAcceptInviteMutationBody = AcceptInviteDto
    export type InvitesControllerAcceptInviteMutationError = void

    /**
 * @summary Accept an invite
 */
export const useInvitesControllerAcceptInvite = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invitesControllerAcceptInvite>>, TError,{data: AcceptInviteDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof invitesControllerAcceptInvite>>,
        TError,
        {data: AcceptInviteDto},
        TContext
      > => {

      const mutationOptions = getInvitesControllerAcceptInviteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete an invitation (only allowed by the user who created it)
 * @summary Delete an invite
 */
export const invitesControllerDeleteInvite = (
    id: string,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/invites/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getInvitesControllerDeleteInviteMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invitesControllerDeleteInvite>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof invitesControllerDeleteInvite>>, TError,{id: string}, TContext> => {

const mutationKey = ['invitesControllerDeleteInvite'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof invitesControllerDeleteInvite>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  invitesControllerDeleteInvite(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InvitesControllerDeleteInviteMutationResult = NonNullable<Awaited<ReturnType<typeof invitesControllerDeleteInvite>>>
    
    export type InvitesControllerDeleteInviteMutationError = void

    /**
 * @summary Delete an invite
 */
export const useInvitesControllerDeleteInvite = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invitesControllerDeleteInvite>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof invitesControllerDeleteInvite>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getInvitesControllerDeleteInviteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const storageControllerUploadFile = (
    storageControllerUploadFileBody: StorageControllerUploadFileBody,
 signal?: AbortSignal
) => {
      
      const formData = new FormData();
if(storageControllerUploadFileBody.file !== undefined) {
 formData.append(`file`, storageControllerUploadFileBody.file)
 }

      return customAxiosInstance<void>(
      {url: `/storage/upload`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      );
    }
  


export const getStorageControllerUploadFileMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof storageControllerUploadFile>>, TError,{data: StorageControllerUploadFileBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof storageControllerUploadFile>>, TError,{data: StorageControllerUploadFileBody}, TContext> => {

const mutationKey = ['storageControllerUploadFile'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof storageControllerUploadFile>>, {data: StorageControllerUploadFileBody}> = (props) => {
          const {data} = props ?? {};

          return  storageControllerUploadFile(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type StorageControllerUploadFileMutationResult = NonNullable<Awaited<ReturnType<typeof storageControllerUploadFile>>>
    export type StorageControllerUploadFileMutationBody = StorageControllerUploadFileBody
    export type StorageControllerUploadFileMutationError = unknown

    export const useStorageControllerUploadFile = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof storageControllerUploadFile>>, TError,{data: StorageControllerUploadFileBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof storageControllerUploadFile>>,
        TError,
        {data: StorageControllerUploadFileBody},
        TContext
      > => {

      const mutationOptions = getStorageControllerUploadFileMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const storageControllerGetFile = (
    objectName: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<void>(
      {url: `/storage/${objectName}`, method: 'GET', signal
    },
      );
    }
  

export const getStorageControllerGetFileQueryKey = (objectName: string,) => {
    return [`/storage/${objectName}`] as const;
    }

    
export const getStorageControllerGetFileQueryOptions = <TData = Awaited<ReturnType<typeof storageControllerGetFile>>, TError = unknown>(objectName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageControllerGetFile>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStorageControllerGetFileQueryKey(objectName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof storageControllerGetFile>>> = ({ signal }) => storageControllerGetFile(objectName, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(objectName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof storageControllerGetFile>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StorageControllerGetFileQueryResult = NonNullable<Awaited<ReturnType<typeof storageControllerGetFile>>>
export type StorageControllerGetFileQueryError = unknown


export function useStorageControllerGetFile<TData = Awaited<ReturnType<typeof storageControllerGetFile>>, TError = unknown>(
 objectName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageControllerGetFile>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof storageControllerGetFile>>,
          TError,
          Awaited<ReturnType<typeof storageControllerGetFile>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStorageControllerGetFile<TData = Awaited<ReturnType<typeof storageControllerGetFile>>, TError = unknown>(
 objectName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageControllerGetFile>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof storageControllerGetFile>>,
          TError,
          Awaited<ReturnType<typeof storageControllerGetFile>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStorageControllerGetFile<TData = Awaited<ReturnType<typeof storageControllerGetFile>>, TError = unknown>(
 objectName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageControllerGetFile>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useStorageControllerGetFile<TData = Awaited<ReturnType<typeof storageControllerGetFile>>, TError = unknown>(
 objectName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageControllerGetFile>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStorageControllerGetFileQueryOptions(objectName,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const storageControllerDeleteFile = (
    objectName: string,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/storage/${objectName}`, method: 'DELETE'
    },
      );
    }
  


export const getStorageControllerDeleteFileMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof storageControllerDeleteFile>>, TError,{objectName: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof storageControllerDeleteFile>>, TError,{objectName: string}, TContext> => {

const mutationKey = ['storageControllerDeleteFile'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof storageControllerDeleteFile>>, {objectName: string}> = (props) => {
          const {objectName} = props ?? {};

          return  storageControllerDeleteFile(objectName,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type StorageControllerDeleteFileMutationResult = NonNullable<Awaited<ReturnType<typeof storageControllerDeleteFile>>>
    
    export type StorageControllerDeleteFileMutationError = unknown

    export const useStorageControllerDeleteFile = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof storageControllerDeleteFile>>, TError,{objectName: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof storageControllerDeleteFile>>,
        TError,
        {objectName: string},
        TContext
      > => {

      const mutationOptions = getStorageControllerDeleteFileMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const storageControllerGetPresignedUrl = (
    objectName: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<void>(
      {url: `/storage/url/${objectName}`, method: 'GET', signal
    },
      );
    }
  

export const getStorageControllerGetPresignedUrlQueryKey = (objectName: string,) => {
    return [`/storage/url/${objectName}`] as const;
    }

    
export const getStorageControllerGetPresignedUrlQueryOptions = <TData = Awaited<ReturnType<typeof storageControllerGetPresignedUrl>>, TError = unknown>(objectName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageControllerGetPresignedUrl>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStorageControllerGetPresignedUrlQueryKey(objectName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof storageControllerGetPresignedUrl>>> = ({ signal }) => storageControllerGetPresignedUrl(objectName, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(objectName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof storageControllerGetPresignedUrl>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StorageControllerGetPresignedUrlQueryResult = NonNullable<Awaited<ReturnType<typeof storageControllerGetPresignedUrl>>>
export type StorageControllerGetPresignedUrlQueryError = unknown


export function useStorageControllerGetPresignedUrl<TData = Awaited<ReturnType<typeof storageControllerGetPresignedUrl>>, TError = unknown>(
 objectName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageControllerGetPresignedUrl>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof storageControllerGetPresignedUrl>>,
          TError,
          Awaited<ReturnType<typeof storageControllerGetPresignedUrl>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStorageControllerGetPresignedUrl<TData = Awaited<ReturnType<typeof storageControllerGetPresignedUrl>>, TError = unknown>(
 objectName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageControllerGetPresignedUrl>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof storageControllerGetPresignedUrl>>,
          TError,
          Awaited<ReturnType<typeof storageControllerGetPresignedUrl>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStorageControllerGetPresignedUrl<TData = Awaited<ReturnType<typeof storageControllerGetPresignedUrl>>, TError = unknown>(
 objectName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageControllerGetPresignedUrl>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useStorageControllerGetPresignedUrl<TData = Awaited<ReturnType<typeof storageControllerGetPresignedUrl>>, TError = unknown>(
 objectName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageControllerGetPresignedUrl>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStorageControllerGetPresignedUrlQueryOptions(objectName,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a new prompt
 */
export const promptsControllerCreate = (
    createPromptDto: CreatePromptDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<PromptResponseDto>(
      {url: `/prompts`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createPromptDto, signal
    },
      );
    }
  


export const getPromptsControllerCreateMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof promptsControllerCreate>>, TError,{data: CreatePromptDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof promptsControllerCreate>>, TError,{data: CreatePromptDto}, TContext> => {

const mutationKey = ['promptsControllerCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof promptsControllerCreate>>, {data: CreatePromptDto}> = (props) => {
          const {data} = props ?? {};

          return  promptsControllerCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PromptsControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof promptsControllerCreate>>>
    export type PromptsControllerCreateMutationBody = CreatePromptDto
    export type PromptsControllerCreateMutationError = void

    /**
 * @summary Create a new prompt
 */
export const usePromptsControllerCreate = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof promptsControllerCreate>>, TError,{data: CreatePromptDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof promptsControllerCreate>>,
        TError,
        {data: CreatePromptDto},
        TContext
      > => {

      const mutationOptions = getPromptsControllerCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get all prompts for the current user
 */
export const promptsControllerFindAll = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<PromptResponseDto[]>(
      {url: `/prompts`, method: 'GET', signal
    },
      );
    }
  

export const getPromptsControllerFindAllQueryKey = () => {
    return [`/prompts`] as const;
    }

    
export const getPromptsControllerFindAllQueryOptions = <TData = Awaited<ReturnType<typeof promptsControllerFindAll>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof promptsControllerFindAll>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPromptsControllerFindAllQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof promptsControllerFindAll>>> = ({ signal }) => promptsControllerFindAll(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof promptsControllerFindAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PromptsControllerFindAllQueryResult = NonNullable<Awaited<ReturnType<typeof promptsControllerFindAll>>>
export type PromptsControllerFindAllQueryError = void


export function usePromptsControllerFindAll<TData = Awaited<ReturnType<typeof promptsControllerFindAll>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof promptsControllerFindAll>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof promptsControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof promptsControllerFindAll>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePromptsControllerFindAll<TData = Awaited<ReturnType<typeof promptsControllerFindAll>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof promptsControllerFindAll>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof promptsControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof promptsControllerFindAll>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePromptsControllerFindAll<TData = Awaited<ReturnType<typeof promptsControllerFindAll>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof promptsControllerFindAll>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all prompts for the current user
 */

export function usePromptsControllerFindAll<TData = Awaited<ReturnType<typeof promptsControllerFindAll>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof promptsControllerFindAll>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPromptsControllerFindAllQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get a prompt by ID
 */
export const promptsControllerFindOne = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<PromptResponseDto>(
      {url: `/prompts/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getPromptsControllerFindOneQueryKey = (id: string,) => {
    return [`/prompts/${id}`] as const;
    }

    
export const getPromptsControllerFindOneQueryOptions = <TData = Awaited<ReturnType<typeof promptsControllerFindOne>>, TError = void>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof promptsControllerFindOne>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPromptsControllerFindOneQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof promptsControllerFindOne>>> = ({ signal }) => promptsControllerFindOne(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof promptsControllerFindOne>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PromptsControllerFindOneQueryResult = NonNullable<Awaited<ReturnType<typeof promptsControllerFindOne>>>
export type PromptsControllerFindOneQueryError = void


export function usePromptsControllerFindOne<TData = Awaited<ReturnType<typeof promptsControllerFindOne>>, TError = void>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof promptsControllerFindOne>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof promptsControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof promptsControllerFindOne>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePromptsControllerFindOne<TData = Awaited<ReturnType<typeof promptsControllerFindOne>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof promptsControllerFindOne>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof promptsControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof promptsControllerFindOne>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePromptsControllerFindOne<TData = Awaited<ReturnType<typeof promptsControllerFindOne>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof promptsControllerFindOne>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a prompt by ID
 */

export function usePromptsControllerFindOne<TData = Awaited<ReturnType<typeof promptsControllerFindOne>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof promptsControllerFindOne>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPromptsControllerFindOneQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update a prompt
 */
export const promptsControllerUpdate = (
    id: string,
    updatePromptDto: UpdatePromptDto,
 ) => {
      
      
      return customAxiosInstance<PromptResponseDto>(
      {url: `/prompts/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updatePromptDto
    },
      );
    }
  


export const getPromptsControllerUpdateMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof promptsControllerUpdate>>, TError,{id: string;data: UpdatePromptDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof promptsControllerUpdate>>, TError,{id: string;data: UpdatePromptDto}, TContext> => {

const mutationKey = ['promptsControllerUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof promptsControllerUpdate>>, {id: string;data: UpdatePromptDto}> = (props) => {
          const {id,data} = props ?? {};

          return  promptsControllerUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PromptsControllerUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof promptsControllerUpdate>>>
    export type PromptsControllerUpdateMutationBody = UpdatePromptDto
    export type PromptsControllerUpdateMutationError = void

    /**
 * @summary Update a prompt
 */
export const usePromptsControllerUpdate = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof promptsControllerUpdate>>, TError,{id: string;data: UpdatePromptDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof promptsControllerUpdate>>,
        TError,
        {id: string;data: UpdatePromptDto},
        TContext
      > => {

      const mutationOptions = getPromptsControllerUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Delete a prompt
 */
export const promptsControllerDelete = (
    id: string,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/prompts/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getPromptsControllerDeleteMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof promptsControllerDelete>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof promptsControllerDelete>>, TError,{id: string}, TContext> => {

const mutationKey = ['promptsControllerDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof promptsControllerDelete>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  promptsControllerDelete(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PromptsControllerDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof promptsControllerDelete>>>
    
    export type PromptsControllerDeleteMutationError = void

    /**
 * @summary Delete a prompt
 */
export const usePromptsControllerDelete = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof promptsControllerDelete>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof promptsControllerDelete>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getPromptsControllerDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Authenticate user with email and password. Sets authentication cookies on successful login.
 * @summary User login
 */
export const authenticationControllerLogin = (
    loginDto: LoginDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<SuccessResponseDto>(
      {url: `/auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: loginDto, signal
    },
      );
    }
  


export const getAuthenticationControllerLoginMutationOptions = <TError = ErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticationControllerLogin>>, TError,{data: LoginDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof authenticationControllerLogin>>, TError,{data: LoginDto}, TContext> => {

const mutationKey = ['authenticationControllerLogin'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authenticationControllerLogin>>, {data: LoginDto}> = (props) => {
          const {data} = props ?? {};

          return  authenticationControllerLogin(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthenticationControllerLoginMutationResult = NonNullable<Awaited<ReturnType<typeof authenticationControllerLogin>>>
    export type AuthenticationControllerLoginMutationBody = LoginDto
    export type AuthenticationControllerLoginMutationError = ErrorResponseDto

    /**
 * @summary User login
 */
export const useAuthenticationControllerLogin = <TError = ErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticationControllerLogin>>, TError,{data: LoginDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authenticationControllerLogin>>,
        TError,
        {data: LoginDto},
        TContext
      > => {

      const mutationOptions = getAuthenticationControllerLoginMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Register a new user account with email, password, and organization name. Automatically logs in the user and sets authentication cookies.
 * @summary User registration
 */
export const authenticationControllerRegister = (
    registerDto: RegisterDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<SuccessResponseDto>(
      {url: `/auth/register`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: registerDto, signal
    },
      );
    }
  


export const getAuthenticationControllerRegisterMutationOptions = <TError = ErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticationControllerRegister>>, TError,{data: RegisterDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof authenticationControllerRegister>>, TError,{data: RegisterDto}, TContext> => {

const mutationKey = ['authenticationControllerRegister'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authenticationControllerRegister>>, {data: RegisterDto}> = (props) => {
          const {data} = props ?? {};

          return  authenticationControllerRegister(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthenticationControllerRegisterMutationResult = NonNullable<Awaited<ReturnType<typeof authenticationControllerRegister>>>
    export type AuthenticationControllerRegisterMutationBody = RegisterDto
    export type AuthenticationControllerRegisterMutationError = ErrorResponseDto

    /**
 * @summary User registration
 */
export const useAuthenticationControllerRegister = <TError = ErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticationControllerRegister>>, TError,{data: RegisterDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authenticationControllerRegister>>,
        TError,
        {data: RegisterDto},
        TContext
      > => {

      const mutationOptions = getAuthenticationControllerRegisterMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Refresh expired access tokens using the refresh token stored in cookies. Returns new authentication cookies.
 * @summary Refresh authentication tokens
 */
export const authenticationControllerRefresh = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<SuccessResponseDto>(
      {url: `/auth/refresh`, method: 'POST', signal
    },
      );
    }
  


export const getAuthenticationControllerRefreshMutationOptions = <TError = ErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticationControllerRefresh>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof authenticationControllerRefresh>>, TError,void, TContext> => {

const mutationKey = ['authenticationControllerRefresh'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authenticationControllerRefresh>>, void> = () => {
          

          return  authenticationControllerRefresh()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthenticationControllerRefreshMutationResult = NonNullable<Awaited<ReturnType<typeof authenticationControllerRefresh>>>
    
    export type AuthenticationControllerRefreshMutationError = ErrorResponseDto

    /**
 * @summary Refresh authentication tokens
 */
export const useAuthenticationControllerRefresh = <TError = ErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticationControllerRefresh>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authenticationControllerRefresh>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getAuthenticationControllerRefreshMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get the current authenticated user's email and role. If access token is expired but refresh token is valid, automatically refreshes tokens and sets new cookies.
 * @summary Get current user information
 */
export const authenticationControllerMe = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<MeResponseDto>(
      {url: `/auth/me`, method: 'GET', signal
    },
      );
    }
  

export const getAuthenticationControllerMeQueryKey = () => {
    return [`/auth/me`] as const;
    }

    
export const getAuthenticationControllerMeQueryOptions = <TData = Awaited<ReturnType<typeof authenticationControllerMe>>, TError = ErrorResponseDto>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authenticationControllerMe>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthenticationControllerMeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authenticationControllerMe>>> = ({ signal }) => authenticationControllerMe(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof authenticationControllerMe>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AuthenticationControllerMeQueryResult = NonNullable<Awaited<ReturnType<typeof authenticationControllerMe>>>
export type AuthenticationControllerMeQueryError = ErrorResponseDto


export function useAuthenticationControllerMe<TData = Awaited<ReturnType<typeof authenticationControllerMe>>, TError = ErrorResponseDto>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof authenticationControllerMe>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authenticationControllerMe>>,
          TError,
          Awaited<ReturnType<typeof authenticationControllerMe>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthenticationControllerMe<TData = Awaited<ReturnType<typeof authenticationControllerMe>>, TError = ErrorResponseDto>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authenticationControllerMe>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authenticationControllerMe>>,
          TError,
          Awaited<ReturnType<typeof authenticationControllerMe>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthenticationControllerMe<TData = Awaited<ReturnType<typeof authenticationControllerMe>>, TError = ErrorResponseDto>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authenticationControllerMe>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get current user information
 */

export function useAuthenticationControllerMe<TData = Awaited<ReturnType<typeof authenticationControllerMe>>, TError = ErrorResponseDto>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authenticationControllerMe>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAuthenticationControllerMeQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Log out the current user by clearing authentication cookies.
 * @summary User logout
 */
export const authenticationControllerLogout = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<SuccessResponseDto>(
      {url: `/auth/logout`, method: 'POST', signal
    },
      );
    }
  


export const getAuthenticationControllerLogoutMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticationControllerLogout>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof authenticationControllerLogout>>, TError,void, TContext> => {

const mutationKey = ['authenticationControllerLogout'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authenticationControllerLogout>>, void> = () => {
          

          return  authenticationControllerLogout()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthenticationControllerLogoutMutationResult = NonNullable<Awaited<ReturnType<typeof authenticationControllerLogout>>>
    
    export type AuthenticationControllerLogoutMutationError = unknown

    /**
 * @summary User logout
 */
export const useAuthenticationControllerLogout = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticationControllerLogout>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authenticationControllerLogout>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getAuthenticationControllerLogoutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const adminControllerGetAllModels = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<void>(
      {url: `/admin/models`, method: 'GET', signal
    },
      );
    }
  

export const getAdminControllerGetAllModelsQueryKey = () => {
    return [`/admin/models`] as const;
    }

    
export const getAdminControllerGetAllModelsQueryOptions = <TData = Awaited<ReturnType<typeof adminControllerGetAllModels>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetAllModels>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAdminControllerGetAllModelsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminControllerGetAllModels>>> = ({ signal }) => adminControllerGetAllModels(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetAllModels>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AdminControllerGetAllModelsQueryResult = NonNullable<Awaited<ReturnType<typeof adminControllerGetAllModels>>>
export type AdminControllerGetAllModelsQueryError = unknown


export function useAdminControllerGetAllModels<TData = Awaited<ReturnType<typeof adminControllerGetAllModels>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetAllModels>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminControllerGetAllModels>>,
          TError,
          Awaited<ReturnType<typeof adminControllerGetAllModels>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAdminControllerGetAllModels<TData = Awaited<ReturnType<typeof adminControllerGetAllModels>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetAllModels>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminControllerGetAllModels>>,
          TError,
          Awaited<ReturnType<typeof adminControllerGetAllModels>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAdminControllerGetAllModels<TData = Awaited<ReturnType<typeof adminControllerGetAllModels>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetAllModels>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAdminControllerGetAllModels<TData = Awaited<ReturnType<typeof adminControllerGetAllModels>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetAllModels>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAdminControllerGetAllModelsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const adminControllerGetModel = (
    params: AdminControllerGetModelParams,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<void>(
      {url: `/admin/model`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getAdminControllerGetModelQueryKey = (params: AdminControllerGetModelParams,) => {
    return [`/admin/model`, ...(params ? [params]: [])] as const;
    }

    
export const getAdminControllerGetModelQueryOptions = <TData = Awaited<ReturnType<typeof adminControllerGetModel>>, TError = unknown>(params: AdminControllerGetModelParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetModel>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAdminControllerGetModelQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminControllerGetModel>>> = ({ signal }) => adminControllerGetModel(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetModel>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AdminControllerGetModelQueryResult = NonNullable<Awaited<ReturnType<typeof adminControllerGetModel>>>
export type AdminControllerGetModelQueryError = unknown


export function useAdminControllerGetModel<TData = Awaited<ReturnType<typeof adminControllerGetModel>>, TError = unknown>(
 params: AdminControllerGetModelParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetModel>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminControllerGetModel>>,
          TError,
          Awaited<ReturnType<typeof adminControllerGetModel>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAdminControllerGetModel<TData = Awaited<ReturnType<typeof adminControllerGetModel>>, TError = unknown>(
 params: AdminControllerGetModelParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetModel>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminControllerGetModel>>,
          TError,
          Awaited<ReturnType<typeof adminControllerGetModel>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAdminControllerGetModel<TData = Awaited<ReturnType<typeof adminControllerGetModel>>, TError = unknown>(
 params: AdminControllerGetModelParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetModel>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAdminControllerGetModel<TData = Awaited<ReturnType<typeof adminControllerGetModel>>, TError = unknown>(
 params: AdminControllerGetModelParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminControllerGetModel>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAdminControllerGetModelQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const adminControllerCreateLanguageModel = (
    createLanguageModelDto: CreateLanguageModelDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<void>(
      {url: `/admin/language-models`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createLanguageModelDto, signal
    },
      );
    }
  


export const getAdminControllerCreateLanguageModelMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminControllerCreateLanguageModel>>, TError,{data: CreateLanguageModelDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof adminControllerCreateLanguageModel>>, TError,{data: CreateLanguageModelDto}, TContext> => {

const mutationKey = ['adminControllerCreateLanguageModel'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminControllerCreateLanguageModel>>, {data: CreateLanguageModelDto}> = (props) => {
          const {data} = props ?? {};

          return  adminControllerCreateLanguageModel(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminControllerCreateLanguageModelMutationResult = NonNullable<Awaited<ReturnType<typeof adminControllerCreateLanguageModel>>>
    export type AdminControllerCreateLanguageModelMutationBody = CreateLanguageModelDto
    export type AdminControllerCreateLanguageModelMutationError = unknown

    export const useAdminControllerCreateLanguageModel = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminControllerCreateLanguageModel>>, TError,{data: CreateLanguageModelDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminControllerCreateLanguageModel>>,
        TError,
        {data: CreateLanguageModelDto},
        TContext
      > => {

      const mutationOptions = getAdminControllerCreateLanguageModelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const adminControllerCreateEmbeddingModel = (
    createEmbeddingModelDto: CreateEmbeddingModelDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<void>(
      {url: `/admin/embedding-models`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createEmbeddingModelDto, signal
    },
      );
    }
  


export const getAdminControllerCreateEmbeddingModelMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminControllerCreateEmbeddingModel>>, TError,{data: CreateEmbeddingModelDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof adminControllerCreateEmbeddingModel>>, TError,{data: CreateEmbeddingModelDto}, TContext> => {

const mutationKey = ['adminControllerCreateEmbeddingModel'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminControllerCreateEmbeddingModel>>, {data: CreateEmbeddingModelDto}> = (props) => {
          const {data} = props ?? {};

          return  adminControllerCreateEmbeddingModel(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminControllerCreateEmbeddingModelMutationResult = NonNullable<Awaited<ReturnType<typeof adminControllerCreateEmbeddingModel>>>
    export type AdminControllerCreateEmbeddingModelMutationBody = CreateEmbeddingModelDto
    export type AdminControllerCreateEmbeddingModelMutationError = unknown

    export const useAdminControllerCreateEmbeddingModel = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminControllerCreateEmbeddingModel>>, TError,{data: CreateEmbeddingModelDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminControllerCreateEmbeddingModel>>,
        TError,
        {data: CreateEmbeddingModelDto},
        TContext
      > => {

      const mutationOptions = getAdminControllerCreateEmbeddingModelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const adminControllerUpdateLanguageModel = (
    id: string,
    updateLanguageModelDto: UpdateLanguageModelDto,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/admin/language-models/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateLanguageModelDto
    },
      );
    }
  


export const getAdminControllerUpdateLanguageModelMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminControllerUpdateLanguageModel>>, TError,{id: string;data: UpdateLanguageModelDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof adminControllerUpdateLanguageModel>>, TError,{id: string;data: UpdateLanguageModelDto}, TContext> => {

const mutationKey = ['adminControllerUpdateLanguageModel'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminControllerUpdateLanguageModel>>, {id: string;data: UpdateLanguageModelDto}> = (props) => {
          const {id,data} = props ?? {};

          return  adminControllerUpdateLanguageModel(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminControllerUpdateLanguageModelMutationResult = NonNullable<Awaited<ReturnType<typeof adminControllerUpdateLanguageModel>>>
    export type AdminControllerUpdateLanguageModelMutationBody = UpdateLanguageModelDto
    export type AdminControllerUpdateLanguageModelMutationError = unknown

    export const useAdminControllerUpdateLanguageModel = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminControllerUpdateLanguageModel>>, TError,{id: string;data: UpdateLanguageModelDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminControllerUpdateLanguageModel>>,
        TError,
        {id: string;data: UpdateLanguageModelDto},
        TContext
      > => {

      const mutationOptions = getAdminControllerUpdateLanguageModelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const adminControllerUpdateEmbeddingModel = (
    id: string,
    updateEmbeddingModelDto: UpdateEmbeddingModelDto,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/admin/embedding-models/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateEmbeddingModelDto
    },
      );
    }
  


export const getAdminControllerUpdateEmbeddingModelMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminControllerUpdateEmbeddingModel>>, TError,{id: string;data: UpdateEmbeddingModelDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof adminControllerUpdateEmbeddingModel>>, TError,{id: string;data: UpdateEmbeddingModelDto}, TContext> => {

const mutationKey = ['adminControllerUpdateEmbeddingModel'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminControllerUpdateEmbeddingModel>>, {id: string;data: UpdateEmbeddingModelDto}> = (props) => {
          const {id,data} = props ?? {};

          return  adminControllerUpdateEmbeddingModel(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminControllerUpdateEmbeddingModelMutationResult = NonNullable<Awaited<ReturnType<typeof adminControllerUpdateEmbeddingModel>>>
    export type AdminControllerUpdateEmbeddingModelMutationBody = UpdateEmbeddingModelDto
    export type AdminControllerUpdateEmbeddingModelMutationError = unknown

    export const useAdminControllerUpdateEmbeddingModel = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminControllerUpdateEmbeddingModel>>, TError,{id: string;data: UpdateEmbeddingModelDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminControllerUpdateEmbeddingModel>>,
        TError,
        {id: string;data: UpdateEmbeddingModelDto},
        TContext
      > => {

      const mutationOptions = getAdminControllerUpdateEmbeddingModelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const adminControllerDeleteModel = (
    id: string,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/admin/models/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getAdminControllerDeleteModelMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminControllerDeleteModel>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof adminControllerDeleteModel>>, TError,{id: string}, TContext> => {

const mutationKey = ['adminControllerDeleteModel'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminControllerDeleteModel>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  adminControllerDeleteModel(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminControllerDeleteModelMutationResult = NonNullable<Awaited<ReturnType<typeof adminControllerDeleteModel>>>
    
    export type AdminControllerDeleteModelMutationError = unknown

    export const useAdminControllerDeleteModel = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminControllerDeleteModel>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminControllerDeleteModel>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getAdminControllerDeleteModelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
