/**
 * Generated by orval v7.9.0 ðŸº
 * Do not edit manually.
 * Ayunis Core API
 * The Ayunis Core API description
 * OpenAPI spec version: 1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AcceptInviteDto,
  AcceptInviteResponseDto,
  ActiveSubscriptionResponseDto,
  AddTeamMemberDto,
  AgentResponseDto,
  AgentSourceResponseDto,
  AgentsControllerAddFileSourceBody,
  ConfirmEmailDto,
  CreateAgentDto,
  CreateAgentShareDto,
  CreateBulkInvitesDto,
  CreateBulkInvitesResponseDto,
  CreateCustomIntegrationDto,
  CreateEmbeddingModelRequestDto,
  CreateInviteDto,
  CreateInviteResponseDto,
  CreateLanguageModelRequestDto,
  CreateOrgRequestDto,
  CreatePermittedModelDto,
  CreatePredefinedIntegrationDto,
  CreatePromptDto,
  CreateSkillDto,
  CreateSubscriptionRequestDto,
  CreateTeamDto,
  CreateThreadDto,
  CreateTrialRequestDto,
  CreateUserDto,
  DeleteAllPendingInvitesResponseDto,
  EmbeddingModelEnabledResponseDto,
  EmbeddingModelResponseDto,
  ErrorResponseDto,
  ForgotPasswordDto,
  GetThreadResponseDto,
  GetThreadsResponseDto,
  InstallAgentFromMarketplaceDto,
  InviteDetailResponseDto,
  InvitesControllerGetInvitesParams,
  IsCloudResponseDto,
  LanguageModelResponseDto,
  LoginDto,
  MarketplaceAgentResponseDto,
  McpIntegrationResponseDto,
  MeResponseDto,
  ModelDistributionResponseDto,
  ModelProviderInfoResponseDto,
  ModelWithConfigResponseDto,
  PaginatedInvitesListResponseDto,
  PaginatedTeamMembersResponseDto,
  PaginatedUsersListResponseDto,
  PermittedLanguageModelResponseDto,
  PermittedLanguageModelResponseDtoNullable,
  PredefinedConfigResponseDto,
  PriceResponseDto,
  PromptResponseDto,
  ProviderUsageChartResponseDto,
  ProviderUsageResponseDto,
  RegisterDto,
  ResendEmailConfirmationDto,
  ResetPasswordDto,
  RetrieveUrlDto,
  RunsControllerSendMessage200,
  RunsControllerSendMessageBody,
  SetOrgDefaultModelDto,
  SetUserDefaultModelDto,
  ShareResponseDto,
  SharesControllerGetSharesParams,
  SkillResponseDto,
  SkillSourceResponseDto,
  SkillsControllerAddFileSourceBody,
  StorageControllerUploadFileBody,
  SubscriptionResponseDto,
  SubscriptionResponseDtoNullable,
  SuccessResponseDto,
  SuperAdminGlobalUsageControllerGetGlobalModelDistributionParams,
  SuperAdminGlobalUsageControllerGetGlobalProviderUsageChartParams,
  SuperAdminModelsControllerGetAllCatalogModels200Item,
  SuperAdminModelsControllerGetCatalogModelById200,
  SuperAdminModelsControllerGetPermittedModels200Item,
  SuperAdminModelsControllerUpdatePermittedModel200,
  SuperAdminOrgListResponseDto,
  SuperAdminOrgResponseDto,
  SuperAdminOrgsControllerGetAllOrgsParams,
  SuperAdminTrialResponseDto,
  SuperAdminTrialResponseDtoNullable,
  SuperAdminUsageControllerGetModelDistributionParams,
  SuperAdminUsageControllerGetUsageStatsParams,
  SuperAdminUsageDataControllerGetProviderUsageChartParams,
  SuperAdminUsageDataControllerGetProviderUsageParams,
  SuperAdminUsageDataControllerGetUserUsageParams,
  SuperAdminUsersControllerGetUsersByOrgIdParams,
  TeamMemberResponseDto,
  TeamResponseDto,
  TeamsControllerListTeamMembersParams,
  ThreadsControllerAddFileSourceBody,
  ThreadsControllerFindAllParams,
  ThreadsControllerGetThreadSources200Item,
  TranscriptionResponseDto,
  TranscriptionsControllerTranscribeBody,
  UpdateAgentDto,
  UpdateBillingInfoDto,
  UpdateEmbeddingModelRequestDto,
  UpdateLanguageModelRequestDto,
  UpdateMcpIntegrationDto,
  UpdatePasswordDto,
  UpdatePermittedModelDto,
  UpdatePromptDto,
  UpdateSeatsDto,
  UpdateSkillDto,
  UpdateTeamDto,
  UpdateThreadTitleDto,
  UpdateTrialRequestDto,
  UpdateUserNameDto,
  UpdateUserRoleDto,
  UploadFileResponseDto,
  UpsertUserSystemPromptDto,
  UsageConfigResponseDto,
  UsageControllerGetModelDistributionParams,
  UsageControllerGetProviderUsageChartParams,
  UsageControllerGetProviderUsageParams,
  UsageControllerGetUsageStatsParams,
  UsageControllerGetUserUsageParams,
  UsageStatsResponseDto,
  UserControllerGetUsersInOrganizationParams,
  UserControllerValidateResetToken200,
  UserControllerValidateResetTokenParams,
  UserResponseDto,
  UserSystemPromptResponseDto,
  UserUsageResponseDto,
  ValidationResponseDto
} from './ayunisCoreAPI.schemas';

import { customAxiosInstance } from '../client';




/**
 * @summary Check if the deployment is running in a cloud environment
 */
export const appControllerIsCloud = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<IsCloudResponseDto>(
      {url: `/`, method: 'GET', signal
    },
      );
    }
  

export const getAppControllerIsCloudQueryKey = () => {
    return [`/`] as const;
    }

    
export const getAppControllerIsCloudQueryOptions = <TData = Awaited<ReturnType<typeof appControllerIsCloud>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerIsCloud>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAppControllerIsCloudQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof appControllerIsCloud>>> = ({ signal }) => appControllerIsCloud(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof appControllerIsCloud>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AppControllerIsCloudQueryResult = NonNullable<Awaited<ReturnType<typeof appControllerIsCloud>>>
export type AppControllerIsCloudQueryError = unknown


export function useAppControllerIsCloud<TData = Awaited<ReturnType<typeof appControllerIsCloud>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerIsCloud>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof appControllerIsCloud>>,
          TError,
          Awaited<ReturnType<typeof appControllerIsCloud>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAppControllerIsCloud<TData = Awaited<ReturnType<typeof appControllerIsCloud>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerIsCloud>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof appControllerIsCloud>>,
          TError,
          Awaited<ReturnType<typeof appControllerIsCloud>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAppControllerIsCloud<TData = Awaited<ReturnType<typeof appControllerIsCloud>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerIsCloud>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Check if the deployment is running in a cloud environment
 */

export function useAppControllerIsCloud<TData = Awaited<ReturnType<typeof appControllerIsCloud>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerIsCloud>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAppControllerIsCloudQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Check if the deployment is healthy
 */
export const appControllerHealth = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<void>(
      {url: `/health`, method: 'GET', signal
    },
      );
    }
  

export const getAppControllerHealthQueryKey = () => {
    return [`/health`] as const;
    }

    
export const getAppControllerHealthQueryOptions = <TData = Awaited<ReturnType<typeof appControllerHealth>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerHealth>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAppControllerHealthQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof appControllerHealth>>> = ({ signal }) => appControllerHealth(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof appControllerHealth>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AppControllerHealthQueryResult = NonNullable<Awaited<ReturnType<typeof appControllerHealth>>>
export type AppControllerHealthQueryError = unknown


export function useAppControllerHealth<TData = Awaited<ReturnType<typeof appControllerHealth>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerHealth>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof appControllerHealth>>,
          TError,
          Awaited<ReturnType<typeof appControllerHealth>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAppControllerHealth<TData = Awaited<ReturnType<typeof appControllerHealth>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerHealth>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof appControllerHealth>>,
          TError,
          Awaited<ReturnType<typeof appControllerHealth>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAppControllerHealth<TData = Awaited<ReturnType<typeof appControllerHealth>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerHealth>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Check if the deployment is healthy
 */

export function useAppControllerHealth<TData = Awaited<ReturnType<typeof appControllerHealth>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerHealth>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAppControllerHealthQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get all available models
 */
export const modelsControllerGetAvailableModelsWithConfig = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<ModelWithConfigResponseDto[]>(
      {url: `/models/available`, method: 'GET', signal
    },
      );
    }
  

export const getModelsControllerGetAvailableModelsWithConfigQueryKey = () => {
    return [`/models/available`] as const;
    }

    
export const getModelsControllerGetAvailableModelsWithConfigQueryOptions = <TData = Awaited<ReturnType<typeof modelsControllerGetAvailableModelsWithConfig>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetAvailableModelsWithConfig>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getModelsControllerGetAvailableModelsWithConfigQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsControllerGetAvailableModelsWithConfig>>> = ({ signal }) => modelsControllerGetAvailableModelsWithConfig(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetAvailableModelsWithConfig>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ModelsControllerGetAvailableModelsWithConfigQueryResult = NonNullable<Awaited<ReturnType<typeof modelsControllerGetAvailableModelsWithConfig>>>
export type ModelsControllerGetAvailableModelsWithConfigQueryError = void


export function useModelsControllerGetAvailableModelsWithConfig<TData = Awaited<ReturnType<typeof modelsControllerGetAvailableModelsWithConfig>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetAvailableModelsWithConfig>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof modelsControllerGetAvailableModelsWithConfig>>,
          TError,
          Awaited<ReturnType<typeof modelsControllerGetAvailableModelsWithConfig>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useModelsControllerGetAvailableModelsWithConfig<TData = Awaited<ReturnType<typeof modelsControllerGetAvailableModelsWithConfig>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetAvailableModelsWithConfig>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof modelsControllerGetAvailableModelsWithConfig>>,
          TError,
          Awaited<ReturnType<typeof modelsControllerGetAvailableModelsWithConfig>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useModelsControllerGetAvailableModelsWithConfig<TData = Awaited<ReturnType<typeof modelsControllerGetAvailableModelsWithConfig>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetAvailableModelsWithConfig>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all available models
 */

export function useModelsControllerGetAvailableModelsWithConfig<TData = Awaited<ReturnType<typeof modelsControllerGetAvailableModelsWithConfig>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetAvailableModelsWithConfig>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getModelsControllerGetAvailableModelsWithConfigQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get all available model providers with their info
 */
export const modelsControllerGetProviders = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<ModelProviderInfoResponseDto[]>(
      {url: `/models/providers`, method: 'GET', signal
    },
      );
    }
  

export const getModelsControllerGetProvidersQueryKey = () => {
    return [`/models/providers`] as const;
    }

    
export const getModelsControllerGetProvidersQueryOptions = <TData = Awaited<ReturnType<typeof modelsControllerGetProviders>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetProviders>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getModelsControllerGetProvidersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsControllerGetProviders>>> = ({ signal }) => modelsControllerGetProviders(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetProviders>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ModelsControllerGetProvidersQueryResult = NonNullable<Awaited<ReturnType<typeof modelsControllerGetProviders>>>
export type ModelsControllerGetProvidersQueryError = unknown


export function useModelsControllerGetProviders<TData = Awaited<ReturnType<typeof modelsControllerGetProviders>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetProviders>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof modelsControllerGetProviders>>,
          TError,
          Awaited<ReturnType<typeof modelsControllerGetProviders>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useModelsControllerGetProviders<TData = Awaited<ReturnType<typeof modelsControllerGetProviders>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetProviders>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof modelsControllerGetProviders>>,
          TError,
          Awaited<ReturnType<typeof modelsControllerGetProviders>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useModelsControllerGetProviders<TData = Awaited<ReturnType<typeof modelsControllerGetProviders>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetProviders>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all available model providers with their info
 */

export function useModelsControllerGetProviders<TData = Awaited<ReturnType<typeof modelsControllerGetProviders>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetProviders>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getModelsControllerGetProvidersQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a permitted model
 */
export const modelsControllerCreatePermittedModel = (
    createPermittedModelDto: CreatePermittedModelDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<void>(
      {url: `/models/permitted`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createPermittedModelDto, signal
    },
      );
    }
  


export const getModelsControllerCreatePermittedModelMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsControllerCreatePermittedModel>>, TError,{data: CreatePermittedModelDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof modelsControllerCreatePermittedModel>>, TError,{data: CreatePermittedModelDto}, TContext> => {

const mutationKey = ['modelsControllerCreatePermittedModel'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof modelsControllerCreatePermittedModel>>, {data: CreatePermittedModelDto}> = (props) => {
          const {data} = props ?? {};

          return  modelsControllerCreatePermittedModel(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ModelsControllerCreatePermittedModelMutationResult = NonNullable<Awaited<ReturnType<typeof modelsControllerCreatePermittedModel>>>
    export type ModelsControllerCreatePermittedModelMutationBody = CreatePermittedModelDto
    export type ModelsControllerCreatePermittedModelMutationError = void

    /**
 * @summary Create a permitted model
 */
export const useModelsControllerCreatePermittedModel = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsControllerCreatePermittedModel>>, TError,{data: CreatePermittedModelDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof modelsControllerCreatePermittedModel>>,
        TError,
        {data: CreatePermittedModelDto},
        TContext
      > => {

      const mutationOptions = getModelsControllerCreatePermittedModelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Delete a permitted model
 */
export const modelsControllerDeletePermittedModel = (
    id: string,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/models/permitted/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getModelsControllerDeletePermittedModelMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsControllerDeletePermittedModel>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof modelsControllerDeletePermittedModel>>, TError,{id: string}, TContext> => {

const mutationKey = ['modelsControllerDeletePermittedModel'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof modelsControllerDeletePermittedModel>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  modelsControllerDeletePermittedModel(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ModelsControllerDeletePermittedModelMutationResult = NonNullable<Awaited<ReturnType<typeof modelsControllerDeletePermittedModel>>>
    
    export type ModelsControllerDeletePermittedModelMutationError = void

    /**
 * @summary Delete a permitted model
 */
export const useModelsControllerDeletePermittedModel = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsControllerDeletePermittedModel>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof modelsControllerDeletePermittedModel>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getModelsControllerDeletePermittedModelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Update a permitted model
 */
export const modelsControllerUpdatePermittedModel = (
    id: string,
    updatePermittedModelDto: UpdatePermittedModelDto,
 ) => {
      
      
      return customAxiosInstance<PermittedLanguageModelResponseDto>(
      {url: `/models/permitted/${id}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updatePermittedModelDto
    },
      );
    }
  


export const getModelsControllerUpdatePermittedModelMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsControllerUpdatePermittedModel>>, TError,{id: string;data: UpdatePermittedModelDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof modelsControllerUpdatePermittedModel>>, TError,{id: string;data: UpdatePermittedModelDto}, TContext> => {

const mutationKey = ['modelsControllerUpdatePermittedModel'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof modelsControllerUpdatePermittedModel>>, {id: string;data: UpdatePermittedModelDto}> = (props) => {
          const {id,data} = props ?? {};

          return  modelsControllerUpdatePermittedModel(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ModelsControllerUpdatePermittedModelMutationResult = NonNullable<Awaited<ReturnType<typeof modelsControllerUpdatePermittedModel>>>
    export type ModelsControllerUpdatePermittedModelMutationBody = UpdatePermittedModelDto
    export type ModelsControllerUpdatePermittedModelMutationError = void

    /**
 * @summary Update a permitted model
 */
export const useModelsControllerUpdatePermittedModel = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsControllerUpdatePermittedModel>>, TError,{id: string;data: UpdatePermittedModelDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof modelsControllerUpdatePermittedModel>>,
        TError,
        {id: string;data: UpdatePermittedModelDto},
        TContext
      > => {

      const mutationOptions = getModelsControllerUpdatePermittedModelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get all permitted language models
 */
export const modelsControllerGetPermittedLanguageModels = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<PermittedLanguageModelResponseDto[]>(
      {url: `/models/permitted/language-models`, method: 'GET', signal
    },
      );
    }
  

export const getModelsControllerGetPermittedLanguageModelsQueryKey = () => {
    return [`/models/permitted/language-models`] as const;
    }

    
export const getModelsControllerGetPermittedLanguageModelsQueryOptions = <TData = Awaited<ReturnType<typeof modelsControllerGetPermittedLanguageModels>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetPermittedLanguageModels>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getModelsControllerGetPermittedLanguageModelsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsControllerGetPermittedLanguageModels>>> = ({ signal }) => modelsControllerGetPermittedLanguageModels(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetPermittedLanguageModels>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ModelsControllerGetPermittedLanguageModelsQueryResult = NonNullable<Awaited<ReturnType<typeof modelsControllerGetPermittedLanguageModels>>>
export type ModelsControllerGetPermittedLanguageModelsQueryError = void


export function useModelsControllerGetPermittedLanguageModels<TData = Awaited<ReturnType<typeof modelsControllerGetPermittedLanguageModels>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetPermittedLanguageModels>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof modelsControllerGetPermittedLanguageModels>>,
          TError,
          Awaited<ReturnType<typeof modelsControllerGetPermittedLanguageModels>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useModelsControllerGetPermittedLanguageModels<TData = Awaited<ReturnType<typeof modelsControllerGetPermittedLanguageModels>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetPermittedLanguageModels>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof modelsControllerGetPermittedLanguageModels>>,
          TError,
          Awaited<ReturnType<typeof modelsControllerGetPermittedLanguageModels>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useModelsControllerGetPermittedLanguageModels<TData = Awaited<ReturnType<typeof modelsControllerGetPermittedLanguageModels>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetPermittedLanguageModels>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all permitted language models
 */

export function useModelsControllerGetPermittedLanguageModels<TData = Awaited<ReturnType<typeof modelsControllerGetPermittedLanguageModels>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetPermittedLanguageModels>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getModelsControllerGetPermittedLanguageModelsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns the applicable default model with fallback hierarchy: User default â†’ Org default â†’ First available model
 * @summary Get the effective default model for the user
 */
export const modelsControllerGetEffectiveDefaultModel = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<PermittedLanguageModelResponseDtoNullable>(
      {url: `/models/default`, method: 'GET', signal
    },
      );
    }
  

export const getModelsControllerGetEffectiveDefaultModelQueryKey = () => {
    return [`/models/default`] as const;
    }

    
export const getModelsControllerGetEffectiveDefaultModelQueryOptions = <TData = Awaited<ReturnType<typeof modelsControllerGetEffectiveDefaultModel>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetEffectiveDefaultModel>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getModelsControllerGetEffectiveDefaultModelQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsControllerGetEffectiveDefaultModel>>> = ({ signal }) => modelsControllerGetEffectiveDefaultModel(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetEffectiveDefaultModel>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ModelsControllerGetEffectiveDefaultModelQueryResult = NonNullable<Awaited<ReturnType<typeof modelsControllerGetEffectiveDefaultModel>>>
export type ModelsControllerGetEffectiveDefaultModelQueryError = void


export function useModelsControllerGetEffectiveDefaultModel<TData = Awaited<ReturnType<typeof modelsControllerGetEffectiveDefaultModel>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetEffectiveDefaultModel>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof modelsControllerGetEffectiveDefaultModel>>,
          TError,
          Awaited<ReturnType<typeof modelsControllerGetEffectiveDefaultModel>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useModelsControllerGetEffectiveDefaultModel<TData = Awaited<ReturnType<typeof modelsControllerGetEffectiveDefaultModel>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetEffectiveDefaultModel>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof modelsControllerGetEffectiveDefaultModel>>,
          TError,
          Awaited<ReturnType<typeof modelsControllerGetEffectiveDefaultModel>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useModelsControllerGetEffectiveDefaultModel<TData = Awaited<ReturnType<typeof modelsControllerGetEffectiveDefaultModel>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetEffectiveDefaultModel>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get the effective default model for the user
 */

export function useModelsControllerGetEffectiveDefaultModel<TData = Awaited<ReturnType<typeof modelsControllerGetEffectiveDefaultModel>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetEffectiveDefaultModel>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getModelsControllerGetEffectiveDefaultModelQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns only the organization's specific default model. Returns null if no org default is set.
 * @summary Get the organization default model
 */
export const modelsControllerGetOrgSpecificDefaultModel = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<PermittedLanguageModelResponseDtoNullable>(
      {url: `/models/org/default`, method: 'GET', signal
    },
      );
    }
  

export const getModelsControllerGetOrgSpecificDefaultModelQueryKey = () => {
    return [`/models/org/default`] as const;
    }

    
export const getModelsControllerGetOrgSpecificDefaultModelQueryOptions = <TData = Awaited<ReturnType<typeof modelsControllerGetOrgSpecificDefaultModel>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetOrgSpecificDefaultModel>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getModelsControllerGetOrgSpecificDefaultModelQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsControllerGetOrgSpecificDefaultModel>>> = ({ signal }) => modelsControllerGetOrgSpecificDefaultModel(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetOrgSpecificDefaultModel>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ModelsControllerGetOrgSpecificDefaultModelQueryResult = NonNullable<Awaited<ReturnType<typeof modelsControllerGetOrgSpecificDefaultModel>>>
export type ModelsControllerGetOrgSpecificDefaultModelQueryError = void


export function useModelsControllerGetOrgSpecificDefaultModel<TData = Awaited<ReturnType<typeof modelsControllerGetOrgSpecificDefaultModel>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetOrgSpecificDefaultModel>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof modelsControllerGetOrgSpecificDefaultModel>>,
          TError,
          Awaited<ReturnType<typeof modelsControllerGetOrgSpecificDefaultModel>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useModelsControllerGetOrgSpecificDefaultModel<TData = Awaited<ReturnType<typeof modelsControllerGetOrgSpecificDefaultModel>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetOrgSpecificDefaultModel>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof modelsControllerGetOrgSpecificDefaultModel>>,
          TError,
          Awaited<ReturnType<typeof modelsControllerGetOrgSpecificDefaultModel>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useModelsControllerGetOrgSpecificDefaultModel<TData = Awaited<ReturnType<typeof modelsControllerGetOrgSpecificDefaultModel>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetOrgSpecificDefaultModel>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get the organization default model
 */

export function useModelsControllerGetOrgSpecificDefaultModel<TData = Awaited<ReturnType<typeof modelsControllerGetOrgSpecificDefaultModel>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetOrgSpecificDefaultModel>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getModelsControllerGetOrgSpecificDefaultModelQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Sets the specified permitted model as the organization default. If a default already exists, it will be updated to the new model.
 * @summary Set or update the organization default model
 */
export const modelsControllerManageOrgDefaultModel = (
    setOrgDefaultModelDto: SetOrgDefaultModelDto,
 ) => {
      
      
      return customAxiosInstance<PermittedLanguageModelResponseDto>(
      {url: `/models/org/default`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: setOrgDefaultModelDto
    },
      );
    }
  


export const getModelsControllerManageOrgDefaultModelMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsControllerManageOrgDefaultModel>>, TError,{data: SetOrgDefaultModelDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof modelsControllerManageOrgDefaultModel>>, TError,{data: SetOrgDefaultModelDto}, TContext> => {

const mutationKey = ['modelsControllerManageOrgDefaultModel'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof modelsControllerManageOrgDefaultModel>>, {data: SetOrgDefaultModelDto}> = (props) => {
          const {data} = props ?? {};

          return  modelsControllerManageOrgDefaultModel(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ModelsControllerManageOrgDefaultModelMutationResult = NonNullable<Awaited<ReturnType<typeof modelsControllerManageOrgDefaultModel>>>
    export type ModelsControllerManageOrgDefaultModelMutationBody = SetOrgDefaultModelDto
    export type ModelsControllerManageOrgDefaultModelMutationError = void

    /**
 * @summary Set or update the organization default model
 */
export const useModelsControllerManageOrgDefaultModel = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsControllerManageOrgDefaultModel>>, TError,{data: SetOrgDefaultModelDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof modelsControllerManageOrgDefaultModel>>,
        TError,
        {data: SetOrgDefaultModelDto},
        TContext
      > => {

      const mutationOptions = getModelsControllerManageOrgDefaultModelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Returns the user's personal default model only. Returns null if no user-specific default is set.
 * @summary Get the user-specific default model
 */
export const modelsControllerGetUserSpecificDefaultModel = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<PermittedLanguageModelResponseDtoNullable>(
      {url: `/models/user/default`, method: 'GET', signal
    },
      );
    }
  

export const getModelsControllerGetUserSpecificDefaultModelQueryKey = () => {
    return [`/models/user/default`] as const;
    }

    
export const getModelsControllerGetUserSpecificDefaultModelQueryOptions = <TData = Awaited<ReturnType<typeof modelsControllerGetUserSpecificDefaultModel>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetUserSpecificDefaultModel>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getModelsControllerGetUserSpecificDefaultModelQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsControllerGetUserSpecificDefaultModel>>> = ({ signal }) => modelsControllerGetUserSpecificDefaultModel(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetUserSpecificDefaultModel>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ModelsControllerGetUserSpecificDefaultModelQueryResult = NonNullable<Awaited<ReturnType<typeof modelsControllerGetUserSpecificDefaultModel>>>
export type ModelsControllerGetUserSpecificDefaultModelQueryError = void


export function useModelsControllerGetUserSpecificDefaultModel<TData = Awaited<ReturnType<typeof modelsControllerGetUserSpecificDefaultModel>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetUserSpecificDefaultModel>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof modelsControllerGetUserSpecificDefaultModel>>,
          TError,
          Awaited<ReturnType<typeof modelsControllerGetUserSpecificDefaultModel>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useModelsControllerGetUserSpecificDefaultModel<TData = Awaited<ReturnType<typeof modelsControllerGetUserSpecificDefaultModel>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetUserSpecificDefaultModel>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof modelsControllerGetUserSpecificDefaultModel>>,
          TError,
          Awaited<ReturnType<typeof modelsControllerGetUserSpecificDefaultModel>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useModelsControllerGetUserSpecificDefaultModel<TData = Awaited<ReturnType<typeof modelsControllerGetUserSpecificDefaultModel>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetUserSpecificDefaultModel>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get the user-specific default model
 */

export function useModelsControllerGetUserSpecificDefaultModel<TData = Awaited<ReturnType<typeof modelsControllerGetUserSpecificDefaultModel>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetUserSpecificDefaultModel>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getModelsControllerGetUserSpecificDefaultModelQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Sets the specified permitted model as the user default. If a default already exists, it will be updated to the new model.
 * @summary Set or update the user default model
 */
export const modelsControllerManageUserDefaultModel = (
    setUserDefaultModelDto: SetUserDefaultModelDto,
 ) => {
      
      
      return customAxiosInstance<PermittedLanguageModelResponseDto>(
      {url: `/models/user/default`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: setUserDefaultModelDto
    },
      );
    }
  


export const getModelsControllerManageUserDefaultModelMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsControllerManageUserDefaultModel>>, TError,{data: SetUserDefaultModelDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof modelsControllerManageUserDefaultModel>>, TError,{data: SetUserDefaultModelDto}, TContext> => {

const mutationKey = ['modelsControllerManageUserDefaultModel'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof modelsControllerManageUserDefaultModel>>, {data: SetUserDefaultModelDto}> = (props) => {
          const {data} = props ?? {};

          return  modelsControllerManageUserDefaultModel(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ModelsControllerManageUserDefaultModelMutationResult = NonNullable<Awaited<ReturnType<typeof modelsControllerManageUserDefaultModel>>>
    export type ModelsControllerManageUserDefaultModelMutationBody = SetUserDefaultModelDto
    export type ModelsControllerManageUserDefaultModelMutationError = void

    /**
 * @summary Set or update the user default model
 */
export const useModelsControllerManageUserDefaultModel = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsControllerManageUserDefaultModel>>, TError,{data: SetUserDefaultModelDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof modelsControllerManageUserDefaultModel>>,
        TError,
        {data: SetUserDefaultModelDto},
        TContext
      > => {

      const mutationOptions = getModelsControllerManageUserDefaultModelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Delete the user default model
 */
export const modelsControllerDeleteUserDefaultModel = (
    
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/models/user/default`, method: 'DELETE'
    },
      );
    }
  


export const getModelsControllerDeleteUserDefaultModelMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsControllerDeleteUserDefaultModel>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof modelsControllerDeleteUserDefaultModel>>, TError,void, TContext> => {

const mutationKey = ['modelsControllerDeleteUserDefaultModel'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof modelsControllerDeleteUserDefaultModel>>, void> = () => {
          

          return  modelsControllerDeleteUserDefaultModel()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ModelsControllerDeleteUserDefaultModelMutationResult = NonNullable<Awaited<ReturnType<typeof modelsControllerDeleteUserDefaultModel>>>
    
    export type ModelsControllerDeleteUserDefaultModelMutationError = void

    /**
 * @summary Delete the user default model
 */
export const useModelsControllerDeleteUserDefaultModel = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsControllerDeleteUserDefaultModel>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof modelsControllerDeleteUserDefaultModel>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getModelsControllerDeleteUserDefaultModelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieves detailed information about a specific model provider
 * @summary Get model provider information
 */
export const modelsControllerGetModelProviderInfo = (
    provider: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<ModelProviderInfoResponseDto>(
      {url: `/models/provider/${provider}`, method: 'GET', signal
    },
      );
    }
  

export const getModelsControllerGetModelProviderInfoQueryKey = (provider: string,) => {
    return [`/models/provider/${provider}`] as const;
    }

    
export const getModelsControllerGetModelProviderInfoQueryOptions = <TData = Awaited<ReturnType<typeof modelsControllerGetModelProviderInfo>>, TError = void>(provider: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetModelProviderInfo>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getModelsControllerGetModelProviderInfoQueryKey(provider);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsControllerGetModelProviderInfo>>> = ({ signal }) => modelsControllerGetModelProviderInfo(provider, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(provider), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetModelProviderInfo>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ModelsControllerGetModelProviderInfoQueryResult = NonNullable<Awaited<ReturnType<typeof modelsControllerGetModelProviderInfo>>>
export type ModelsControllerGetModelProviderInfoQueryError = void


export function useModelsControllerGetModelProviderInfo<TData = Awaited<ReturnType<typeof modelsControllerGetModelProviderInfo>>, TError = void>(
 provider: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetModelProviderInfo>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof modelsControllerGetModelProviderInfo>>,
          TError,
          Awaited<ReturnType<typeof modelsControllerGetModelProviderInfo>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useModelsControllerGetModelProviderInfo<TData = Awaited<ReturnType<typeof modelsControllerGetModelProviderInfo>>, TError = void>(
 provider: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetModelProviderInfo>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof modelsControllerGetModelProviderInfo>>,
          TError,
          Awaited<ReturnType<typeof modelsControllerGetModelProviderInfo>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useModelsControllerGetModelProviderInfo<TData = Awaited<ReturnType<typeof modelsControllerGetModelProviderInfo>>, TError = void>(
 provider: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetModelProviderInfo>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get model provider information
 */

export function useModelsControllerGetModelProviderInfo<TData = Awaited<ReturnType<typeof modelsControllerGetModelProviderInfo>>, TError = void>(
 provider: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerGetModelProviderInfo>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getModelsControllerGetModelProviderInfoQueryOptions(provider,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Check if an embedding model is enabled for this org
 */
export const modelsControllerIsEmbeddingModelEnabled = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<EmbeddingModelEnabledResponseDto>(
      {url: `/models/embedding/enabled`, method: 'GET', signal
    },
      );
    }
  

export const getModelsControllerIsEmbeddingModelEnabledQueryKey = () => {
    return [`/models/embedding/enabled`] as const;
    }

    
export const getModelsControllerIsEmbeddingModelEnabledQueryOptions = <TData = Awaited<ReturnType<typeof modelsControllerIsEmbeddingModelEnabled>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerIsEmbeddingModelEnabled>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getModelsControllerIsEmbeddingModelEnabledQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsControllerIsEmbeddingModelEnabled>>> = ({ signal }) => modelsControllerIsEmbeddingModelEnabled(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof modelsControllerIsEmbeddingModelEnabled>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ModelsControllerIsEmbeddingModelEnabledQueryResult = NonNullable<Awaited<ReturnType<typeof modelsControllerIsEmbeddingModelEnabled>>>
export type ModelsControllerIsEmbeddingModelEnabledQueryError = void


export function useModelsControllerIsEmbeddingModelEnabled<TData = Awaited<ReturnType<typeof modelsControllerIsEmbeddingModelEnabled>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerIsEmbeddingModelEnabled>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof modelsControllerIsEmbeddingModelEnabled>>,
          TError,
          Awaited<ReturnType<typeof modelsControllerIsEmbeddingModelEnabled>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useModelsControllerIsEmbeddingModelEnabled<TData = Awaited<ReturnType<typeof modelsControllerIsEmbeddingModelEnabled>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerIsEmbeddingModelEnabled>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof modelsControllerIsEmbeddingModelEnabled>>,
          TError,
          Awaited<ReturnType<typeof modelsControllerIsEmbeddingModelEnabled>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useModelsControllerIsEmbeddingModelEnabled<TData = Awaited<ReturnType<typeof modelsControllerIsEmbeddingModelEnabled>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerIsEmbeddingModelEnabled>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Check if an embedding model is enabled for this org
 */

export function useModelsControllerIsEmbeddingModelEnabled<TData = Awaited<ReturnType<typeof modelsControllerIsEmbeddingModelEnabled>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsControllerIsEmbeddingModelEnabled>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getModelsControllerIsEmbeddingModelEnabledQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve all available models from the registry with their permitted status for the specified organization. This endpoint is only accessible to super admins.
 * @summary Get all available models
 */
export const superAdminModelsControllerGetAvailableModels = (
    orgId: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<ModelWithConfigResponseDto[]>(
      {url: `/super-admin/models/${orgId}/available`, method: 'GET', signal
    },
      );
    }
  

export const getSuperAdminModelsControllerGetAvailableModelsQueryKey = (orgId: string,) => {
    return [`/super-admin/models/${orgId}/available`] as const;
    }

    
export const getSuperAdminModelsControllerGetAvailableModelsQueryOptions = <TData = Awaited<ReturnType<typeof superAdminModelsControllerGetAvailableModels>>, TError = void>(orgId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminModelsControllerGetAvailableModels>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSuperAdminModelsControllerGetAvailableModelsQueryKey(orgId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof superAdminModelsControllerGetAvailableModels>>> = ({ signal }) => superAdminModelsControllerGetAvailableModels(orgId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orgId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof superAdminModelsControllerGetAvailableModels>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SuperAdminModelsControllerGetAvailableModelsQueryResult = NonNullable<Awaited<ReturnType<typeof superAdminModelsControllerGetAvailableModels>>>
export type SuperAdminModelsControllerGetAvailableModelsQueryError = void


export function useSuperAdminModelsControllerGetAvailableModels<TData = Awaited<ReturnType<typeof superAdminModelsControllerGetAvailableModels>>, TError = void>(
 orgId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminModelsControllerGetAvailableModels>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof superAdminModelsControllerGetAvailableModels>>,
          TError,
          Awaited<ReturnType<typeof superAdminModelsControllerGetAvailableModels>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSuperAdminModelsControllerGetAvailableModels<TData = Awaited<ReturnType<typeof superAdminModelsControllerGetAvailableModels>>, TError = void>(
 orgId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminModelsControllerGetAvailableModels>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof superAdminModelsControllerGetAvailableModels>>,
          TError,
          Awaited<ReturnType<typeof superAdminModelsControllerGetAvailableModels>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSuperAdminModelsControllerGetAvailableModels<TData = Awaited<ReturnType<typeof superAdminModelsControllerGetAvailableModels>>, TError = void>(
 orgId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminModelsControllerGetAvailableModels>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all available models
 */

export function useSuperAdminModelsControllerGetAvailableModels<TData = Awaited<ReturnType<typeof superAdminModelsControllerGetAvailableModels>>, TError = void>(
 orgId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminModelsControllerGetAvailableModels>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSuperAdminModelsControllerGetAvailableModelsQueryOptions(orgId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Sets the specified permitted model as the organization default. If a default already exists, it will be updated to the new model. This endpoint is only accessible to super admins.
 * @summary Set or update the organization default model
 */
export const superAdminModelsControllerManageOrgDefaultModel = (
    orgId: string,
    setOrgDefaultModelDto: SetOrgDefaultModelDto,
 ) => {
      
      
      return customAxiosInstance<PermittedLanguageModelResponseDto>(
      {url: `/super-admin/models/${orgId}/default-model`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: setOrgDefaultModelDto
    },
      );
    }
  


export const getSuperAdminModelsControllerManageOrgDefaultModelMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminModelsControllerManageOrgDefaultModel>>, TError,{orgId: string;data: SetOrgDefaultModelDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof superAdminModelsControllerManageOrgDefaultModel>>, TError,{orgId: string;data: SetOrgDefaultModelDto}, TContext> => {

const mutationKey = ['superAdminModelsControllerManageOrgDefaultModel'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof superAdminModelsControllerManageOrgDefaultModel>>, {orgId: string;data: SetOrgDefaultModelDto}> = (props) => {
          const {orgId,data} = props ?? {};

          return  superAdminModelsControllerManageOrgDefaultModel(orgId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuperAdminModelsControllerManageOrgDefaultModelMutationResult = NonNullable<Awaited<ReturnType<typeof superAdminModelsControllerManageOrgDefaultModel>>>
    export type SuperAdminModelsControllerManageOrgDefaultModelMutationBody = SetOrgDefaultModelDto
    export type SuperAdminModelsControllerManageOrgDefaultModelMutationError = void

    /**
 * @summary Set or update the organization default model
 */
export const useSuperAdminModelsControllerManageOrgDefaultModel = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminModelsControllerManageOrgDefaultModel>>, TError,{orgId: string;data: SetOrgDefaultModelDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof superAdminModelsControllerManageOrgDefaultModel>>,
        TError,
        {orgId: string;data: SetOrgDefaultModelDto},
        TContext
      > => {

      const mutationOptions = getSuperAdminModelsControllerManageOrgDefaultModelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Remove a model (language or embedding) from the master catalog. This endpoint is only accessible to super admins.
 * @summary Delete a model from the catalog
 */
export const superAdminModelsControllerDeleteCatalogModel = (
    id: string,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/super-admin/models/catalog/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getSuperAdminModelsControllerDeleteCatalogModelMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminModelsControllerDeleteCatalogModel>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof superAdminModelsControllerDeleteCatalogModel>>, TError,{id: string}, TContext> => {

const mutationKey = ['superAdminModelsControllerDeleteCatalogModel'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof superAdminModelsControllerDeleteCatalogModel>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  superAdminModelsControllerDeleteCatalogModel(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuperAdminModelsControllerDeleteCatalogModelMutationResult = NonNullable<Awaited<ReturnType<typeof superAdminModelsControllerDeleteCatalogModel>>>
    
    export type SuperAdminModelsControllerDeleteCatalogModelMutationError = void

    /**
 * @summary Delete a model from the catalog
 */
export const useSuperAdminModelsControllerDeleteCatalogModel = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminModelsControllerDeleteCatalogModel>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof superAdminModelsControllerDeleteCatalogModel>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getSuperAdminModelsControllerDeleteCatalogModelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a specific model from the master catalog by its ID. This endpoint is only accessible to super admins.
 * @summary Get a model by ID from the catalog
 */
export const superAdminModelsControllerGetCatalogModelById = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<SuperAdminModelsControllerGetCatalogModelById200>(
      {url: `/super-admin/models/catalog/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getSuperAdminModelsControllerGetCatalogModelByIdQueryKey = (id: string,) => {
    return [`/super-admin/models/catalog/${id}`] as const;
    }

    
export const getSuperAdminModelsControllerGetCatalogModelByIdQueryOptions = <TData = Awaited<ReturnType<typeof superAdminModelsControllerGetCatalogModelById>>, TError = void>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminModelsControllerGetCatalogModelById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSuperAdminModelsControllerGetCatalogModelByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof superAdminModelsControllerGetCatalogModelById>>> = ({ signal }) => superAdminModelsControllerGetCatalogModelById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof superAdminModelsControllerGetCatalogModelById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SuperAdminModelsControllerGetCatalogModelByIdQueryResult = NonNullable<Awaited<ReturnType<typeof superAdminModelsControllerGetCatalogModelById>>>
export type SuperAdminModelsControllerGetCatalogModelByIdQueryError = void


export function useSuperAdminModelsControllerGetCatalogModelById<TData = Awaited<ReturnType<typeof superAdminModelsControllerGetCatalogModelById>>, TError = void>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminModelsControllerGetCatalogModelById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof superAdminModelsControllerGetCatalogModelById>>,
          TError,
          Awaited<ReturnType<typeof superAdminModelsControllerGetCatalogModelById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSuperAdminModelsControllerGetCatalogModelById<TData = Awaited<ReturnType<typeof superAdminModelsControllerGetCatalogModelById>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminModelsControllerGetCatalogModelById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof superAdminModelsControllerGetCatalogModelById>>,
          TError,
          Awaited<ReturnType<typeof superAdminModelsControllerGetCatalogModelById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSuperAdminModelsControllerGetCatalogModelById<TData = Awaited<ReturnType<typeof superAdminModelsControllerGetCatalogModelById>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminModelsControllerGetCatalogModelById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a model by ID from the catalog
 */

export function useSuperAdminModelsControllerGetCatalogModelById<TData = Awaited<ReturnType<typeof superAdminModelsControllerGetCatalogModelById>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminModelsControllerGetCatalogModelById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSuperAdminModelsControllerGetCatalogModelByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve all permitted models for the specified organization. This endpoint is only accessible to super admins.
 * @summary Get all permitted models for a specific organization
 */
export const superAdminModelsControllerGetPermittedModels = (
    orgId: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<SuperAdminModelsControllerGetPermittedModels200Item[]>(
      {url: `/super-admin/models/${orgId}/permitted-models`, method: 'GET', signal
    },
      );
    }
  

export const getSuperAdminModelsControllerGetPermittedModelsQueryKey = (orgId: string,) => {
    return [`/super-admin/models/${orgId}/permitted-models`] as const;
    }

    
export const getSuperAdminModelsControllerGetPermittedModelsQueryOptions = <TData = Awaited<ReturnType<typeof superAdminModelsControllerGetPermittedModels>>, TError = void>(orgId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminModelsControllerGetPermittedModels>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSuperAdminModelsControllerGetPermittedModelsQueryKey(orgId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof superAdminModelsControllerGetPermittedModels>>> = ({ signal }) => superAdminModelsControllerGetPermittedModels(orgId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orgId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof superAdminModelsControllerGetPermittedModels>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SuperAdminModelsControllerGetPermittedModelsQueryResult = NonNullable<Awaited<ReturnType<typeof superAdminModelsControllerGetPermittedModels>>>
export type SuperAdminModelsControllerGetPermittedModelsQueryError = void


export function useSuperAdminModelsControllerGetPermittedModels<TData = Awaited<ReturnType<typeof superAdminModelsControllerGetPermittedModels>>, TError = void>(
 orgId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminModelsControllerGetPermittedModels>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof superAdminModelsControllerGetPermittedModels>>,
          TError,
          Awaited<ReturnType<typeof superAdminModelsControllerGetPermittedModels>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSuperAdminModelsControllerGetPermittedModels<TData = Awaited<ReturnType<typeof superAdminModelsControllerGetPermittedModels>>, TError = void>(
 orgId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminModelsControllerGetPermittedModels>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof superAdminModelsControllerGetPermittedModels>>,
          TError,
          Awaited<ReturnType<typeof superAdminModelsControllerGetPermittedModels>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSuperAdminModelsControllerGetPermittedModels<TData = Awaited<ReturnType<typeof superAdminModelsControllerGetPermittedModels>>, TError = void>(
 orgId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminModelsControllerGetPermittedModels>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all permitted models for a specific organization
 */

export function useSuperAdminModelsControllerGetPermittedModels<TData = Awaited<ReturnType<typeof superAdminModelsControllerGetPermittedModels>>, TError = void>(
 orgId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminModelsControllerGetPermittedModels>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSuperAdminModelsControllerGetPermittedModelsQueryOptions(orgId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new permitted model for the specified organization. This endpoint is only accessible to super admins.
 * @summary Create a permitted model for a specific organization
 */
export const superAdminModelsControllerCreatePermittedModel = (
    orgId: string,
    createPermittedModelDto: CreatePermittedModelDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<void>(
      {url: `/super-admin/models/${orgId}/permitted-models`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createPermittedModelDto, signal
    },
      );
    }
  


export const getSuperAdminModelsControllerCreatePermittedModelMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminModelsControllerCreatePermittedModel>>, TError,{orgId: string;data: CreatePermittedModelDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof superAdminModelsControllerCreatePermittedModel>>, TError,{orgId: string;data: CreatePermittedModelDto}, TContext> => {

const mutationKey = ['superAdminModelsControllerCreatePermittedModel'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof superAdminModelsControllerCreatePermittedModel>>, {orgId: string;data: CreatePermittedModelDto}> = (props) => {
          const {orgId,data} = props ?? {};

          return  superAdminModelsControllerCreatePermittedModel(orgId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuperAdminModelsControllerCreatePermittedModelMutationResult = NonNullable<Awaited<ReturnType<typeof superAdminModelsControllerCreatePermittedModel>>>
    export type SuperAdminModelsControllerCreatePermittedModelMutationBody = CreatePermittedModelDto
    export type SuperAdminModelsControllerCreatePermittedModelMutationError = void

    /**
 * @summary Create a permitted model for a specific organization
 */
export const useSuperAdminModelsControllerCreatePermittedModel = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminModelsControllerCreatePermittedModel>>, TError,{orgId: string;data: CreatePermittedModelDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof superAdminModelsControllerCreatePermittedModel>>,
        TError,
        {orgId: string;data: CreatePermittedModelDto},
        TContext
      > => {

      const mutationOptions = getSuperAdminModelsControllerCreatePermittedModelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a permitted model for the specified organization. This endpoint is only accessible to super admins.
 * @summary Delete a permitted model for a specific organization
 */
export const superAdminModelsControllerDeletePermittedModel = (
    orgId: string,
    id: string,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/super-admin/models/${orgId}/permitted-models/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getSuperAdminModelsControllerDeletePermittedModelMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminModelsControllerDeletePermittedModel>>, TError,{orgId: string;id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof superAdminModelsControllerDeletePermittedModel>>, TError,{orgId: string;id: string}, TContext> => {

const mutationKey = ['superAdminModelsControllerDeletePermittedModel'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof superAdminModelsControllerDeletePermittedModel>>, {orgId: string;id: string}> = (props) => {
          const {orgId,id} = props ?? {};

          return  superAdminModelsControllerDeletePermittedModel(orgId,id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuperAdminModelsControllerDeletePermittedModelMutationResult = NonNullable<Awaited<ReturnType<typeof superAdminModelsControllerDeletePermittedModel>>>
    
    export type SuperAdminModelsControllerDeletePermittedModelMutationError = void

    /**
 * @summary Delete a permitted model for a specific organization
 */
export const useSuperAdminModelsControllerDeletePermittedModel = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminModelsControllerDeletePermittedModel>>, TError,{orgId: string;id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof superAdminModelsControllerDeletePermittedModel>>,
        TError,
        {orgId: string;id: string},
        TContext
      > => {

      const mutationOptions = getSuperAdminModelsControllerDeletePermittedModelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Update the settings of a permitted model for the specified organization. This endpoint is only accessible to super admins.
 * @summary Update a permitted model for a specific organization
 */
export const superAdminModelsControllerUpdatePermittedModel = (
    orgId: string,
    id: string,
    updatePermittedModelDto: UpdatePermittedModelDto,
 ) => {
      
      
      return customAxiosInstance<SuperAdminModelsControllerUpdatePermittedModel200>(
      {url: `/super-admin/models/${orgId}/permitted-models/${id}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updatePermittedModelDto
    },
      );
    }
  


export const getSuperAdminModelsControllerUpdatePermittedModelMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminModelsControllerUpdatePermittedModel>>, TError,{orgId: string;id: string;data: UpdatePermittedModelDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof superAdminModelsControllerUpdatePermittedModel>>, TError,{orgId: string;id: string;data: UpdatePermittedModelDto}, TContext> => {

const mutationKey = ['superAdminModelsControllerUpdatePermittedModel'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof superAdminModelsControllerUpdatePermittedModel>>, {orgId: string;id: string;data: UpdatePermittedModelDto}> = (props) => {
          const {orgId,id,data} = props ?? {};

          return  superAdminModelsControllerUpdatePermittedModel(orgId,id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuperAdminModelsControllerUpdatePermittedModelMutationResult = NonNullable<Awaited<ReturnType<typeof superAdminModelsControllerUpdatePermittedModel>>>
    export type SuperAdminModelsControllerUpdatePermittedModelMutationBody = UpdatePermittedModelDto
    export type SuperAdminModelsControllerUpdatePermittedModelMutationError = void

    /**
 * @summary Update a permitted model for a specific organization
 */
export const useSuperAdminModelsControllerUpdatePermittedModel = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminModelsControllerUpdatePermittedModel>>, TError,{orgId: string;id: string;data: UpdatePermittedModelDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof superAdminModelsControllerUpdatePermittedModel>>,
        TError,
        {orgId: string;id: string;data: UpdatePermittedModelDto},
        TContext
      > => {

      const mutationOptions = getSuperAdminModelsControllerUpdatePermittedModelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve all models (language and embedding) from the master catalog. This endpoint is only accessible to super admins.
 * @summary Get all models in the catalog
 */
export const superAdminModelsControllerGetAllCatalogModels = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<SuperAdminModelsControllerGetAllCatalogModels200Item[]>(
      {url: `/super-admin/models/catalog`, method: 'GET', signal
    },
      );
    }
  

export const getSuperAdminModelsControllerGetAllCatalogModelsQueryKey = () => {
    return [`/super-admin/models/catalog`] as const;
    }

    
export const getSuperAdminModelsControllerGetAllCatalogModelsQueryOptions = <TData = Awaited<ReturnType<typeof superAdminModelsControllerGetAllCatalogModels>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminModelsControllerGetAllCatalogModels>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSuperAdminModelsControllerGetAllCatalogModelsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof superAdminModelsControllerGetAllCatalogModels>>> = ({ signal }) => superAdminModelsControllerGetAllCatalogModels(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof superAdminModelsControllerGetAllCatalogModels>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SuperAdminModelsControllerGetAllCatalogModelsQueryResult = NonNullable<Awaited<ReturnType<typeof superAdminModelsControllerGetAllCatalogModels>>>
export type SuperAdminModelsControllerGetAllCatalogModelsQueryError = void


export function useSuperAdminModelsControllerGetAllCatalogModels<TData = Awaited<ReturnType<typeof superAdminModelsControllerGetAllCatalogModels>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminModelsControllerGetAllCatalogModels>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof superAdminModelsControllerGetAllCatalogModels>>,
          TError,
          Awaited<ReturnType<typeof superAdminModelsControllerGetAllCatalogModels>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSuperAdminModelsControllerGetAllCatalogModels<TData = Awaited<ReturnType<typeof superAdminModelsControllerGetAllCatalogModels>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminModelsControllerGetAllCatalogModels>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof superAdminModelsControllerGetAllCatalogModels>>,
          TError,
          Awaited<ReturnType<typeof superAdminModelsControllerGetAllCatalogModels>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSuperAdminModelsControllerGetAllCatalogModels<TData = Awaited<ReturnType<typeof superAdminModelsControllerGetAllCatalogModels>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminModelsControllerGetAllCatalogModels>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all models in the catalog
 */

export function useSuperAdminModelsControllerGetAllCatalogModels<TData = Awaited<ReturnType<typeof superAdminModelsControllerGetAllCatalogModels>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminModelsControllerGetAllCatalogModels>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSuperAdminModelsControllerGetAllCatalogModelsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new language model in the master catalog. This endpoint is only accessible to super admins.
 * @summary Create a new language model in the catalog
 */
export const superAdminModelsControllerCreateLanguageModel = (
    createLanguageModelRequestDto: CreateLanguageModelRequestDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<LanguageModelResponseDto>(
      {url: `/super-admin/models/catalog/language`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createLanguageModelRequestDto, signal
    },
      );
    }
  


export const getSuperAdminModelsControllerCreateLanguageModelMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminModelsControllerCreateLanguageModel>>, TError,{data: CreateLanguageModelRequestDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof superAdminModelsControllerCreateLanguageModel>>, TError,{data: CreateLanguageModelRequestDto}, TContext> => {

const mutationKey = ['superAdminModelsControllerCreateLanguageModel'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof superAdminModelsControllerCreateLanguageModel>>, {data: CreateLanguageModelRequestDto}> = (props) => {
          const {data} = props ?? {};

          return  superAdminModelsControllerCreateLanguageModel(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuperAdminModelsControllerCreateLanguageModelMutationResult = NonNullable<Awaited<ReturnType<typeof superAdminModelsControllerCreateLanguageModel>>>
    export type SuperAdminModelsControllerCreateLanguageModelMutationBody = CreateLanguageModelRequestDto
    export type SuperAdminModelsControllerCreateLanguageModelMutationError = void

    /**
 * @summary Create a new language model in the catalog
 */
export const useSuperAdminModelsControllerCreateLanguageModel = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminModelsControllerCreateLanguageModel>>, TError,{data: CreateLanguageModelRequestDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof superAdminModelsControllerCreateLanguageModel>>,
        TError,
        {data: CreateLanguageModelRequestDto},
        TContext
      > => {

      const mutationOptions = getSuperAdminModelsControllerCreateLanguageModelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Update an existing language model in the master catalog. This endpoint is only accessible to super admins.
 * @summary Update a language model in the catalog
 */
export const superAdminModelsControllerUpdateLanguageModel = (
    id: string,
    updateLanguageModelRequestDto: UpdateLanguageModelRequestDto,
 ) => {
      
      
      return customAxiosInstance<LanguageModelResponseDto>(
      {url: `/super-admin/models/catalog/language/${id}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateLanguageModelRequestDto
    },
      );
    }
  


export const getSuperAdminModelsControllerUpdateLanguageModelMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminModelsControllerUpdateLanguageModel>>, TError,{id: string;data: UpdateLanguageModelRequestDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof superAdminModelsControllerUpdateLanguageModel>>, TError,{id: string;data: UpdateLanguageModelRequestDto}, TContext> => {

const mutationKey = ['superAdminModelsControllerUpdateLanguageModel'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof superAdminModelsControllerUpdateLanguageModel>>, {id: string;data: UpdateLanguageModelRequestDto}> = (props) => {
          const {id,data} = props ?? {};

          return  superAdminModelsControllerUpdateLanguageModel(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuperAdminModelsControllerUpdateLanguageModelMutationResult = NonNullable<Awaited<ReturnType<typeof superAdminModelsControllerUpdateLanguageModel>>>
    export type SuperAdminModelsControllerUpdateLanguageModelMutationBody = UpdateLanguageModelRequestDto
    export type SuperAdminModelsControllerUpdateLanguageModelMutationError = void

    /**
 * @summary Update a language model in the catalog
 */
export const useSuperAdminModelsControllerUpdateLanguageModel = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminModelsControllerUpdateLanguageModel>>, TError,{id: string;data: UpdateLanguageModelRequestDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof superAdminModelsControllerUpdateLanguageModel>>,
        TError,
        {id: string;data: UpdateLanguageModelRequestDto},
        TContext
      > => {

      const mutationOptions = getSuperAdminModelsControllerUpdateLanguageModelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Create a new embedding model in the master catalog. This endpoint is only accessible to super admins.
 * @summary Create a new embedding model in the catalog
 */
export const superAdminModelsControllerCreateEmbeddingModel = (
    createEmbeddingModelRequestDto: CreateEmbeddingModelRequestDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<EmbeddingModelResponseDto>(
      {url: `/super-admin/models/catalog/embedding`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createEmbeddingModelRequestDto, signal
    },
      );
    }
  


export const getSuperAdminModelsControllerCreateEmbeddingModelMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminModelsControllerCreateEmbeddingModel>>, TError,{data: CreateEmbeddingModelRequestDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof superAdminModelsControllerCreateEmbeddingModel>>, TError,{data: CreateEmbeddingModelRequestDto}, TContext> => {

const mutationKey = ['superAdminModelsControllerCreateEmbeddingModel'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof superAdminModelsControllerCreateEmbeddingModel>>, {data: CreateEmbeddingModelRequestDto}> = (props) => {
          const {data} = props ?? {};

          return  superAdminModelsControllerCreateEmbeddingModel(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuperAdminModelsControllerCreateEmbeddingModelMutationResult = NonNullable<Awaited<ReturnType<typeof superAdminModelsControllerCreateEmbeddingModel>>>
    export type SuperAdminModelsControllerCreateEmbeddingModelMutationBody = CreateEmbeddingModelRequestDto
    export type SuperAdminModelsControllerCreateEmbeddingModelMutationError = void

    /**
 * @summary Create a new embedding model in the catalog
 */
export const useSuperAdminModelsControllerCreateEmbeddingModel = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminModelsControllerCreateEmbeddingModel>>, TError,{data: CreateEmbeddingModelRequestDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof superAdminModelsControllerCreateEmbeddingModel>>,
        TError,
        {data: CreateEmbeddingModelRequestDto},
        TContext
      > => {

      const mutationOptions = getSuperAdminModelsControllerCreateEmbeddingModelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Update an existing embedding model in the master catalog. This endpoint is only accessible to super admins.
 * @summary Update an embedding model in the catalog
 */
export const superAdminModelsControllerUpdateEmbeddingModel = (
    id: string,
    updateEmbeddingModelRequestDto: UpdateEmbeddingModelRequestDto,
 ) => {
      
      
      return customAxiosInstance<EmbeddingModelResponseDto>(
      {url: `/super-admin/models/catalog/embedding/${id}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateEmbeddingModelRequestDto
    },
      );
    }
  


export const getSuperAdminModelsControllerUpdateEmbeddingModelMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminModelsControllerUpdateEmbeddingModel>>, TError,{id: string;data: UpdateEmbeddingModelRequestDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof superAdminModelsControllerUpdateEmbeddingModel>>, TError,{id: string;data: UpdateEmbeddingModelRequestDto}, TContext> => {

const mutationKey = ['superAdminModelsControllerUpdateEmbeddingModel'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof superAdminModelsControllerUpdateEmbeddingModel>>, {id: string;data: UpdateEmbeddingModelRequestDto}> = (props) => {
          const {id,data} = props ?? {};

          return  superAdminModelsControllerUpdateEmbeddingModel(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuperAdminModelsControllerUpdateEmbeddingModelMutationResult = NonNullable<Awaited<ReturnType<typeof superAdminModelsControllerUpdateEmbeddingModel>>>
    export type SuperAdminModelsControllerUpdateEmbeddingModelMutationBody = UpdateEmbeddingModelRequestDto
    export type SuperAdminModelsControllerUpdateEmbeddingModelMutationError = void

    /**
 * @summary Update an embedding model in the catalog
 */
export const useSuperAdminModelsControllerUpdateEmbeddingModel = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminModelsControllerUpdateEmbeddingModel>>, TError,{id: string;data: UpdateEmbeddingModelRequestDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof superAdminModelsControllerUpdateEmbeddingModel>>,
        TError,
        {id: string;data: UpdateEmbeddingModelRequestDto},
        TContext
      > => {

      const mutationOptions = getSuperAdminModelsControllerUpdateEmbeddingModelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Create a new organization in the system. Only accessible to users with the super admin system role.
 * @summary Create a new organization
 */
export const superAdminOrgsControllerCreateOrg = (
    createOrgRequestDto: CreateOrgRequestDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<SuperAdminOrgResponseDto>(
      {url: `/super-admin/orgs`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createOrgRequestDto, signal
    },
      );
    }
  


export const getSuperAdminOrgsControllerCreateOrgMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminOrgsControllerCreateOrg>>, TError,{data: CreateOrgRequestDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof superAdminOrgsControllerCreateOrg>>, TError,{data: CreateOrgRequestDto}, TContext> => {

const mutationKey = ['superAdminOrgsControllerCreateOrg'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof superAdminOrgsControllerCreateOrg>>, {data: CreateOrgRequestDto}> = (props) => {
          const {data} = props ?? {};

          return  superAdminOrgsControllerCreateOrg(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuperAdminOrgsControllerCreateOrgMutationResult = NonNullable<Awaited<ReturnType<typeof superAdminOrgsControllerCreateOrg>>>
    export type SuperAdminOrgsControllerCreateOrgMutationBody = CreateOrgRequestDto
    export type SuperAdminOrgsControllerCreateOrgMutationError = void

    /**
 * @summary Create a new organization
 */
export const useSuperAdminOrgsControllerCreateOrg = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminOrgsControllerCreateOrg>>, TError,{data: CreateOrgRequestDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof superAdminOrgsControllerCreateOrg>>,
        TError,
        {data: CreateOrgRequestDto},
        TContext
      > => {

      const mutationOptions = getSuperAdminOrgsControllerCreateOrgMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve paginated organizations in the system. Only accessible to users with the super admin system role.
 * @summary List all organizations
 */
export const superAdminOrgsControllerGetAllOrgs = (
    params?: SuperAdminOrgsControllerGetAllOrgsParams,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<SuperAdminOrgListResponseDto>(
      {url: `/super-admin/orgs`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getSuperAdminOrgsControllerGetAllOrgsQueryKey = (params?: SuperAdminOrgsControllerGetAllOrgsParams,) => {
    return [`/super-admin/orgs`, ...(params ? [params]: [])] as const;
    }

    
export const getSuperAdminOrgsControllerGetAllOrgsQueryOptions = <TData = Awaited<ReturnType<typeof superAdminOrgsControllerGetAllOrgs>>, TError = void>(params?: SuperAdminOrgsControllerGetAllOrgsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminOrgsControllerGetAllOrgs>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSuperAdminOrgsControllerGetAllOrgsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof superAdminOrgsControllerGetAllOrgs>>> = ({ signal }) => superAdminOrgsControllerGetAllOrgs(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof superAdminOrgsControllerGetAllOrgs>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SuperAdminOrgsControllerGetAllOrgsQueryResult = NonNullable<Awaited<ReturnType<typeof superAdminOrgsControllerGetAllOrgs>>>
export type SuperAdminOrgsControllerGetAllOrgsQueryError = void


export function useSuperAdminOrgsControllerGetAllOrgs<TData = Awaited<ReturnType<typeof superAdminOrgsControllerGetAllOrgs>>, TError = void>(
 params: undefined |  SuperAdminOrgsControllerGetAllOrgsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminOrgsControllerGetAllOrgs>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof superAdminOrgsControllerGetAllOrgs>>,
          TError,
          Awaited<ReturnType<typeof superAdminOrgsControllerGetAllOrgs>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSuperAdminOrgsControllerGetAllOrgs<TData = Awaited<ReturnType<typeof superAdminOrgsControllerGetAllOrgs>>, TError = void>(
 params?: SuperAdminOrgsControllerGetAllOrgsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminOrgsControllerGetAllOrgs>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof superAdminOrgsControllerGetAllOrgs>>,
          TError,
          Awaited<ReturnType<typeof superAdminOrgsControllerGetAllOrgs>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSuperAdminOrgsControllerGetAllOrgs<TData = Awaited<ReturnType<typeof superAdminOrgsControllerGetAllOrgs>>, TError = void>(
 params?: SuperAdminOrgsControllerGetAllOrgsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminOrgsControllerGetAllOrgs>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List all organizations
 */

export function useSuperAdminOrgsControllerGetAllOrgs<TData = Awaited<ReturnType<typeof superAdminOrgsControllerGetAllOrgs>>, TError = void>(
 params?: SuperAdminOrgsControllerGetAllOrgsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminOrgsControllerGetAllOrgs>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSuperAdminOrgsControllerGetAllOrgsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve an organization by its ID. Only accessible to users with the super admin system role.
 * @summary Get an organization by ID
 */
export const superAdminOrgsControllerGetOrgById = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<SuperAdminOrgResponseDto>(
      {url: `/super-admin/orgs/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getSuperAdminOrgsControllerGetOrgByIdQueryKey = (id: string,) => {
    return [`/super-admin/orgs/${id}`] as const;
    }

    
export const getSuperAdminOrgsControllerGetOrgByIdQueryOptions = <TData = Awaited<ReturnType<typeof superAdminOrgsControllerGetOrgById>>, TError = void>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminOrgsControllerGetOrgById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSuperAdminOrgsControllerGetOrgByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof superAdminOrgsControllerGetOrgById>>> = ({ signal }) => superAdminOrgsControllerGetOrgById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof superAdminOrgsControllerGetOrgById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SuperAdminOrgsControllerGetOrgByIdQueryResult = NonNullable<Awaited<ReturnType<typeof superAdminOrgsControllerGetOrgById>>>
export type SuperAdminOrgsControllerGetOrgByIdQueryError = void


export function useSuperAdminOrgsControllerGetOrgById<TData = Awaited<ReturnType<typeof superAdminOrgsControllerGetOrgById>>, TError = void>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminOrgsControllerGetOrgById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof superAdminOrgsControllerGetOrgById>>,
          TError,
          Awaited<ReturnType<typeof superAdminOrgsControllerGetOrgById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSuperAdminOrgsControllerGetOrgById<TData = Awaited<ReturnType<typeof superAdminOrgsControllerGetOrgById>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminOrgsControllerGetOrgById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof superAdminOrgsControllerGetOrgById>>,
          TError,
          Awaited<ReturnType<typeof superAdminOrgsControllerGetOrgById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSuperAdminOrgsControllerGetOrgById<TData = Awaited<ReturnType<typeof superAdminOrgsControllerGetOrgById>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminOrgsControllerGetOrgById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get an organization by ID
 */

export function useSuperAdminOrgsControllerGetOrgById<TData = Awaited<ReturnType<typeof superAdminOrgsControllerGetOrgById>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminOrgsControllerGetOrgById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSuperAdminOrgsControllerGetOrgByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve paginated users that belong to the current authenticated user's organization. Returns user information without sensitive data like password hashes.
 * @summary Get users in current organization
 */
export const userControllerGetUsersInOrganization = (
    params?: UserControllerGetUsersInOrganizationParams,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<PaginatedUsersListResponseDto>(
      {url: `/users`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getUserControllerGetUsersInOrganizationQueryKey = (params?: UserControllerGetUsersInOrganizationParams,) => {
    return [`/users`, ...(params ? [params]: [])] as const;
    }

    
export const getUserControllerGetUsersInOrganizationQueryOptions = <TData = Awaited<ReturnType<typeof userControllerGetUsersInOrganization>>, TError = void>(params?: UserControllerGetUsersInOrganizationParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerGetUsersInOrganization>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUserControllerGetUsersInOrganizationQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userControllerGetUsersInOrganization>>> = ({ signal }) => userControllerGetUsersInOrganization(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userControllerGetUsersInOrganization>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UserControllerGetUsersInOrganizationQueryResult = NonNullable<Awaited<ReturnType<typeof userControllerGetUsersInOrganization>>>
export type UserControllerGetUsersInOrganizationQueryError = void


export function useUserControllerGetUsersInOrganization<TData = Awaited<ReturnType<typeof userControllerGetUsersInOrganization>>, TError = void>(
 params: undefined |  UserControllerGetUsersInOrganizationParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerGetUsersInOrganization>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerGetUsersInOrganization>>,
          TError,
          Awaited<ReturnType<typeof userControllerGetUsersInOrganization>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserControllerGetUsersInOrganization<TData = Awaited<ReturnType<typeof userControllerGetUsersInOrganization>>, TError = void>(
 params?: UserControllerGetUsersInOrganizationParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerGetUsersInOrganization>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerGetUsersInOrganization>>,
          TError,
          Awaited<ReturnType<typeof userControllerGetUsersInOrganization>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserControllerGetUsersInOrganization<TData = Awaited<ReturnType<typeof userControllerGetUsersInOrganization>>, TError = void>(
 params?: UserControllerGetUsersInOrganizationParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerGetUsersInOrganization>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get users in current organization
 */

export function useUserControllerGetUsersInOrganization<TData = Awaited<ReturnType<typeof userControllerGetUsersInOrganization>>, TError = void>(
 params?: UserControllerGetUsersInOrganizationParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerGetUsersInOrganization>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserControllerGetUsersInOrganizationQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update the role of a user. You cannot update your own role.
 * @summary Update user role
 */
export const userControllerUpdateUserRole = (
    id: string,
    updateUserRoleDto: UpdateUserRoleDto,
 ) => {
      
      
      return customAxiosInstance<UserResponseDto>(
      {url: `/users/${id}/role`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateUserRoleDto
    },
      );
    }
  


export const getUserControllerUpdateUserRoleMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerUpdateUserRole>>, TError,{id: string;data: UpdateUserRoleDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof userControllerUpdateUserRole>>, TError,{id: string;data: UpdateUserRoleDto}, TContext> => {

const mutationKey = ['userControllerUpdateUserRole'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userControllerUpdateUserRole>>, {id: string;data: UpdateUserRoleDto}> = (props) => {
          const {id,data} = props ?? {};

          return  userControllerUpdateUserRole(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserControllerUpdateUserRoleMutationResult = NonNullable<Awaited<ReturnType<typeof userControllerUpdateUserRole>>>
    export type UserControllerUpdateUserRoleMutationBody = UpdateUserRoleDto
    export type UserControllerUpdateUserRoleMutationError = void

    /**
 * @summary Update user role
 */
export const useUserControllerUpdateUserRole = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerUpdateUserRole>>, TError,{id: string;data: UpdateUserRoleDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof userControllerUpdateUserRole>>,
        TError,
        {id: string;data: UpdateUserRoleDto},
        TContext
      > => {

      const mutationOptions = getUserControllerUpdateUserRoleMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Update the name of a user. Users can only update their own name.
 * @summary Update user name
 */
export const userControllerUpdateUserName = (
    updateUserNameDto: UpdateUserNameDto,
 ) => {
      
      
      return customAxiosInstance<UserResponseDto>(
      {url: `/users/name`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateUserNameDto
    },
      );
    }
  


export const getUserControllerUpdateUserNameMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerUpdateUserName>>, TError,{data: UpdateUserNameDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof userControllerUpdateUserName>>, TError,{data: UpdateUserNameDto}, TContext> => {

const mutationKey = ['userControllerUpdateUserName'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userControllerUpdateUserName>>, {data: UpdateUserNameDto}> = (props) => {
          const {data} = props ?? {};

          return  userControllerUpdateUserName(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserControllerUpdateUserNameMutationResult = NonNullable<Awaited<ReturnType<typeof userControllerUpdateUserName>>>
    export type UserControllerUpdateUserNameMutationBody = UpdateUserNameDto
    export type UserControllerUpdateUserNameMutationError = void

    /**
 * @summary Update user name
 */
export const useUserControllerUpdateUserName = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerUpdateUserName>>, TError,{data: UpdateUserNameDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof userControllerUpdateUserName>>,
        TError,
        {data: UpdateUserNameDto},
        TContext
      > => {

      const mutationOptions = getUserControllerUpdateUserNameMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Update the password of the current authenticated user. Requires current password for verification.
 * @summary Update user password
 */
export const userControllerUpdatePassword = (
    updatePasswordDto: UpdatePasswordDto,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/users/password`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updatePasswordDto
    },
      );
    }
  


export const getUserControllerUpdatePasswordMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerUpdatePassword>>, TError,{data: UpdatePasswordDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof userControllerUpdatePassword>>, TError,{data: UpdatePasswordDto}, TContext> => {

const mutationKey = ['userControllerUpdatePassword'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userControllerUpdatePassword>>, {data: UpdatePasswordDto}> = (props) => {
          const {data} = props ?? {};

          return  userControllerUpdatePassword(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserControllerUpdatePasswordMutationResult = NonNullable<Awaited<ReturnType<typeof userControllerUpdatePassword>>>
    export type UserControllerUpdatePasswordMutationBody = UpdatePasswordDto
    export type UserControllerUpdatePasswordMutationError = void

    /**
 * @summary Update user password
 */
export const useUserControllerUpdatePassword = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerUpdatePassword>>, TError,{data: UpdatePasswordDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof userControllerUpdatePassword>>,
        TError,
        {data: UpdatePasswordDto},
        TContext
      > => {

      const mutationOptions = getUserControllerUpdatePasswordMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Confirm a user's email address using a JWT token received via email
 * @summary Confirm user email
 */
export const userControllerConfirmEmail = (
    confirmEmailDto: ConfirmEmailDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<void>(
      {url: `/users/confirm-email`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: confirmEmailDto, signal
    },
      );
    }
  


export const getUserControllerConfirmEmailMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerConfirmEmail>>, TError,{data: ConfirmEmailDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof userControllerConfirmEmail>>, TError,{data: ConfirmEmailDto}, TContext> => {

const mutationKey = ['userControllerConfirmEmail'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userControllerConfirmEmail>>, {data: ConfirmEmailDto}> = (props) => {
          const {data} = props ?? {};

          return  userControllerConfirmEmail(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserControllerConfirmEmailMutationResult = NonNullable<Awaited<ReturnType<typeof userControllerConfirmEmail>>>
    export type UserControllerConfirmEmailMutationBody = ConfirmEmailDto
    export type UserControllerConfirmEmailMutationError = void

    /**
 * @summary Confirm user email
 */
export const useUserControllerConfirmEmail = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerConfirmEmail>>, TError,{data: ConfirmEmailDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof userControllerConfirmEmail>>,
        TError,
        {data: ConfirmEmailDto},
        TContext
      > => {

      const mutationOptions = getUserControllerConfirmEmailMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Resend a confirmation email to the specified email address. Silently succeeds even if email is already verified or user does not exist for security reasons.
 * @summary Resend email confirmation
 */
export const userControllerResendEmailConfirmation = (
    resendEmailConfirmationDto: ResendEmailConfirmationDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<void>(
      {url: `/users/resend-confirmation`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: resendEmailConfirmationDto, signal
    },
      );
    }
  


export const getUserControllerResendEmailConfirmationMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerResendEmailConfirmation>>, TError,{data: ResendEmailConfirmationDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof userControllerResendEmailConfirmation>>, TError,{data: ResendEmailConfirmationDto}, TContext> => {

const mutationKey = ['userControllerResendEmailConfirmation'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userControllerResendEmailConfirmation>>, {data: ResendEmailConfirmationDto}> = (props) => {
          const {data} = props ?? {};

          return  userControllerResendEmailConfirmation(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserControllerResendEmailConfirmationMutationResult = NonNullable<Awaited<ReturnType<typeof userControllerResendEmailConfirmation>>>
    export type UserControllerResendEmailConfirmationMutationBody = ResendEmailConfirmationDto
    export type UserControllerResendEmailConfirmationMutationError = void

    /**
 * @summary Resend email confirmation
 */
export const useUserControllerResendEmailConfirmation = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerResendEmailConfirmation>>, TError,{data: ResendEmailConfirmationDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof userControllerResendEmailConfirmation>>,
        TError,
        {data: ResendEmailConfirmationDto},
        TContext
      > => {

      const mutationOptions = getUserControllerResendEmailConfirmationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a user by their ID. Only users within the same organization can be deleted.
 * @summary Delete a user
 */
export const userControllerDeleteUser = (
    id: string,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/users/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getUserControllerDeleteUserMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerDeleteUser>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof userControllerDeleteUser>>, TError,{id: string}, TContext> => {

const mutationKey = ['userControllerDeleteUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userControllerDeleteUser>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  userControllerDeleteUser(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserControllerDeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof userControllerDeleteUser>>>
    
    export type UserControllerDeleteUserMutationError = void

    /**
 * @summary Delete a user
 */
export const useUserControllerDeleteUser = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerDeleteUser>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof userControllerDeleteUser>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getUserControllerDeleteUserMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Send a password reset email to a user in your organization. Only organization admins can use this endpoint.
 * @summary Trigger password reset for a user
 */
export const userControllerTriggerPasswordResetForUser = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<void>(
      {url: `/users/${id}/trigger-password-reset`, method: 'POST', signal
    },
      );
    }
  


export const getUserControllerTriggerPasswordResetForUserMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerTriggerPasswordResetForUser>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof userControllerTriggerPasswordResetForUser>>, TError,{id: string}, TContext> => {

const mutationKey = ['userControllerTriggerPasswordResetForUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userControllerTriggerPasswordResetForUser>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  userControllerTriggerPasswordResetForUser(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserControllerTriggerPasswordResetForUserMutationResult = NonNullable<Awaited<ReturnType<typeof userControllerTriggerPasswordResetForUser>>>
    
    export type UserControllerTriggerPasswordResetForUserMutationError = void

    /**
 * @summary Trigger password reset for a user
 */
export const useUserControllerTriggerPasswordResetForUser = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerTriggerPasswordResetForUser>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof userControllerTriggerPasswordResetForUser>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getUserControllerTriggerPasswordResetForUserMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Send a password reset email to the provided email address. If the email exists in the system, a reset link will be sent.
 * @summary Trigger password reset
 */
export const userControllerForgotPassword = (
    forgotPasswordDto: ForgotPasswordDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<void>(
      {url: `/users/forgot-password`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: forgotPasswordDto, signal
    },
      );
    }
  


export const getUserControllerForgotPasswordMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerForgotPassword>>, TError,{data: ForgotPasswordDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof userControllerForgotPassword>>, TError,{data: ForgotPasswordDto}, TContext> => {

const mutationKey = ['userControllerForgotPassword'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userControllerForgotPassword>>, {data: ForgotPasswordDto}> = (props) => {
          const {data} = props ?? {};

          return  userControllerForgotPassword(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserControllerForgotPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof userControllerForgotPassword>>>
    export type UserControllerForgotPasswordMutationBody = ForgotPasswordDto
    export type UserControllerForgotPasswordMutationError = void

    /**
 * @summary Trigger password reset
 */
export const useUserControllerForgotPassword = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerForgotPassword>>, TError,{data: ForgotPasswordDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof userControllerForgotPassword>>,
        TError,
        {data: ForgotPasswordDto},
        TContext
      > => {

      const mutationOptions = getUserControllerForgotPasswordMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Reset user password using the token received via email. The token must be valid and not expired.
 * @summary Reset password with token
 */
export const userControllerResetPassword = (
    resetPasswordDto: ResetPasswordDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<void>(
      {url: `/users/reset-password`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: resetPasswordDto, signal
    },
      );
    }
  


export const getUserControllerResetPasswordMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerResetPassword>>, TError,{data: ResetPasswordDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof userControllerResetPassword>>, TError,{data: ResetPasswordDto}, TContext> => {

const mutationKey = ['userControllerResetPassword'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userControllerResetPassword>>, {data: ResetPasswordDto}> = (props) => {
          const {data} = props ?? {};

          return  userControllerResetPassword(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserControllerResetPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof userControllerResetPassword>>>
    export type UserControllerResetPasswordMutationBody = ResetPasswordDto
    export type UserControllerResetPasswordMutationError = void

    /**
 * @summary Reset password with token
 */
export const useUserControllerResetPassword = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerResetPassword>>, TError,{data: ResetPasswordDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof userControllerResetPassword>>,
        TError,
        {data: ResetPasswordDto},
        TContext
      > => {

      const mutationOptions = getUserControllerResetPasswordMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Validate a password reset token without performing the actual password reset. Used to check if a token is valid before showing the reset form.
 * @summary Validate password reset token
 */
export const userControllerValidateResetToken = (
    params: UserControllerValidateResetTokenParams,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<UserControllerValidateResetToken200>(
      {url: `/users/validate-reset-token`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getUserControllerValidateResetTokenQueryKey = (params: UserControllerValidateResetTokenParams,) => {
    return [`/users/validate-reset-token`, ...(params ? [params]: [])] as const;
    }

    
export const getUserControllerValidateResetTokenQueryOptions = <TData = Awaited<ReturnType<typeof userControllerValidateResetToken>>, TError = void>(params: UserControllerValidateResetTokenParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerValidateResetToken>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUserControllerValidateResetTokenQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userControllerValidateResetToken>>> = ({ signal }) => userControllerValidateResetToken(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userControllerValidateResetToken>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UserControllerValidateResetTokenQueryResult = NonNullable<Awaited<ReturnType<typeof userControllerValidateResetToken>>>
export type UserControllerValidateResetTokenQueryError = void


export function useUserControllerValidateResetToken<TData = Awaited<ReturnType<typeof userControllerValidateResetToken>>, TError = void>(
 params: UserControllerValidateResetTokenParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerValidateResetToken>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerValidateResetToken>>,
          TError,
          Awaited<ReturnType<typeof userControllerValidateResetToken>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserControllerValidateResetToken<TData = Awaited<ReturnType<typeof userControllerValidateResetToken>>, TError = void>(
 params: UserControllerValidateResetTokenParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerValidateResetToken>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerValidateResetToken>>,
          TError,
          Awaited<ReturnType<typeof userControllerValidateResetToken>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserControllerValidateResetToken<TData = Awaited<ReturnType<typeof userControllerValidateResetToken>>, TError = void>(
 params: UserControllerValidateResetTokenParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerValidateResetToken>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Validate password reset token
 */

export function useUserControllerValidateResetToken<TData = Awaited<ReturnType<typeof userControllerValidateResetToken>>, TError = void>(
 params: UserControllerValidateResetTokenParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerValidateResetToken>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserControllerValidateResetTokenQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve paginated users that belong to the specified organization. This endpoint is only accessible to super admins.
 * @summary Get users by organization ID
 */
export const superAdminUsersControllerGetUsersByOrgId = (
    orgId: string,
    params?: SuperAdminUsersControllerGetUsersByOrgIdParams,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<PaginatedUsersListResponseDto>(
      {url: `/super-admin/users/${orgId}`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getSuperAdminUsersControllerGetUsersByOrgIdQueryKey = (orgId: string,
    params?: SuperAdminUsersControllerGetUsersByOrgIdParams,) => {
    return [`/super-admin/users/${orgId}`, ...(params ? [params]: [])] as const;
    }

    
export const getSuperAdminUsersControllerGetUsersByOrgIdQueryOptions = <TData = Awaited<ReturnType<typeof superAdminUsersControllerGetUsersByOrgId>>, TError = void>(orgId: string,
    params?: SuperAdminUsersControllerGetUsersByOrgIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminUsersControllerGetUsersByOrgId>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSuperAdminUsersControllerGetUsersByOrgIdQueryKey(orgId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof superAdminUsersControllerGetUsersByOrgId>>> = ({ signal }) => superAdminUsersControllerGetUsersByOrgId(orgId,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orgId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof superAdminUsersControllerGetUsersByOrgId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SuperAdminUsersControllerGetUsersByOrgIdQueryResult = NonNullable<Awaited<ReturnType<typeof superAdminUsersControllerGetUsersByOrgId>>>
export type SuperAdminUsersControllerGetUsersByOrgIdQueryError = void


export function useSuperAdminUsersControllerGetUsersByOrgId<TData = Awaited<ReturnType<typeof superAdminUsersControllerGetUsersByOrgId>>, TError = void>(
 orgId: string,
    params: undefined |  SuperAdminUsersControllerGetUsersByOrgIdParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminUsersControllerGetUsersByOrgId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof superAdminUsersControllerGetUsersByOrgId>>,
          TError,
          Awaited<ReturnType<typeof superAdminUsersControllerGetUsersByOrgId>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSuperAdminUsersControllerGetUsersByOrgId<TData = Awaited<ReturnType<typeof superAdminUsersControllerGetUsersByOrgId>>, TError = void>(
 orgId: string,
    params?: SuperAdminUsersControllerGetUsersByOrgIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminUsersControllerGetUsersByOrgId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof superAdminUsersControllerGetUsersByOrgId>>,
          TError,
          Awaited<ReturnType<typeof superAdminUsersControllerGetUsersByOrgId>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSuperAdminUsersControllerGetUsersByOrgId<TData = Awaited<ReturnType<typeof superAdminUsersControllerGetUsersByOrgId>>, TError = void>(
 orgId: string,
    params?: SuperAdminUsersControllerGetUsersByOrgIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminUsersControllerGetUsersByOrgId>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get users by organization ID
 */

export function useSuperAdminUsersControllerGetUsersByOrgId<TData = Awaited<ReturnType<typeof superAdminUsersControllerGetUsersByOrgId>>, TError = void>(
 orgId: string,
    params?: SuperAdminUsersControllerGetUsersByOrgIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminUsersControllerGetUsersByOrgId>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSuperAdminUsersControllerGetUsersByOrgIdQueryOptions(orgId,params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Delete a user by their ID. This endpoint is only accessible to super admins and allows deletion of users from any organization.
 * @summary Delete a user
 */
export const superAdminUsersControllerDeleteUser = (
    userId: string,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/super-admin/users/${userId}`, method: 'DELETE'
    },
      );
    }
  


export const getSuperAdminUsersControllerDeleteUserMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminUsersControllerDeleteUser>>, TError,{userId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof superAdminUsersControllerDeleteUser>>, TError,{userId: string}, TContext> => {

const mutationKey = ['superAdminUsersControllerDeleteUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof superAdminUsersControllerDeleteUser>>, {userId: string}> = (props) => {
          const {userId} = props ?? {};

          return  superAdminUsersControllerDeleteUser(userId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuperAdminUsersControllerDeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof superAdminUsersControllerDeleteUser>>>
    
    export type SuperAdminUsersControllerDeleteUserMutationError = void

    /**
 * @summary Delete a user
 */
export const useSuperAdminUsersControllerDeleteUser = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminUsersControllerDeleteUser>>, TError,{userId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof superAdminUsersControllerDeleteUser>>,
        TError,
        {userId: string},
        TContext
      > => {

      const mutationOptions = getSuperAdminUsersControllerDeleteUserMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Send a password reset email to the specified user. This endpoint is only accessible to super admins.
 * @summary Trigger password reset for a user
 */
export const superAdminUsersControllerTriggerPasswordReset = (
    userId: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<void>(
      {url: `/super-admin/users/${userId}/trigger-password-reset`, method: 'POST', signal
    },
      );
    }
  


export const getSuperAdminUsersControllerTriggerPasswordResetMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminUsersControllerTriggerPasswordReset>>, TError,{userId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof superAdminUsersControllerTriggerPasswordReset>>, TError,{userId: string}, TContext> => {

const mutationKey = ['superAdminUsersControllerTriggerPasswordReset'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof superAdminUsersControllerTriggerPasswordReset>>, {userId: string}> = (props) => {
          const {userId} = props ?? {};

          return  superAdminUsersControllerTriggerPasswordReset(userId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuperAdminUsersControllerTriggerPasswordResetMutationResult = NonNullable<Awaited<ReturnType<typeof superAdminUsersControllerTriggerPasswordReset>>>
    
    export type SuperAdminUsersControllerTriggerPasswordResetMutationError = void

    /**
 * @summary Trigger password reset for a user
 */
export const useSuperAdminUsersControllerTriggerPasswordReset = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminUsersControllerTriggerPasswordReset>>, TError,{userId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof superAdminUsersControllerTriggerPasswordReset>>,
        TError,
        {userId: string},
        TContext
      > => {

      const mutationOptions = getSuperAdminUsersControllerTriggerPasswordResetMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Create a new user in the specified organization with a randomly generated password. A password reset email will be sent to the user. This endpoint is only accessible to super admins.
 * @summary Create a new user in an organization
 */
export const superAdminUsersControllerCreateUser = (
    orgId: string,
    createUserDto: CreateUserDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<UserResponseDto>(
      {url: `/super-admin/users/${orgId}/create`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createUserDto, signal
    },
      );
    }
  


export const getSuperAdminUsersControllerCreateUserMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminUsersControllerCreateUser>>, TError,{orgId: string;data: CreateUserDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof superAdminUsersControllerCreateUser>>, TError,{orgId: string;data: CreateUserDto}, TContext> => {

const mutationKey = ['superAdminUsersControllerCreateUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof superAdminUsersControllerCreateUser>>, {orgId: string;data: CreateUserDto}> = (props) => {
          const {orgId,data} = props ?? {};

          return  superAdminUsersControllerCreateUser(orgId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuperAdminUsersControllerCreateUserMutationResult = NonNullable<Awaited<ReturnType<typeof superAdminUsersControllerCreateUser>>>
    export type SuperAdminUsersControllerCreateUserMutationBody = CreateUserDto
    export type SuperAdminUsersControllerCreateUserMutationError = void

    /**
 * @summary Create a new user in an organization
 */
export const useSuperAdminUsersControllerCreateUser = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminUsersControllerCreateUser>>, TError,{orgId: string;data: CreateUserDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof superAdminUsersControllerCreateUser>>,
        TError,
        {orgId: string;data: CreateUserDto},
        TContext
      > => {

      const mutationOptions = getSuperAdminUsersControllerCreateUserMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Send an invitation to a user to join an organization with a specific role
 * @summary Create a new invite
 */
export const invitesControllerCreate = (
    createInviteDto: CreateInviteDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<CreateInviteResponseDto>(
      {url: `/invites`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createInviteDto, signal
    },
      );
    }
  


export const getInvitesControllerCreateMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invitesControllerCreate>>, TError,{data: CreateInviteDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof invitesControllerCreate>>, TError,{data: CreateInviteDto}, TContext> => {

const mutationKey = ['invitesControllerCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof invitesControllerCreate>>, {data: CreateInviteDto}> = (props) => {
          const {data} = props ?? {};

          return  invitesControllerCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InvitesControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof invitesControllerCreate>>>
    export type InvitesControllerCreateMutationBody = CreateInviteDto
    export type InvitesControllerCreateMutationError = void

    /**
 * @summary Create a new invite
 */
export const useInvitesControllerCreate = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invitesControllerCreate>>, TError,{data: CreateInviteDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof invitesControllerCreate>>,
        TError,
        {data: CreateInviteDto},
        TContext
      > => {

      const mutationOptions = getInvitesControllerCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve paginated invites with optional search
 * @summary Get all invites for current user's organization
 */
export const invitesControllerGetInvites = (
    params?: InvitesControllerGetInvitesParams,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<PaginatedInvitesListResponseDto>(
      {url: `/invites`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getInvitesControllerGetInvitesQueryKey = (params?: InvitesControllerGetInvitesParams,) => {
    return [`/invites`, ...(params ? [params]: [])] as const;
    }

    
export const getInvitesControllerGetInvitesQueryOptions = <TData = Awaited<ReturnType<typeof invitesControllerGetInvites>>, TError = void>(params?: InvitesControllerGetInvitesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invitesControllerGetInvites>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInvitesControllerGetInvitesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof invitesControllerGetInvites>>> = ({ signal }) => invitesControllerGetInvites(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof invitesControllerGetInvites>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type InvitesControllerGetInvitesQueryResult = NonNullable<Awaited<ReturnType<typeof invitesControllerGetInvites>>>
export type InvitesControllerGetInvitesQueryError = void


export function useInvitesControllerGetInvites<TData = Awaited<ReturnType<typeof invitesControllerGetInvites>>, TError = void>(
 params: undefined |  InvitesControllerGetInvitesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof invitesControllerGetInvites>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof invitesControllerGetInvites>>,
          TError,
          Awaited<ReturnType<typeof invitesControllerGetInvites>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInvitesControllerGetInvites<TData = Awaited<ReturnType<typeof invitesControllerGetInvites>>, TError = void>(
 params?: InvitesControllerGetInvitesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invitesControllerGetInvites>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof invitesControllerGetInvites>>,
          TError,
          Awaited<ReturnType<typeof invitesControllerGetInvites>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInvitesControllerGetInvites<TData = Awaited<ReturnType<typeof invitesControllerGetInvites>>, TError = void>(
 params?: InvitesControllerGetInvitesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invitesControllerGetInvites>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all invites for current user's organization
 */

export function useInvitesControllerGetInvites<TData = Awaited<ReturnType<typeof invitesControllerGetInvites>>, TError = void>(
 params?: InvitesControllerGetInvitesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invitesControllerGetInvites>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getInvitesControllerGetInvitesQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Send invitations to multiple users. All rows are validated before any are processed.
 * @summary Create multiple invites in bulk
 */
export const invitesControllerCreateBulk = (
    createBulkInvitesDto: CreateBulkInvitesDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<CreateBulkInvitesResponseDto>(
      {url: `/invites/bulk`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createBulkInvitesDto, signal
    },
      );
    }
  


export const getInvitesControllerCreateBulkMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invitesControllerCreateBulk>>, TError,{data: CreateBulkInvitesDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof invitesControllerCreateBulk>>, TError,{data: CreateBulkInvitesDto}, TContext> => {

const mutationKey = ['invitesControllerCreateBulk'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof invitesControllerCreateBulk>>, {data: CreateBulkInvitesDto}> = (props) => {
          const {data} = props ?? {};

          return  invitesControllerCreateBulk(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InvitesControllerCreateBulkMutationResult = NonNullable<Awaited<ReturnType<typeof invitesControllerCreateBulk>>>
    export type InvitesControllerCreateBulkMutationBody = CreateBulkInvitesDto
    export type InvitesControllerCreateBulkMutationError = void

    /**
 * @summary Create multiple invites in bulk
 */
export const useInvitesControllerCreateBulk = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invitesControllerCreateBulk>>, TError,{data: CreateBulkInvitesDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof invitesControllerCreateBulk>>,
        TError,
        {data: CreateBulkInvitesDto},
        TContext
      > => {

      const mutationOptions = getInvitesControllerCreateBulkMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve invite details including organization name by token
 * @summary Get a single invite by token
 */
export const invitesControllerGetInviteByToken = (
    token: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<InviteDetailResponseDto>(
      {url: `/invites/${token}`, method: 'GET', signal
    },
      );
    }
  

export const getInvitesControllerGetInviteByTokenQueryKey = (token: string,) => {
    return [`/invites/${token}`] as const;
    }

    
export const getInvitesControllerGetInviteByTokenQueryOptions = <TData = Awaited<ReturnType<typeof invitesControllerGetInviteByToken>>, TError = void>(token: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invitesControllerGetInviteByToken>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInvitesControllerGetInviteByTokenQueryKey(token);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof invitesControllerGetInviteByToken>>> = ({ signal }) => invitesControllerGetInviteByToken(token, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(token), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof invitesControllerGetInviteByToken>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type InvitesControllerGetInviteByTokenQueryResult = NonNullable<Awaited<ReturnType<typeof invitesControllerGetInviteByToken>>>
export type InvitesControllerGetInviteByTokenQueryError = void


export function useInvitesControllerGetInviteByToken<TData = Awaited<ReturnType<typeof invitesControllerGetInviteByToken>>, TError = void>(
 token: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof invitesControllerGetInviteByToken>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof invitesControllerGetInviteByToken>>,
          TError,
          Awaited<ReturnType<typeof invitesControllerGetInviteByToken>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInvitesControllerGetInviteByToken<TData = Awaited<ReturnType<typeof invitesControllerGetInviteByToken>>, TError = void>(
 token: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invitesControllerGetInviteByToken>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof invitesControllerGetInviteByToken>>,
          TError,
          Awaited<ReturnType<typeof invitesControllerGetInviteByToken>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInvitesControllerGetInviteByToken<TData = Awaited<ReturnType<typeof invitesControllerGetInviteByToken>>, TError = void>(
 token: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invitesControllerGetInviteByToken>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a single invite by token
 */

export function useInvitesControllerGetInviteByToken<TData = Awaited<ReturnType<typeof invitesControllerGetInviteByToken>>, TError = void>(
 token: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof invitesControllerGetInviteByToken>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getInvitesControllerGetInviteByTokenQueryOptions(token,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Accept an invitation using the JWT token
 * @summary Accept an invite
 */
export const invitesControllerAcceptInvite = (
    acceptInviteDto: AcceptInviteDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<AcceptInviteResponseDto>(
      {url: `/invites/accept`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: acceptInviteDto, signal
    },
      );
    }
  


export const getInvitesControllerAcceptInviteMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invitesControllerAcceptInvite>>, TError,{data: AcceptInviteDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof invitesControllerAcceptInvite>>, TError,{data: AcceptInviteDto}, TContext> => {

const mutationKey = ['invitesControllerAcceptInvite'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof invitesControllerAcceptInvite>>, {data: AcceptInviteDto}> = (props) => {
          const {data} = props ?? {};

          return  invitesControllerAcceptInvite(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InvitesControllerAcceptInviteMutationResult = NonNullable<Awaited<ReturnType<typeof invitesControllerAcceptInvite>>>
    export type InvitesControllerAcceptInviteMutationBody = AcceptInviteDto
    export type InvitesControllerAcceptInviteMutationError = void

    /**
 * @summary Accept an invite
 */
export const useInvitesControllerAcceptInvite = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invitesControllerAcceptInvite>>, TError,{data: AcceptInviteDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof invitesControllerAcceptInvite>>,
        TError,
        {data: AcceptInviteDto},
        TContext
      > => {

      const mutationOptions = getInvitesControllerAcceptInviteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete the expired invite and create a new one with the same details, then send the invitation email
 * @summary Resend an expired invite
 */
export const invitesControllerResendExpiredInvite = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<CreateInviteResponseDto>(
      {url: `/invites/${id}/resend`, method: 'POST', signal
    },
      );
    }
  


export const getInvitesControllerResendExpiredInviteMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invitesControllerResendExpiredInvite>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof invitesControllerResendExpiredInvite>>, TError,{id: string}, TContext> => {

const mutationKey = ['invitesControllerResendExpiredInvite'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof invitesControllerResendExpiredInvite>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  invitesControllerResendExpiredInvite(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InvitesControllerResendExpiredInviteMutationResult = NonNullable<Awaited<ReturnType<typeof invitesControllerResendExpiredInvite>>>
    
    export type InvitesControllerResendExpiredInviteMutationError = void

    /**
 * @summary Resend an expired invite
 */
export const useInvitesControllerResendExpiredInvite = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invitesControllerResendExpiredInvite>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof invitesControllerResendExpiredInvite>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getInvitesControllerResendExpiredInviteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete all pending invitations for the organization (Admin only)
 * @summary Delete all pending invites
 */
export const invitesControllerDeleteAllPending = (
    
 ) => {
      
      
      return customAxiosInstance<DeleteAllPendingInvitesResponseDto>(
      {url: `/invites/all`, method: 'DELETE'
    },
      );
    }
  


export const getInvitesControllerDeleteAllPendingMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invitesControllerDeleteAllPending>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof invitesControllerDeleteAllPending>>, TError,void, TContext> => {

const mutationKey = ['invitesControllerDeleteAllPending'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof invitesControllerDeleteAllPending>>, void> = () => {
          

          return  invitesControllerDeleteAllPending()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InvitesControllerDeleteAllPendingMutationResult = NonNullable<Awaited<ReturnType<typeof invitesControllerDeleteAllPending>>>
    
    export type InvitesControllerDeleteAllPendingMutationError = void

    /**
 * @summary Delete all pending invites
 */
export const useInvitesControllerDeleteAllPending = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invitesControllerDeleteAllPending>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof invitesControllerDeleteAllPending>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getInvitesControllerDeleteAllPendingMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete an invitation (only allowed by the user who created it)
 * @summary Delete an invite
 */
export const invitesControllerDeleteInvite = (
    id: string,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/invites/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getInvitesControllerDeleteInviteMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invitesControllerDeleteInvite>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof invitesControllerDeleteInvite>>, TError,{id: string}, TContext> => {

const mutationKey = ['invitesControllerDeleteInvite'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof invitesControllerDeleteInvite>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  invitesControllerDeleteInvite(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InvitesControllerDeleteInviteMutationResult = NonNullable<Awaited<ReturnType<typeof invitesControllerDeleteInvite>>>
    
    export type InvitesControllerDeleteInviteMutationError = void

    /**
 * @summary Delete an invite
 */
export const useInvitesControllerDeleteInvite = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof invitesControllerDeleteInvite>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof invitesControllerDeleteInvite>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getInvitesControllerDeleteInviteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get subscription details for the current organization
 */
export const subscriptionsControllerGetSubscription = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<SubscriptionResponseDtoNullable>(
      {url: `/subscriptions`, method: 'GET', signal
    },
      );
    }
  

export const getSubscriptionsControllerGetSubscriptionQueryKey = () => {
    return [`/subscriptions`] as const;
    }

    
export const getSubscriptionsControllerGetSubscriptionQueryOptions = <TData = Awaited<ReturnType<typeof subscriptionsControllerGetSubscription>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof subscriptionsControllerGetSubscription>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubscriptionsControllerGetSubscriptionQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof subscriptionsControllerGetSubscription>>> = ({ signal }) => subscriptionsControllerGetSubscription(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof subscriptionsControllerGetSubscription>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SubscriptionsControllerGetSubscriptionQueryResult = NonNullable<Awaited<ReturnType<typeof subscriptionsControllerGetSubscription>>>
export type SubscriptionsControllerGetSubscriptionQueryError = void


export function useSubscriptionsControllerGetSubscription<TData = Awaited<ReturnType<typeof subscriptionsControllerGetSubscription>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof subscriptionsControllerGetSubscription>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof subscriptionsControllerGetSubscription>>,
          TError,
          Awaited<ReturnType<typeof subscriptionsControllerGetSubscription>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubscriptionsControllerGetSubscription<TData = Awaited<ReturnType<typeof subscriptionsControllerGetSubscription>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof subscriptionsControllerGetSubscription>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof subscriptionsControllerGetSubscription>>,
          TError,
          Awaited<ReturnType<typeof subscriptionsControllerGetSubscription>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubscriptionsControllerGetSubscription<TData = Awaited<ReturnType<typeof subscriptionsControllerGetSubscription>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof subscriptionsControllerGetSubscription>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get subscription details for the current organization
 */

export function useSubscriptionsControllerGetSubscription<TData = Awaited<ReturnType<typeof subscriptionsControllerGetSubscription>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof subscriptionsControllerGetSubscription>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubscriptionsControllerGetSubscriptionQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a new subscription for the current organization
 */
export const subscriptionsControllerCreateSubscription = (
    createSubscriptionRequestDto: CreateSubscriptionRequestDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<SubscriptionResponseDto>(
      {url: `/subscriptions`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createSubscriptionRequestDto, signal
    },
      );
    }
  


export const getSubscriptionsControllerCreateSubscriptionMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof subscriptionsControllerCreateSubscription>>, TError,{data: CreateSubscriptionRequestDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof subscriptionsControllerCreateSubscription>>, TError,{data: CreateSubscriptionRequestDto}, TContext> => {

const mutationKey = ['subscriptionsControllerCreateSubscription'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof subscriptionsControllerCreateSubscription>>, {data: CreateSubscriptionRequestDto}> = (props) => {
          const {data} = props ?? {};

          return  subscriptionsControllerCreateSubscription(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SubscriptionsControllerCreateSubscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof subscriptionsControllerCreateSubscription>>>
    export type SubscriptionsControllerCreateSubscriptionMutationBody = CreateSubscriptionRequestDto
    export type SubscriptionsControllerCreateSubscriptionMutationError = void

    /**
 * @summary Create a new subscription for the current organization
 */
export const useSubscriptionsControllerCreateSubscription = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof subscriptionsControllerCreateSubscription>>, TError,{data: CreateSubscriptionRequestDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof subscriptionsControllerCreateSubscription>>,
        TError,
        {data: CreateSubscriptionRequestDto},
        TContext
      > => {

      const mutationOptions = getSubscriptionsControllerCreateSubscriptionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Cancel the subscription for the current organization
 */
export const subscriptionsControllerCancelSubscription = (
    
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/subscriptions`, method: 'DELETE'
    },
      );
    }
  


export const getSubscriptionsControllerCancelSubscriptionMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof subscriptionsControllerCancelSubscription>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof subscriptionsControllerCancelSubscription>>, TError,void, TContext> => {

const mutationKey = ['subscriptionsControllerCancelSubscription'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof subscriptionsControllerCancelSubscription>>, void> = () => {
          

          return  subscriptionsControllerCancelSubscription()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SubscriptionsControllerCancelSubscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof subscriptionsControllerCancelSubscription>>>
    
    export type SubscriptionsControllerCancelSubscriptionMutationError = void

    /**
 * @summary Cancel the subscription for the current organization
 */
export const useSubscriptionsControllerCancelSubscription = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof subscriptionsControllerCancelSubscription>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof subscriptionsControllerCancelSubscription>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getSubscriptionsControllerCancelSubscriptionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Check if the current organization has an active subscription
 */
export const subscriptionsControllerHasActiveSubscription = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<ActiveSubscriptionResponseDto>(
      {url: `/subscriptions/active`, method: 'GET', signal
    },
      );
    }
  

export const getSubscriptionsControllerHasActiveSubscriptionQueryKey = () => {
    return [`/subscriptions/active`] as const;
    }

    
export const getSubscriptionsControllerHasActiveSubscriptionQueryOptions = <TData = Awaited<ReturnType<typeof subscriptionsControllerHasActiveSubscription>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof subscriptionsControllerHasActiveSubscription>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubscriptionsControllerHasActiveSubscriptionQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof subscriptionsControllerHasActiveSubscription>>> = ({ signal }) => subscriptionsControllerHasActiveSubscription(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof subscriptionsControllerHasActiveSubscription>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SubscriptionsControllerHasActiveSubscriptionQueryResult = NonNullable<Awaited<ReturnType<typeof subscriptionsControllerHasActiveSubscription>>>
export type SubscriptionsControllerHasActiveSubscriptionQueryError = void


export function useSubscriptionsControllerHasActiveSubscription<TData = Awaited<ReturnType<typeof subscriptionsControllerHasActiveSubscription>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof subscriptionsControllerHasActiveSubscription>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof subscriptionsControllerHasActiveSubscription>>,
          TError,
          Awaited<ReturnType<typeof subscriptionsControllerHasActiveSubscription>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubscriptionsControllerHasActiveSubscription<TData = Awaited<ReturnType<typeof subscriptionsControllerHasActiveSubscription>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof subscriptionsControllerHasActiveSubscription>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof subscriptionsControllerHasActiveSubscription>>,
          TError,
          Awaited<ReturnType<typeof subscriptionsControllerHasActiveSubscription>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubscriptionsControllerHasActiveSubscription<TData = Awaited<ReturnType<typeof subscriptionsControllerHasActiveSubscription>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof subscriptionsControllerHasActiveSubscription>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Check if the current organization has an active subscription
 */

export function useSubscriptionsControllerHasActiveSubscription<TData = Awaited<ReturnType<typeof subscriptionsControllerHasActiveSubscription>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof subscriptionsControllerHasActiveSubscription>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubscriptionsControllerHasActiveSubscriptionQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get the current price per seat monthly
 */
export const subscriptionsControllerGetCurrentPrice = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<PriceResponseDto>(
      {url: `/subscriptions/price`, method: 'GET', signal
    },
      );
    }
  

export const getSubscriptionsControllerGetCurrentPriceQueryKey = () => {
    return [`/subscriptions/price`] as const;
    }

    
export const getSubscriptionsControllerGetCurrentPriceQueryOptions = <TData = Awaited<ReturnType<typeof subscriptionsControllerGetCurrentPrice>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof subscriptionsControllerGetCurrentPrice>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSubscriptionsControllerGetCurrentPriceQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof subscriptionsControllerGetCurrentPrice>>> = ({ signal }) => subscriptionsControllerGetCurrentPrice(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof subscriptionsControllerGetCurrentPrice>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SubscriptionsControllerGetCurrentPriceQueryResult = NonNullable<Awaited<ReturnType<typeof subscriptionsControllerGetCurrentPrice>>>
export type SubscriptionsControllerGetCurrentPriceQueryError = void


export function useSubscriptionsControllerGetCurrentPrice<TData = Awaited<ReturnType<typeof subscriptionsControllerGetCurrentPrice>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof subscriptionsControllerGetCurrentPrice>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof subscriptionsControllerGetCurrentPrice>>,
          TError,
          Awaited<ReturnType<typeof subscriptionsControllerGetCurrentPrice>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubscriptionsControllerGetCurrentPrice<TData = Awaited<ReturnType<typeof subscriptionsControllerGetCurrentPrice>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof subscriptionsControllerGetCurrentPrice>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof subscriptionsControllerGetCurrentPrice>>,
          TError,
          Awaited<ReturnType<typeof subscriptionsControllerGetCurrentPrice>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSubscriptionsControllerGetCurrentPrice<TData = Awaited<ReturnType<typeof subscriptionsControllerGetCurrentPrice>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof subscriptionsControllerGetCurrentPrice>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get the current price per seat monthly
 */

export function useSubscriptionsControllerGetCurrentPrice<TData = Awaited<ReturnType<typeof subscriptionsControllerGetCurrentPrice>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof subscriptionsControllerGetCurrentPrice>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSubscriptionsControllerGetCurrentPriceQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update the number of seats for the current organization
 */
export const subscriptionsControllerUpdateSeats = (
    updateSeatsDto: UpdateSeatsDto,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/subscriptions/seats`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateSeatsDto
    },
      );
    }
  


export const getSubscriptionsControllerUpdateSeatsMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof subscriptionsControllerUpdateSeats>>, TError,{data: UpdateSeatsDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof subscriptionsControllerUpdateSeats>>, TError,{data: UpdateSeatsDto}, TContext> => {

const mutationKey = ['subscriptionsControllerUpdateSeats'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof subscriptionsControllerUpdateSeats>>, {data: UpdateSeatsDto}> = (props) => {
          const {data} = props ?? {};

          return  subscriptionsControllerUpdateSeats(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SubscriptionsControllerUpdateSeatsMutationResult = NonNullable<Awaited<ReturnType<typeof subscriptionsControllerUpdateSeats>>>
    export type SubscriptionsControllerUpdateSeatsMutationBody = UpdateSeatsDto
    export type SubscriptionsControllerUpdateSeatsMutationError = void

    /**
 * @summary Update the number of seats for the current organization
 */
export const useSubscriptionsControllerUpdateSeats = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof subscriptionsControllerUpdateSeats>>, TError,{data: UpdateSeatsDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof subscriptionsControllerUpdateSeats>>,
        TError,
        {data: UpdateSeatsDto},
        TContext
      > => {

      const mutationOptions = getSubscriptionsControllerUpdateSeatsMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Update the billing information for the current organization
 */
export const subscriptionsControllerUpdateBillingInfo = (
    updateBillingInfoDto: UpdateBillingInfoDto,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/subscriptions/billing-info`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateBillingInfoDto
    },
      );
    }
  


export const getSubscriptionsControllerUpdateBillingInfoMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof subscriptionsControllerUpdateBillingInfo>>, TError,{data: UpdateBillingInfoDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof subscriptionsControllerUpdateBillingInfo>>, TError,{data: UpdateBillingInfoDto}, TContext> => {

const mutationKey = ['subscriptionsControllerUpdateBillingInfo'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof subscriptionsControllerUpdateBillingInfo>>, {data: UpdateBillingInfoDto}> = (props) => {
          const {data} = props ?? {};

          return  subscriptionsControllerUpdateBillingInfo(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SubscriptionsControllerUpdateBillingInfoMutationResult = NonNullable<Awaited<ReturnType<typeof subscriptionsControllerUpdateBillingInfo>>>
    export type SubscriptionsControllerUpdateBillingInfoMutationBody = UpdateBillingInfoDto
    export type SubscriptionsControllerUpdateBillingInfoMutationError = void

    /**
 * @summary Update the billing information for the current organization
 */
export const useSubscriptionsControllerUpdateBillingInfo = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof subscriptionsControllerUpdateBillingInfo>>, TError,{data: UpdateBillingInfoDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof subscriptionsControllerUpdateBillingInfo>>,
        TError,
        {data: UpdateBillingInfoDto},
        TContext
      > => {

      const mutationOptions = getSubscriptionsControllerUpdateBillingInfoMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Uncancel the subscription for the current organization
 */
export const subscriptionsControllerUncancelSubscription = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<void>(
      {url: `/subscriptions/uncancel`, method: 'POST', signal
    },
      );
    }
  


export const getSubscriptionsControllerUncancelSubscriptionMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof subscriptionsControllerUncancelSubscription>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof subscriptionsControllerUncancelSubscription>>, TError,void, TContext> => {

const mutationKey = ['subscriptionsControllerUncancelSubscription'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof subscriptionsControllerUncancelSubscription>>, void> = () => {
          

          return  subscriptionsControllerUncancelSubscription()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SubscriptionsControllerUncancelSubscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof subscriptionsControllerUncancelSubscription>>>
    
    export type SubscriptionsControllerUncancelSubscriptionMutationError = void

    /**
 * @summary Uncancel the subscription for the current organization
 */
export const useSubscriptionsControllerUncancelSubscription = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof subscriptionsControllerUncancelSubscription>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof subscriptionsControllerUncancelSubscription>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getSubscriptionsControllerUncancelSubscriptionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve subscription details for the specified organization. This endpoint is only accessible to super admins.
 * @summary Get subscription details for a specific organization
 */
export const superAdminSubscriptionsControllerGetSubscription = (
    orgId: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<SubscriptionResponseDtoNullable>(
      {url: `/super-admin/subscriptions/${orgId}`, method: 'GET', signal
    },
      );
    }
  

export const getSuperAdminSubscriptionsControllerGetSubscriptionQueryKey = (orgId: string,) => {
    return [`/super-admin/subscriptions/${orgId}`] as const;
    }

    
export const getSuperAdminSubscriptionsControllerGetSubscriptionQueryOptions = <TData = Awaited<ReturnType<typeof superAdminSubscriptionsControllerGetSubscription>>, TError = void>(orgId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminSubscriptionsControllerGetSubscription>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSuperAdminSubscriptionsControllerGetSubscriptionQueryKey(orgId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof superAdminSubscriptionsControllerGetSubscription>>> = ({ signal }) => superAdminSubscriptionsControllerGetSubscription(orgId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orgId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof superAdminSubscriptionsControllerGetSubscription>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SuperAdminSubscriptionsControllerGetSubscriptionQueryResult = NonNullable<Awaited<ReturnType<typeof superAdminSubscriptionsControllerGetSubscription>>>
export type SuperAdminSubscriptionsControllerGetSubscriptionQueryError = void


export function useSuperAdminSubscriptionsControllerGetSubscription<TData = Awaited<ReturnType<typeof superAdminSubscriptionsControllerGetSubscription>>, TError = void>(
 orgId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminSubscriptionsControllerGetSubscription>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof superAdminSubscriptionsControllerGetSubscription>>,
          TError,
          Awaited<ReturnType<typeof superAdminSubscriptionsControllerGetSubscription>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSuperAdminSubscriptionsControllerGetSubscription<TData = Awaited<ReturnType<typeof superAdminSubscriptionsControllerGetSubscription>>, TError = void>(
 orgId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminSubscriptionsControllerGetSubscription>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof superAdminSubscriptionsControllerGetSubscription>>,
          TError,
          Awaited<ReturnType<typeof superAdminSubscriptionsControllerGetSubscription>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSuperAdminSubscriptionsControllerGetSubscription<TData = Awaited<ReturnType<typeof superAdminSubscriptionsControllerGetSubscription>>, TError = void>(
 orgId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminSubscriptionsControllerGetSubscription>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get subscription details for a specific organization
 */

export function useSuperAdminSubscriptionsControllerGetSubscription<TData = Awaited<ReturnType<typeof superAdminSubscriptionsControllerGetSubscription>>, TError = void>(
 orgId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminSubscriptionsControllerGetSubscription>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSuperAdminSubscriptionsControllerGetSubscriptionQueryOptions(orgId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new subscription for the specified organization. This endpoint is only accessible to super admins.
 * @summary Create a new subscription for a specific organization
 */
export const superAdminSubscriptionsControllerCreateSubscription = (
    orgId: string,
    createSubscriptionRequestDto: CreateSubscriptionRequestDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<SubscriptionResponseDto>(
      {url: `/super-admin/subscriptions/${orgId}`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createSubscriptionRequestDto, signal
    },
      );
    }
  


export const getSuperAdminSubscriptionsControllerCreateSubscriptionMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminSubscriptionsControllerCreateSubscription>>, TError,{orgId: string;data: CreateSubscriptionRequestDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof superAdminSubscriptionsControllerCreateSubscription>>, TError,{orgId: string;data: CreateSubscriptionRequestDto}, TContext> => {

const mutationKey = ['superAdminSubscriptionsControllerCreateSubscription'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof superAdminSubscriptionsControllerCreateSubscription>>, {orgId: string;data: CreateSubscriptionRequestDto}> = (props) => {
          const {orgId,data} = props ?? {};

          return  superAdminSubscriptionsControllerCreateSubscription(orgId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuperAdminSubscriptionsControllerCreateSubscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof superAdminSubscriptionsControllerCreateSubscription>>>
    export type SuperAdminSubscriptionsControllerCreateSubscriptionMutationBody = CreateSubscriptionRequestDto
    export type SuperAdminSubscriptionsControllerCreateSubscriptionMutationError = void

    /**
 * @summary Create a new subscription for a specific organization
 */
export const useSuperAdminSubscriptionsControllerCreateSubscription = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminSubscriptionsControllerCreateSubscription>>, TError,{orgId: string;data: CreateSubscriptionRequestDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof superAdminSubscriptionsControllerCreateSubscription>>,
        TError,
        {orgId: string;data: CreateSubscriptionRequestDto},
        TContext
      > => {

      const mutationOptions = getSuperAdminSubscriptionsControllerCreateSubscriptionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Cancel the subscription for the specified organization. This endpoint is only accessible to super admins.
 * @summary Cancel the subscription for a specific organization
 */
export const superAdminSubscriptionsControllerCancelSubscription = (
    orgId: string,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/super-admin/subscriptions/${orgId}`, method: 'DELETE'
    },
      );
    }
  


export const getSuperAdminSubscriptionsControllerCancelSubscriptionMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminSubscriptionsControllerCancelSubscription>>, TError,{orgId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof superAdminSubscriptionsControllerCancelSubscription>>, TError,{orgId: string}, TContext> => {

const mutationKey = ['superAdminSubscriptionsControllerCancelSubscription'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof superAdminSubscriptionsControllerCancelSubscription>>, {orgId: string}> = (props) => {
          const {orgId} = props ?? {};

          return  superAdminSubscriptionsControllerCancelSubscription(orgId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuperAdminSubscriptionsControllerCancelSubscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof superAdminSubscriptionsControllerCancelSubscription>>>
    
    export type SuperAdminSubscriptionsControllerCancelSubscriptionMutationError = void

    /**
 * @summary Cancel the subscription for a specific organization
 */
export const useSuperAdminSubscriptionsControllerCancelSubscription = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminSubscriptionsControllerCancelSubscription>>, TError,{orgId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof superAdminSubscriptionsControllerCancelSubscription>>,
        TError,
        {orgId: string},
        TContext
      > => {

      const mutationOptions = getSuperAdminSubscriptionsControllerCancelSubscriptionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Update the number of seats for the specified organization. This endpoint is only accessible to super admins.
 * @summary Update the number of seats for a specific organization
 */
export const superAdminSubscriptionsControllerUpdateSeats = (
    orgId: string,
    updateSeatsDto: UpdateSeatsDto,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/super-admin/subscriptions/${orgId}/seats`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateSeatsDto
    },
      );
    }
  


export const getSuperAdminSubscriptionsControllerUpdateSeatsMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminSubscriptionsControllerUpdateSeats>>, TError,{orgId: string;data: UpdateSeatsDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof superAdminSubscriptionsControllerUpdateSeats>>, TError,{orgId: string;data: UpdateSeatsDto}, TContext> => {

const mutationKey = ['superAdminSubscriptionsControllerUpdateSeats'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof superAdminSubscriptionsControllerUpdateSeats>>, {orgId: string;data: UpdateSeatsDto}> = (props) => {
          const {orgId,data} = props ?? {};

          return  superAdminSubscriptionsControllerUpdateSeats(orgId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuperAdminSubscriptionsControllerUpdateSeatsMutationResult = NonNullable<Awaited<ReturnType<typeof superAdminSubscriptionsControllerUpdateSeats>>>
    export type SuperAdminSubscriptionsControllerUpdateSeatsMutationBody = UpdateSeatsDto
    export type SuperAdminSubscriptionsControllerUpdateSeatsMutationError = void

    /**
 * @summary Update the number of seats for a specific organization
 */
export const useSuperAdminSubscriptionsControllerUpdateSeats = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminSubscriptionsControllerUpdateSeats>>, TError,{orgId: string;data: UpdateSeatsDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof superAdminSubscriptionsControllerUpdateSeats>>,
        TError,
        {orgId: string;data: UpdateSeatsDto},
        TContext
      > => {

      const mutationOptions = getSuperAdminSubscriptionsControllerUpdateSeatsMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Update the billing information for the specified organization. This endpoint is only accessible to super admins.
 * @summary Update the billing information for a specific organization
 */
export const superAdminSubscriptionsControllerUpdateBillingInfo = (
    orgId: string,
    updateBillingInfoDto: UpdateBillingInfoDto,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/super-admin/subscriptions/${orgId}/billing-info`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateBillingInfoDto
    },
      );
    }
  


export const getSuperAdminSubscriptionsControllerUpdateBillingInfoMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminSubscriptionsControllerUpdateBillingInfo>>, TError,{orgId: string;data: UpdateBillingInfoDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof superAdminSubscriptionsControllerUpdateBillingInfo>>, TError,{orgId: string;data: UpdateBillingInfoDto}, TContext> => {

const mutationKey = ['superAdminSubscriptionsControllerUpdateBillingInfo'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof superAdminSubscriptionsControllerUpdateBillingInfo>>, {orgId: string;data: UpdateBillingInfoDto}> = (props) => {
          const {orgId,data} = props ?? {};

          return  superAdminSubscriptionsControllerUpdateBillingInfo(orgId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuperAdminSubscriptionsControllerUpdateBillingInfoMutationResult = NonNullable<Awaited<ReturnType<typeof superAdminSubscriptionsControllerUpdateBillingInfo>>>
    export type SuperAdminSubscriptionsControllerUpdateBillingInfoMutationBody = UpdateBillingInfoDto
    export type SuperAdminSubscriptionsControllerUpdateBillingInfoMutationError = void

    /**
 * @summary Update the billing information for a specific organization
 */
export const useSuperAdminSubscriptionsControllerUpdateBillingInfo = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminSubscriptionsControllerUpdateBillingInfo>>, TError,{orgId: string;data: UpdateBillingInfoDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof superAdminSubscriptionsControllerUpdateBillingInfo>>,
        TError,
        {orgId: string;data: UpdateBillingInfoDto},
        TContext
      > => {

      const mutationOptions = getSuperAdminSubscriptionsControllerUpdateBillingInfoMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Uncancel the subscription for the specified organization. This endpoint is only accessible to super admins.
 * @summary Uncancel the subscription for a specific organization
 */
export const superAdminSubscriptionsControllerUncancelSubscription = (
    orgId: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<void>(
      {url: `/super-admin/subscriptions/${orgId}/uncancel`, method: 'POST', signal
    },
      );
    }
  


export const getSuperAdminSubscriptionsControllerUncancelSubscriptionMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminSubscriptionsControllerUncancelSubscription>>, TError,{orgId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof superAdminSubscriptionsControllerUncancelSubscription>>, TError,{orgId: string}, TContext> => {

const mutationKey = ['superAdminSubscriptionsControllerUncancelSubscription'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof superAdminSubscriptionsControllerUncancelSubscription>>, {orgId: string}> = (props) => {
          const {orgId} = props ?? {};

          return  superAdminSubscriptionsControllerUncancelSubscription(orgId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuperAdminSubscriptionsControllerUncancelSubscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof superAdminSubscriptionsControllerUncancelSubscription>>>
    
    export type SuperAdminSubscriptionsControllerUncancelSubscriptionMutationError = void

    /**
 * @summary Uncancel the subscription for a specific organization
 */
export const useSuperAdminSubscriptionsControllerUncancelSubscription = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminSubscriptionsControllerUncancelSubscription>>, TError,{orgId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof superAdminSubscriptionsControllerUncancelSubscription>>,
        TError,
        {orgId: string},
        TContext
      > => {

      const mutationOptions = getSuperAdminSubscriptionsControllerUncancelSubscriptionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Generic file upload endpoint. Stores the file with optional metadata. Validation (file types, sizes) should be handled by consuming modules.
 * @summary Upload a file to object storage
 */
export const storageControllerUploadFile = (
    storageControllerUploadFileBody: StorageControllerUploadFileBody,
 signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`file`, storageControllerUploadFileBody.file)

      return customAxiosInstance<UploadFileResponseDto>(
      {url: `/storage/upload`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      );
    }
  


export const getStorageControllerUploadFileMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof storageControllerUploadFile>>, TError,{data: StorageControllerUploadFileBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof storageControllerUploadFile>>, TError,{data: StorageControllerUploadFileBody}, TContext> => {

const mutationKey = ['storageControllerUploadFile'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof storageControllerUploadFile>>, {data: StorageControllerUploadFileBody}> = (props) => {
          const {data} = props ?? {};

          return  storageControllerUploadFile(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type StorageControllerUploadFileMutationResult = NonNullable<Awaited<ReturnType<typeof storageControllerUploadFile>>>
    export type StorageControllerUploadFileMutationBody = StorageControllerUploadFileBody
    export type StorageControllerUploadFileMutationError = void

    /**
 * @summary Upload a file to object storage
 */
export const useStorageControllerUploadFile = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof storageControllerUploadFile>>, TError,{data: StorageControllerUploadFileBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof storageControllerUploadFile>>,
        TError,
        {data: StorageControllerUploadFileBody},
        TContext
      > => {

      const mutationOptions = getStorageControllerUploadFileMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const storageControllerGetFile = (
    objectName: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<void>(
      {url: `/storage/${objectName}`, method: 'GET', signal
    },
      );
    }
  

export const getStorageControllerGetFileQueryKey = (objectName: string,) => {
    return [`/storage/${objectName}`] as const;
    }

    
export const getStorageControllerGetFileQueryOptions = <TData = Awaited<ReturnType<typeof storageControllerGetFile>>, TError = unknown>(objectName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageControllerGetFile>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStorageControllerGetFileQueryKey(objectName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof storageControllerGetFile>>> = ({ signal }) => storageControllerGetFile(objectName, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(objectName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof storageControllerGetFile>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StorageControllerGetFileQueryResult = NonNullable<Awaited<ReturnType<typeof storageControllerGetFile>>>
export type StorageControllerGetFileQueryError = unknown


export function useStorageControllerGetFile<TData = Awaited<ReturnType<typeof storageControllerGetFile>>, TError = unknown>(
 objectName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageControllerGetFile>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof storageControllerGetFile>>,
          TError,
          Awaited<ReturnType<typeof storageControllerGetFile>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStorageControllerGetFile<TData = Awaited<ReturnType<typeof storageControllerGetFile>>, TError = unknown>(
 objectName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageControllerGetFile>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof storageControllerGetFile>>,
          TError,
          Awaited<ReturnType<typeof storageControllerGetFile>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStorageControllerGetFile<TData = Awaited<ReturnType<typeof storageControllerGetFile>>, TError = unknown>(
 objectName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageControllerGetFile>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useStorageControllerGetFile<TData = Awaited<ReturnType<typeof storageControllerGetFile>>, TError = unknown>(
 objectName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageControllerGetFile>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStorageControllerGetFileQueryOptions(objectName,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const storageControllerDeleteFile = (
    objectName: string,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/storage/${objectName}`, method: 'DELETE'
    },
      );
    }
  


export const getStorageControllerDeleteFileMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof storageControllerDeleteFile>>, TError,{objectName: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof storageControllerDeleteFile>>, TError,{objectName: string}, TContext> => {

const mutationKey = ['storageControllerDeleteFile'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof storageControllerDeleteFile>>, {objectName: string}> = (props) => {
          const {objectName} = props ?? {};

          return  storageControllerDeleteFile(objectName,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type StorageControllerDeleteFileMutationResult = NonNullable<Awaited<ReturnType<typeof storageControllerDeleteFile>>>
    
    export type StorageControllerDeleteFileMutationError = unknown

    export const useStorageControllerDeleteFile = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof storageControllerDeleteFile>>, TError,{objectName: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof storageControllerDeleteFile>>,
        TError,
        {objectName: string},
        TContext
      > => {

      const mutationOptions = getStorageControllerDeleteFileMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const storageControllerGetPresignedUrl = (
    objectName: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<void>(
      {url: `/storage/url/${objectName}`, method: 'GET', signal
    },
      );
    }
  

export const getStorageControllerGetPresignedUrlQueryKey = (objectName: string,) => {
    return [`/storage/url/${objectName}`] as const;
    }

    
export const getStorageControllerGetPresignedUrlQueryOptions = <TData = Awaited<ReturnType<typeof storageControllerGetPresignedUrl>>, TError = unknown>(objectName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageControllerGetPresignedUrl>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStorageControllerGetPresignedUrlQueryKey(objectName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof storageControllerGetPresignedUrl>>> = ({ signal }) => storageControllerGetPresignedUrl(objectName, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(objectName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof storageControllerGetPresignedUrl>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StorageControllerGetPresignedUrlQueryResult = NonNullable<Awaited<ReturnType<typeof storageControllerGetPresignedUrl>>>
export type StorageControllerGetPresignedUrlQueryError = unknown


export function useStorageControllerGetPresignedUrl<TData = Awaited<ReturnType<typeof storageControllerGetPresignedUrl>>, TError = unknown>(
 objectName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageControllerGetPresignedUrl>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof storageControllerGetPresignedUrl>>,
          TError,
          Awaited<ReturnType<typeof storageControllerGetPresignedUrl>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStorageControllerGetPresignedUrl<TData = Awaited<ReturnType<typeof storageControllerGetPresignedUrl>>, TError = unknown>(
 objectName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageControllerGetPresignedUrl>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof storageControllerGetPresignedUrl>>,
          TError,
          Awaited<ReturnType<typeof storageControllerGetPresignedUrl>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStorageControllerGetPresignedUrl<TData = Awaited<ReturnType<typeof storageControllerGetPresignedUrl>>, TError = unknown>(
 objectName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageControllerGetPresignedUrl>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useStorageControllerGetPresignedUrl<TData = Awaited<ReturnType<typeof storageControllerGetPresignedUrl>>, TError = unknown>(
 objectName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageControllerGetPresignedUrl>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStorageControllerGetPresignedUrlQueryOptions(objectName,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Retrieve content from a URL
 */
export const urlRetrieverControllerRetrieveUrl = (
    retrieveUrlDto: RetrieveUrlDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<void>(
      {url: `/retrievers/url`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: retrieveUrlDto, signal
    },
      );
    }
  


export const getUrlRetrieverControllerRetrieveUrlMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof urlRetrieverControllerRetrieveUrl>>, TError,{data: RetrieveUrlDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof urlRetrieverControllerRetrieveUrl>>, TError,{data: RetrieveUrlDto}, TContext> => {

const mutationKey = ['urlRetrieverControllerRetrieveUrl'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof urlRetrieverControllerRetrieveUrl>>, {data: RetrieveUrlDto}> = (props) => {
          const {data} = props ?? {};

          return  urlRetrieverControllerRetrieveUrl(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UrlRetrieverControllerRetrieveUrlMutationResult = NonNullable<Awaited<ReturnType<typeof urlRetrieverControllerRetrieveUrl>>>
    export type UrlRetrieverControllerRetrieveUrlMutationBody = RetrieveUrlDto
    export type UrlRetrieverControllerRetrieveUrlMutationError = unknown

    /**
 * @summary Retrieve content from a URL
 */
export const useUrlRetrieverControllerRetrieveUrl = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof urlRetrieverControllerRetrieveUrl>>, TError,{data: RetrieveUrlDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof urlRetrieverControllerRetrieveUrl>>,
        TError,
        {data: RetrieveUrlDto},
        TContext
      > => {

      const mutationOptions = getUrlRetrieverControllerRetrieveUrlMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Create a new thread
 */
export const threadsControllerCreate = (
    createThreadDto: CreateThreadDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<GetThreadResponseDto>(
      {url: `/threads`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createThreadDto, signal
    },
      );
    }
  


export const getThreadsControllerCreateMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof threadsControllerCreate>>, TError,{data: CreateThreadDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof threadsControllerCreate>>, TError,{data: CreateThreadDto}, TContext> => {

const mutationKey = ['threadsControllerCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof threadsControllerCreate>>, {data: CreateThreadDto}> = (props) => {
          const {data} = props ?? {};

          return  threadsControllerCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ThreadsControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof threadsControllerCreate>>>
    export type ThreadsControllerCreateMutationBody = CreateThreadDto
    export type ThreadsControllerCreateMutationError = void

    /**
 * @summary Create a new thread
 */
export const useThreadsControllerCreate = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof threadsControllerCreate>>, TError,{data: CreateThreadDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof threadsControllerCreate>>,
        TError,
        {data: CreateThreadDto},
        TContext
      > => {

      const mutationOptions = getThreadsControllerCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get all threads for the current user
 */
export const threadsControllerFindAll = (
    params?: ThreadsControllerFindAllParams,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<GetThreadsResponseDto>(
      {url: `/threads`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getThreadsControllerFindAllQueryKey = (params?: ThreadsControllerFindAllParams,) => {
    return [`/threads`, ...(params ? [params]: [])] as const;
    }

    
export const getThreadsControllerFindAllQueryOptions = <TData = Awaited<ReturnType<typeof threadsControllerFindAll>>, TError = void>(params?: ThreadsControllerFindAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof threadsControllerFindAll>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getThreadsControllerFindAllQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof threadsControllerFindAll>>> = ({ signal }) => threadsControllerFindAll(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof threadsControllerFindAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ThreadsControllerFindAllQueryResult = NonNullable<Awaited<ReturnType<typeof threadsControllerFindAll>>>
export type ThreadsControllerFindAllQueryError = void


export function useThreadsControllerFindAll<TData = Awaited<ReturnType<typeof threadsControllerFindAll>>, TError = void>(
 params: undefined |  ThreadsControllerFindAllParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof threadsControllerFindAll>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof threadsControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof threadsControllerFindAll>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useThreadsControllerFindAll<TData = Awaited<ReturnType<typeof threadsControllerFindAll>>, TError = void>(
 params?: ThreadsControllerFindAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof threadsControllerFindAll>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof threadsControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof threadsControllerFindAll>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useThreadsControllerFindAll<TData = Awaited<ReturnType<typeof threadsControllerFindAll>>, TError = void>(
 params?: ThreadsControllerFindAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof threadsControllerFindAll>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all threads for the current user
 */

export function useThreadsControllerFindAll<TData = Awaited<ReturnType<typeof threadsControllerFindAll>>, TError = void>(
 params?: ThreadsControllerFindAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof threadsControllerFindAll>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getThreadsControllerFindAllQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get a thread by ID
 */
export const threadsControllerFindOne = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<GetThreadResponseDto>(
      {url: `/threads/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getThreadsControllerFindOneQueryKey = (id: string,) => {
    return [`/threads/${id}`] as const;
    }

    
export const getThreadsControllerFindOneQueryOptions = <TData = Awaited<ReturnType<typeof threadsControllerFindOne>>, TError = void>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof threadsControllerFindOne>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getThreadsControllerFindOneQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof threadsControllerFindOne>>> = ({ signal }) => threadsControllerFindOne(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof threadsControllerFindOne>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ThreadsControllerFindOneQueryResult = NonNullable<Awaited<ReturnType<typeof threadsControllerFindOne>>>
export type ThreadsControllerFindOneQueryError = void


export function useThreadsControllerFindOne<TData = Awaited<ReturnType<typeof threadsControllerFindOne>>, TError = void>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof threadsControllerFindOne>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof threadsControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof threadsControllerFindOne>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useThreadsControllerFindOne<TData = Awaited<ReturnType<typeof threadsControllerFindOne>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof threadsControllerFindOne>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof threadsControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof threadsControllerFindOne>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useThreadsControllerFindOne<TData = Awaited<ReturnType<typeof threadsControllerFindOne>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof threadsControllerFindOne>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a thread by ID
 */

export function useThreadsControllerFindOne<TData = Awaited<ReturnType<typeof threadsControllerFindOne>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof threadsControllerFindOne>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getThreadsControllerFindOneQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Delete a thread
 */
export const threadsControllerDelete = (
    id: string,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/threads/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getThreadsControllerDeleteMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof threadsControllerDelete>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof threadsControllerDelete>>, TError,{id: string}, TContext> => {

const mutationKey = ['threadsControllerDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof threadsControllerDelete>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  threadsControllerDelete(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ThreadsControllerDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof threadsControllerDelete>>>
    
    export type ThreadsControllerDeleteMutationError = void

    /**
 * @summary Delete a thread
 */
export const useThreadsControllerDelete = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof threadsControllerDelete>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof threadsControllerDelete>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getThreadsControllerDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Update a thread title
 */
export const threadsControllerUpdateTitle = (
    id: string,
    updateThreadTitleDto: UpdateThreadTitleDto,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/threads/${id}/title`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateThreadTitleDto
    },
      );
    }
  


export const getThreadsControllerUpdateTitleMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof threadsControllerUpdateTitle>>, TError,{id: string;data: UpdateThreadTitleDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof threadsControllerUpdateTitle>>, TError,{id: string;data: UpdateThreadTitleDto}, TContext> => {

const mutationKey = ['threadsControllerUpdateTitle'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof threadsControllerUpdateTitle>>, {id: string;data: UpdateThreadTitleDto}> = (props) => {
          const {id,data} = props ?? {};

          return  threadsControllerUpdateTitle(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ThreadsControllerUpdateTitleMutationResult = NonNullable<Awaited<ReturnType<typeof threadsControllerUpdateTitle>>>
    export type ThreadsControllerUpdateTitleMutationBody = UpdateThreadTitleDto
    export type ThreadsControllerUpdateTitleMutationError = void

    /**
 * @summary Update a thread title
 */
export const useThreadsControllerUpdateTitle = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof threadsControllerUpdateTitle>>, TError,{id: string;data: UpdateThreadTitleDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof threadsControllerUpdateTitle>>,
        TError,
        {id: string;data: UpdateThreadTitleDto},
        TContext
      > => {

      const mutationOptions = getThreadsControllerUpdateTitleMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get all sources for a thread
 */
export const threadsControllerGetThreadSources = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<ThreadsControllerGetThreadSources200Item[]>(
      {url: `/threads/${id}/sources`, method: 'GET', signal
    },
      );
    }
  

export const getThreadsControllerGetThreadSourcesQueryKey = (id: string,) => {
    return [`/threads/${id}/sources`] as const;
    }

    
export const getThreadsControllerGetThreadSourcesQueryOptions = <TData = Awaited<ReturnType<typeof threadsControllerGetThreadSources>>, TError = void>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof threadsControllerGetThreadSources>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getThreadsControllerGetThreadSourcesQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof threadsControllerGetThreadSources>>> = ({ signal }) => threadsControllerGetThreadSources(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof threadsControllerGetThreadSources>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ThreadsControllerGetThreadSourcesQueryResult = NonNullable<Awaited<ReturnType<typeof threadsControllerGetThreadSources>>>
export type ThreadsControllerGetThreadSourcesQueryError = void


export function useThreadsControllerGetThreadSources<TData = Awaited<ReturnType<typeof threadsControllerGetThreadSources>>, TError = void>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof threadsControllerGetThreadSources>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof threadsControllerGetThreadSources>>,
          TError,
          Awaited<ReturnType<typeof threadsControllerGetThreadSources>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useThreadsControllerGetThreadSources<TData = Awaited<ReturnType<typeof threadsControllerGetThreadSources>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof threadsControllerGetThreadSources>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof threadsControllerGetThreadSources>>,
          TError,
          Awaited<ReturnType<typeof threadsControllerGetThreadSources>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useThreadsControllerGetThreadSources<TData = Awaited<ReturnType<typeof threadsControllerGetThreadSources>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof threadsControllerGetThreadSources>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all sources for a thread
 */

export function useThreadsControllerGetThreadSources<TData = Awaited<ReturnType<typeof threadsControllerGetThreadSources>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof threadsControllerGetThreadSources>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getThreadsControllerGetThreadSourcesQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Add a file source to a thread
 */
export const threadsControllerAddFileSource = (
    id: string,
    threadsControllerAddFileSourceBody: ThreadsControllerAddFileSourceBody,
 signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`file`, threadsControllerAddFileSourceBody.file)
if(threadsControllerAddFileSourceBody.name !== undefined) {
 formData.append(`name`, threadsControllerAddFileSourceBody.name)
 }
if(threadsControllerAddFileSourceBody.description !== undefined) {
 formData.append(`description`, threadsControllerAddFileSourceBody.description)
 }

      return customAxiosInstance<void>(
      {url: `/threads/${id}/sources/file`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      );
    }
  


export const getThreadsControllerAddFileSourceMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof threadsControllerAddFileSource>>, TError,{id: string;data: ThreadsControllerAddFileSourceBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof threadsControllerAddFileSource>>, TError,{id: string;data: ThreadsControllerAddFileSourceBody}, TContext> => {

const mutationKey = ['threadsControllerAddFileSource'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof threadsControllerAddFileSource>>, {id: string;data: ThreadsControllerAddFileSourceBody}> = (props) => {
          const {id,data} = props ?? {};

          return  threadsControllerAddFileSource(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ThreadsControllerAddFileSourceMutationResult = NonNullable<Awaited<ReturnType<typeof threadsControllerAddFileSource>>>
    export type ThreadsControllerAddFileSourceMutationBody = ThreadsControllerAddFileSourceBody
    export type ThreadsControllerAddFileSourceMutationError = unknown

    /**
 * @summary Add a file source to a thread
 */
export const useThreadsControllerAddFileSource = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof threadsControllerAddFileSource>>, TError,{id: string;data: ThreadsControllerAddFileSourceBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof threadsControllerAddFileSource>>,
        TError,
        {id: string;data: ThreadsControllerAddFileSourceBody},
        TContext
      > => {

      const mutationOptions = getThreadsControllerAddFileSourceMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Remove a source from a thread
 */
export const threadsControllerRemoveSource = (
    id: string,
    sourceId: string,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/threads/${id}/sources/${sourceId}`, method: 'DELETE'
    },
      );
    }
  


export const getThreadsControllerRemoveSourceMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof threadsControllerRemoveSource>>, TError,{id: string;sourceId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof threadsControllerRemoveSource>>, TError,{id: string;sourceId: string}, TContext> => {

const mutationKey = ['threadsControllerRemoveSource'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof threadsControllerRemoveSource>>, {id: string;sourceId: string}> = (props) => {
          const {id,sourceId} = props ?? {};

          return  threadsControllerRemoveSource(id,sourceId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ThreadsControllerRemoveSourceMutationResult = NonNullable<Awaited<ReturnType<typeof threadsControllerRemoveSource>>>
    
    export type ThreadsControllerRemoveSourceMutationError = void

    /**
 * @summary Remove a source from a thread
 */
export const useThreadsControllerRemoveSource = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof threadsControllerRemoveSource>>, TError,{id: string;sourceId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof threadsControllerRemoveSource>>,
        TError,
        {id: string;sourceId: string},
        TContext
      > => {

      const mutationOptions = getThreadsControllerRemoveSourceMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Download a data source as CSV
 */
export const threadsControllerDownloadSource = (
    id: string,
    sourceId: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<Blob>(
      {url: `/threads/${id}/sources/${sourceId}/download`, method: 'GET',
        responseType: 'blob', signal
    },
      );
    }
  

export const getThreadsControllerDownloadSourceQueryKey = (id: string,
    sourceId: string,) => {
    return [`/threads/${id}/sources/${sourceId}/download`] as const;
    }

    
export const getThreadsControllerDownloadSourceQueryOptions = <TData = Awaited<ReturnType<typeof threadsControllerDownloadSource>>, TError = void>(id: string,
    sourceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof threadsControllerDownloadSource>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getThreadsControllerDownloadSourceQueryKey(id,sourceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof threadsControllerDownloadSource>>> = ({ signal }) => threadsControllerDownloadSource(id,sourceId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id && sourceId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof threadsControllerDownloadSource>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ThreadsControllerDownloadSourceQueryResult = NonNullable<Awaited<ReturnType<typeof threadsControllerDownloadSource>>>
export type ThreadsControllerDownloadSourceQueryError = void


export function useThreadsControllerDownloadSource<TData = Awaited<ReturnType<typeof threadsControllerDownloadSource>>, TError = void>(
 id: string,
    sourceId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof threadsControllerDownloadSource>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof threadsControllerDownloadSource>>,
          TError,
          Awaited<ReturnType<typeof threadsControllerDownloadSource>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useThreadsControllerDownloadSource<TData = Awaited<ReturnType<typeof threadsControllerDownloadSource>>, TError = void>(
 id: string,
    sourceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof threadsControllerDownloadSource>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof threadsControllerDownloadSource>>,
          TError,
          Awaited<ReturnType<typeof threadsControllerDownloadSource>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useThreadsControllerDownloadSource<TData = Awaited<ReturnType<typeof threadsControllerDownloadSource>>, TError = void>(
 id: string,
    sourceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof threadsControllerDownloadSource>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Download a data source as CSV
 */

export function useThreadsControllerDownloadSource<TData = Awaited<ReturnType<typeof threadsControllerDownloadSource>>, TError = void>(
 id: string,
    sourceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof threadsControllerDownloadSource>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getThreadsControllerDownloadSourceQueryOptions(id,sourceId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Install an agent from the marketplace
 */
export const agentsControllerInstallFromMarketplace = (
    installAgentFromMarketplaceDto: InstallAgentFromMarketplaceDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<AgentResponseDto>(
      {url: `/agents/install-from-marketplace`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: installAgentFromMarketplaceDto, signal
    },
      );
    }
  


export const getAgentsControllerInstallFromMarketplaceMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof agentsControllerInstallFromMarketplace>>, TError,{data: InstallAgentFromMarketplaceDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof agentsControllerInstallFromMarketplace>>, TError,{data: InstallAgentFromMarketplaceDto}, TContext> => {

const mutationKey = ['agentsControllerInstallFromMarketplace'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof agentsControllerInstallFromMarketplace>>, {data: InstallAgentFromMarketplaceDto}> = (props) => {
          const {data} = props ?? {};

          return  agentsControllerInstallFromMarketplace(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AgentsControllerInstallFromMarketplaceMutationResult = NonNullable<Awaited<ReturnType<typeof agentsControllerInstallFromMarketplace>>>
    export type AgentsControllerInstallFromMarketplaceMutationBody = InstallAgentFromMarketplaceDto
    export type AgentsControllerInstallFromMarketplaceMutationError = void

    /**
 * @summary Install an agent from the marketplace
 */
export const useAgentsControllerInstallFromMarketplace = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof agentsControllerInstallFromMarketplace>>, TError,{data: InstallAgentFromMarketplaceDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof agentsControllerInstallFromMarketplace>>,
        TError,
        {data: InstallAgentFromMarketplaceDto},
        TContext
      > => {

      const mutationOptions = getAgentsControllerInstallFromMarketplaceMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Create a new agent
 */
export const agentsControllerCreate = (
    createAgentDto: CreateAgentDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<AgentResponseDto>(
      {url: `/agents`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createAgentDto, signal
    },
      );
    }
  


export const getAgentsControllerCreateMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof agentsControllerCreate>>, TError,{data: CreateAgentDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof agentsControllerCreate>>, TError,{data: CreateAgentDto}, TContext> => {

const mutationKey = ['agentsControllerCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof agentsControllerCreate>>, {data: CreateAgentDto}> = (props) => {
          const {data} = props ?? {};

          return  agentsControllerCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AgentsControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof agentsControllerCreate>>>
    export type AgentsControllerCreateMutationBody = CreateAgentDto
    export type AgentsControllerCreateMutationError = void

    /**
 * @summary Create a new agent
 */
export const useAgentsControllerCreate = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof agentsControllerCreate>>, TError,{data: CreateAgentDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof agentsControllerCreate>>,
        TError,
        {data: CreateAgentDto},
        TContext
      > => {

      const mutationOptions = getAgentsControllerCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get all agents for the current user
 */
export const agentsControllerFindAll = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<AgentResponseDto[]>(
      {url: `/agents`, method: 'GET', signal
    },
      );
    }
  

export const getAgentsControllerFindAllQueryKey = () => {
    return [`/agents`] as const;
    }

    
export const getAgentsControllerFindAllQueryOptions = <TData = Awaited<ReturnType<typeof agentsControllerFindAll>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof agentsControllerFindAll>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAgentsControllerFindAllQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof agentsControllerFindAll>>> = ({ signal }) => agentsControllerFindAll(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof agentsControllerFindAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AgentsControllerFindAllQueryResult = NonNullable<Awaited<ReturnType<typeof agentsControllerFindAll>>>
export type AgentsControllerFindAllQueryError = void


export function useAgentsControllerFindAll<TData = Awaited<ReturnType<typeof agentsControllerFindAll>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof agentsControllerFindAll>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof agentsControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof agentsControllerFindAll>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAgentsControllerFindAll<TData = Awaited<ReturnType<typeof agentsControllerFindAll>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof agentsControllerFindAll>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof agentsControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof agentsControllerFindAll>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAgentsControllerFindAll<TData = Awaited<ReturnType<typeof agentsControllerFindAll>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof agentsControllerFindAll>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all agents for the current user
 */

export function useAgentsControllerFindAll<TData = Awaited<ReturnType<typeof agentsControllerFindAll>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof agentsControllerFindAll>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAgentsControllerFindAllQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get an agent by ID
 */
export const agentsControllerFindOne = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<AgentResponseDto>(
      {url: `/agents/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getAgentsControllerFindOneQueryKey = (id: string,) => {
    return [`/agents/${id}`] as const;
    }

    
export const getAgentsControllerFindOneQueryOptions = <TData = Awaited<ReturnType<typeof agentsControllerFindOne>>, TError = void>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof agentsControllerFindOne>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAgentsControllerFindOneQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof agentsControllerFindOne>>> = ({ signal }) => agentsControllerFindOne(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof agentsControllerFindOne>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AgentsControllerFindOneQueryResult = NonNullable<Awaited<ReturnType<typeof agentsControllerFindOne>>>
export type AgentsControllerFindOneQueryError = void


export function useAgentsControllerFindOne<TData = Awaited<ReturnType<typeof agentsControllerFindOne>>, TError = void>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof agentsControllerFindOne>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof agentsControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof agentsControllerFindOne>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAgentsControllerFindOne<TData = Awaited<ReturnType<typeof agentsControllerFindOne>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof agentsControllerFindOne>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof agentsControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof agentsControllerFindOne>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAgentsControllerFindOne<TData = Awaited<ReturnType<typeof agentsControllerFindOne>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof agentsControllerFindOne>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get an agent by ID
 */

export function useAgentsControllerFindOne<TData = Awaited<ReturnType<typeof agentsControllerFindOne>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof agentsControllerFindOne>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAgentsControllerFindOneQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update an agent
 */
export const agentsControllerUpdate = (
    id: string,
    updateAgentDto: UpdateAgentDto,
 ) => {
      
      
      return customAxiosInstance<AgentResponseDto>(
      {url: `/agents/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateAgentDto
    },
      );
    }
  


export const getAgentsControllerUpdateMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof agentsControllerUpdate>>, TError,{id: string;data: UpdateAgentDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof agentsControllerUpdate>>, TError,{id: string;data: UpdateAgentDto}, TContext> => {

const mutationKey = ['agentsControllerUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof agentsControllerUpdate>>, {id: string;data: UpdateAgentDto}> = (props) => {
          const {id,data} = props ?? {};

          return  agentsControllerUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AgentsControllerUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof agentsControllerUpdate>>>
    export type AgentsControllerUpdateMutationBody = UpdateAgentDto
    export type AgentsControllerUpdateMutationError = void

    /**
 * @summary Update an agent
 */
export const useAgentsControllerUpdate = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof agentsControllerUpdate>>, TError,{id: string;data: UpdateAgentDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof agentsControllerUpdate>>,
        TError,
        {id: string;data: UpdateAgentDto},
        TContext
      > => {

      const mutationOptions = getAgentsControllerUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Delete an agent
 */
export const agentsControllerDelete = (
    id: string,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/agents/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getAgentsControllerDeleteMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof agentsControllerDelete>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof agentsControllerDelete>>, TError,{id: string}, TContext> => {

const mutationKey = ['agentsControllerDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof agentsControllerDelete>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  agentsControllerDelete(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AgentsControllerDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof agentsControllerDelete>>>
    
    export type AgentsControllerDeleteMutationError = void

    /**
 * @summary Delete an agent
 */
export const useAgentsControllerDelete = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof agentsControllerDelete>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof agentsControllerDelete>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getAgentsControllerDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get all sources for an agent
 */
export const agentsControllerGetAgentSources = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<AgentSourceResponseDto[]>(
      {url: `/agents/${id}/sources`, method: 'GET', signal
    },
      );
    }
  

export const getAgentsControllerGetAgentSourcesQueryKey = (id: string,) => {
    return [`/agents/${id}/sources`] as const;
    }

    
export const getAgentsControllerGetAgentSourcesQueryOptions = <TData = Awaited<ReturnType<typeof agentsControllerGetAgentSources>>, TError = void>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof agentsControllerGetAgentSources>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAgentsControllerGetAgentSourcesQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof agentsControllerGetAgentSources>>> = ({ signal }) => agentsControllerGetAgentSources(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof agentsControllerGetAgentSources>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AgentsControllerGetAgentSourcesQueryResult = NonNullable<Awaited<ReturnType<typeof agentsControllerGetAgentSources>>>
export type AgentsControllerGetAgentSourcesQueryError = void


export function useAgentsControllerGetAgentSources<TData = Awaited<ReturnType<typeof agentsControllerGetAgentSources>>, TError = void>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof agentsControllerGetAgentSources>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof agentsControllerGetAgentSources>>,
          TError,
          Awaited<ReturnType<typeof agentsControllerGetAgentSources>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAgentsControllerGetAgentSources<TData = Awaited<ReturnType<typeof agentsControllerGetAgentSources>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof agentsControllerGetAgentSources>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof agentsControllerGetAgentSources>>,
          TError,
          Awaited<ReturnType<typeof agentsControllerGetAgentSources>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAgentsControllerGetAgentSources<TData = Awaited<ReturnType<typeof agentsControllerGetAgentSources>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof agentsControllerGetAgentSources>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all sources for an agent
 */

export function useAgentsControllerGetAgentSources<TData = Awaited<ReturnType<typeof agentsControllerGetAgentSources>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof agentsControllerGetAgentSources>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAgentsControllerGetAgentSourcesQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Add a file source to an agent
 */
export const agentsControllerAddFileSource = (
    id: string,
    agentsControllerAddFileSourceBody: AgentsControllerAddFileSourceBody,
 signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`file`, agentsControllerAddFileSourceBody.file)

      return customAxiosInstance<void>(
      {url: `/agents/${id}/sources/file`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      );
    }
  


export const getAgentsControllerAddFileSourceMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof agentsControllerAddFileSource>>, TError,{id: string;data: AgentsControllerAddFileSourceBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof agentsControllerAddFileSource>>, TError,{id: string;data: AgentsControllerAddFileSourceBody}, TContext> => {

const mutationKey = ['agentsControllerAddFileSource'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof agentsControllerAddFileSource>>, {id: string;data: AgentsControllerAddFileSourceBody}> = (props) => {
          const {id,data} = props ?? {};

          return  agentsControllerAddFileSource(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AgentsControllerAddFileSourceMutationResult = NonNullable<Awaited<ReturnType<typeof agentsControllerAddFileSource>>>
    export type AgentsControllerAddFileSourceMutationBody = AgentsControllerAddFileSourceBody
    export type AgentsControllerAddFileSourceMutationError = void

    /**
 * @summary Add a file source to an agent
 */
export const useAgentsControllerAddFileSource = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof agentsControllerAddFileSource>>, TError,{id: string;data: AgentsControllerAddFileSourceBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof agentsControllerAddFileSource>>,
        TError,
        {id: string;data: AgentsControllerAddFileSourceBody},
        TContext
      > => {

      const mutationOptions = getAgentsControllerAddFileSourceMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Remove a source from an agent
 */
export const agentsControllerRemoveSource = (
    id: string,
    sourceAssignmentId: string,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/agents/${id}/sources/${sourceAssignmentId}`, method: 'DELETE'
    },
      );
    }
  


export const getAgentsControllerRemoveSourceMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof agentsControllerRemoveSource>>, TError,{id: string;sourceAssignmentId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof agentsControllerRemoveSource>>, TError,{id: string;sourceAssignmentId: string}, TContext> => {

const mutationKey = ['agentsControllerRemoveSource'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof agentsControllerRemoveSource>>, {id: string;sourceAssignmentId: string}> = (props) => {
          const {id,sourceAssignmentId} = props ?? {};

          return  agentsControllerRemoveSource(id,sourceAssignmentId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AgentsControllerRemoveSourceMutationResult = NonNullable<Awaited<ReturnType<typeof agentsControllerRemoveSource>>>
    
    export type AgentsControllerRemoveSourceMutationError = void

    /**
 * @summary Remove a source from an agent
 */
export const useAgentsControllerRemoveSource = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof agentsControllerRemoveSource>>, TError,{id: string;sourceAssignmentId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof agentsControllerRemoveSource>>,
        TError,
        {id: string;sourceAssignmentId: string},
        TContext
      > => {

      const mutationOptions = getAgentsControllerRemoveSourceMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Assign MCP integration to agent
 */
export const agentsControllerAssignMcpIntegration = (
    agentId: string,
    integrationId: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<AgentResponseDto>(
      {url: `/agents/${agentId}/mcp-integrations/${integrationId}`, method: 'POST', signal
    },
      );
    }
  


export const getAgentsControllerAssignMcpIntegrationMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof agentsControllerAssignMcpIntegration>>, TError,{agentId: string;integrationId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof agentsControllerAssignMcpIntegration>>, TError,{agentId: string;integrationId: string}, TContext> => {

const mutationKey = ['agentsControllerAssignMcpIntegration'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof agentsControllerAssignMcpIntegration>>, {agentId: string;integrationId: string}> = (props) => {
          const {agentId,integrationId} = props ?? {};

          return  agentsControllerAssignMcpIntegration(agentId,integrationId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AgentsControllerAssignMcpIntegrationMutationResult = NonNullable<Awaited<ReturnType<typeof agentsControllerAssignMcpIntegration>>>
    
    export type AgentsControllerAssignMcpIntegrationMutationError = void

    /**
 * @summary Assign MCP integration to agent
 */
export const useAgentsControllerAssignMcpIntegration = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof agentsControllerAssignMcpIntegration>>, TError,{agentId: string;integrationId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof agentsControllerAssignMcpIntegration>>,
        TError,
        {agentId: string;integrationId: string},
        TContext
      > => {

      const mutationOptions = getAgentsControllerAssignMcpIntegrationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Unassign MCP integration from agent
 */
export const agentsControllerUnassignMcpIntegration = (
    agentId: string,
    integrationId: string,
 ) => {
      
      
      return customAxiosInstance<AgentResponseDto>(
      {url: `/agents/${agentId}/mcp-integrations/${integrationId}`, method: 'DELETE'
    },
      );
    }
  


export const getAgentsControllerUnassignMcpIntegrationMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof agentsControllerUnassignMcpIntegration>>, TError,{agentId: string;integrationId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof agentsControllerUnassignMcpIntegration>>, TError,{agentId: string;integrationId: string}, TContext> => {

const mutationKey = ['agentsControllerUnassignMcpIntegration'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof agentsControllerUnassignMcpIntegration>>, {agentId: string;integrationId: string}> = (props) => {
          const {agentId,integrationId} = props ?? {};

          return  agentsControllerUnassignMcpIntegration(agentId,integrationId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AgentsControllerUnassignMcpIntegrationMutationResult = NonNullable<Awaited<ReturnType<typeof agentsControllerUnassignMcpIntegration>>>
    
    export type AgentsControllerUnassignMcpIntegrationMutationError = void

    /**
 * @summary Unassign MCP integration from agent
 */
export const useAgentsControllerUnassignMcpIntegration = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof agentsControllerUnassignMcpIntegration>>, TError,{agentId: string;integrationId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof agentsControllerUnassignMcpIntegration>>,
        TError,
        {agentId: string;integrationId: string},
        TContext
      > => {

      const mutationOptions = getAgentsControllerUnassignMcpIntegrationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary List MCP integrations assigned to agent
 */
export const agentsControllerListAgentMcpIntegrations = (
    agentId: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<McpIntegrationResponseDto[]>(
      {url: `/agents/${agentId}/mcp-integrations`, method: 'GET', signal
    },
      );
    }
  

export const getAgentsControllerListAgentMcpIntegrationsQueryKey = (agentId: string,) => {
    return [`/agents/${agentId}/mcp-integrations`] as const;
    }

    
export const getAgentsControllerListAgentMcpIntegrationsQueryOptions = <TData = Awaited<ReturnType<typeof agentsControllerListAgentMcpIntegrations>>, TError = void>(agentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof agentsControllerListAgentMcpIntegrations>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAgentsControllerListAgentMcpIntegrationsQueryKey(agentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof agentsControllerListAgentMcpIntegrations>>> = ({ signal }) => agentsControllerListAgentMcpIntegrations(agentId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(agentId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof agentsControllerListAgentMcpIntegrations>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AgentsControllerListAgentMcpIntegrationsQueryResult = NonNullable<Awaited<ReturnType<typeof agentsControllerListAgentMcpIntegrations>>>
export type AgentsControllerListAgentMcpIntegrationsQueryError = void


export function useAgentsControllerListAgentMcpIntegrations<TData = Awaited<ReturnType<typeof agentsControllerListAgentMcpIntegrations>>, TError = void>(
 agentId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof agentsControllerListAgentMcpIntegrations>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof agentsControllerListAgentMcpIntegrations>>,
          TError,
          Awaited<ReturnType<typeof agentsControllerListAgentMcpIntegrations>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAgentsControllerListAgentMcpIntegrations<TData = Awaited<ReturnType<typeof agentsControllerListAgentMcpIntegrations>>, TError = void>(
 agentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof agentsControllerListAgentMcpIntegrations>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof agentsControllerListAgentMcpIntegrations>>,
          TError,
          Awaited<ReturnType<typeof agentsControllerListAgentMcpIntegrations>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAgentsControllerListAgentMcpIntegrations<TData = Awaited<ReturnType<typeof agentsControllerListAgentMcpIntegrations>>, TError = void>(
 agentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof agentsControllerListAgentMcpIntegrations>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List MCP integrations assigned to agent
 */

export function useAgentsControllerListAgentMcpIntegrations<TData = Awaited<ReturnType<typeof agentsControllerListAgentMcpIntegrations>>, TError = void>(
 agentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof agentsControllerListAgentMcpIntegrations>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAgentsControllerListAgentMcpIntegrationsQueryOptions(agentId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a share for an agent
 */
export const sharesControllerCreateShare = (
    createAgentShareDto: CreateAgentShareDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<ShareResponseDto>(
      {url: `/shares`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createAgentShareDto, signal
    },
      );
    }
  


export const getSharesControllerCreateShareMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sharesControllerCreateShare>>, TError,{data: CreateAgentShareDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof sharesControllerCreateShare>>, TError,{data: CreateAgentShareDto}, TContext> => {

const mutationKey = ['sharesControllerCreateShare'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sharesControllerCreateShare>>, {data: CreateAgentShareDto}> = (props) => {
          const {data} = props ?? {};

          return  sharesControllerCreateShare(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SharesControllerCreateShareMutationResult = NonNullable<Awaited<ReturnType<typeof sharesControllerCreateShare>>>
    export type SharesControllerCreateShareMutationBody = CreateAgentShareDto
    export type SharesControllerCreateShareMutationError = void

    /**
 * @summary Create a share for an agent
 */
export const useSharesControllerCreateShare = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sharesControllerCreateShare>>, TError,{data: CreateAgentShareDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sharesControllerCreateShare>>,
        TError,
        {data: CreateAgentShareDto},
        TContext
      > => {

      const mutationOptions = getSharesControllerCreateShareMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get shares for an entity
 */
export const sharesControllerGetShares = (
    params: SharesControllerGetSharesParams,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<ShareResponseDto[]>(
      {url: `/shares`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getSharesControllerGetSharesQueryKey = (params: SharesControllerGetSharesParams,) => {
    return [`/shares`, ...(params ? [params]: [])] as const;
    }

    
export const getSharesControllerGetSharesQueryOptions = <TData = Awaited<ReturnType<typeof sharesControllerGetShares>>, TError = void>(params: SharesControllerGetSharesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sharesControllerGetShares>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSharesControllerGetSharesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof sharesControllerGetShares>>> = ({ signal }) => sharesControllerGetShares(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof sharesControllerGetShares>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SharesControllerGetSharesQueryResult = NonNullable<Awaited<ReturnType<typeof sharesControllerGetShares>>>
export type SharesControllerGetSharesQueryError = void


export function useSharesControllerGetShares<TData = Awaited<ReturnType<typeof sharesControllerGetShares>>, TError = void>(
 params: SharesControllerGetSharesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof sharesControllerGetShares>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sharesControllerGetShares>>,
          TError,
          Awaited<ReturnType<typeof sharesControllerGetShares>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSharesControllerGetShares<TData = Awaited<ReturnType<typeof sharesControllerGetShares>>, TError = void>(
 params: SharesControllerGetSharesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sharesControllerGetShares>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sharesControllerGetShares>>,
          TError,
          Awaited<ReturnType<typeof sharesControllerGetShares>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSharesControllerGetShares<TData = Awaited<ReturnType<typeof sharesControllerGetShares>>, TError = void>(
 params: SharesControllerGetSharesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sharesControllerGetShares>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get shares for an entity
 */

export function useSharesControllerGetShares<TData = Awaited<ReturnType<typeof sharesControllerGetShares>>, TError = void>(
 params: SharesControllerGetSharesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sharesControllerGetShares>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSharesControllerGetSharesQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Delete a share
 */
export const sharesControllerDeleteShare = (
    id: string,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/shares/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getSharesControllerDeleteShareMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sharesControllerDeleteShare>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof sharesControllerDeleteShare>>, TError,{id: string}, TContext> => {

const mutationKey = ['sharesControllerDeleteShare'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sharesControllerDeleteShare>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  sharesControllerDeleteShare(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SharesControllerDeleteShareMutationResult = NonNullable<Awaited<ReturnType<typeof sharesControllerDeleteShare>>>
    
    export type SharesControllerDeleteShareMutationError = void

    /**
 * @summary Delete a share
 */
export const useSharesControllerDeleteShare = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sharesControllerDeleteShare>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sharesControllerDeleteShare>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getSharesControllerDeleteShareMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Preview a marketplace agent before installation
 */
export const marketplaceControllerGetAgent = (
    identifier: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<MarketplaceAgentResponseDto>(
      {url: `/marketplace/agents/${identifier}`, method: 'GET', signal
    },
      );
    }
  

export const getMarketplaceControllerGetAgentQueryKey = (identifier: string,) => {
    return [`/marketplace/agents/${identifier}`] as const;
    }

    
export const getMarketplaceControllerGetAgentQueryOptions = <TData = Awaited<ReturnType<typeof marketplaceControllerGetAgent>>, TError = void>(identifier: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof marketplaceControllerGetAgent>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMarketplaceControllerGetAgentQueryKey(identifier);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof marketplaceControllerGetAgent>>> = ({ signal }) => marketplaceControllerGetAgent(identifier, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(identifier), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof marketplaceControllerGetAgent>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type MarketplaceControllerGetAgentQueryResult = NonNullable<Awaited<ReturnType<typeof marketplaceControllerGetAgent>>>
export type MarketplaceControllerGetAgentQueryError = void


export function useMarketplaceControllerGetAgent<TData = Awaited<ReturnType<typeof marketplaceControllerGetAgent>>, TError = void>(
 identifier: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof marketplaceControllerGetAgent>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof marketplaceControllerGetAgent>>,
          TError,
          Awaited<ReturnType<typeof marketplaceControllerGetAgent>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMarketplaceControllerGetAgent<TData = Awaited<ReturnType<typeof marketplaceControllerGetAgent>>, TError = void>(
 identifier: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof marketplaceControllerGetAgent>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof marketplaceControllerGetAgent>>,
          TError,
          Awaited<ReturnType<typeof marketplaceControllerGetAgent>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMarketplaceControllerGetAgent<TData = Awaited<ReturnType<typeof marketplaceControllerGetAgent>>, TError = void>(
 identifier: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof marketplaceControllerGetAgent>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Preview a marketplace agent before installation
 */

export function useMarketplaceControllerGetAgent<TData = Awaited<ReturnType<typeof marketplaceControllerGetAgent>>, TError = void>(
 identifier: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof marketplaceControllerGetAgent>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getMarketplaceControllerGetAgentQueryOptions(identifier,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a new predefined MCP integration
 */
export const mcpIntegrationsControllerCreatePredefined = (
    createPredefinedIntegrationDto: CreatePredefinedIntegrationDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<McpIntegrationResponseDto>(
      {url: `/mcp-integrations/predefined`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createPredefinedIntegrationDto, signal
    },
      );
    }
  


export const getMcpIntegrationsControllerCreatePredefinedMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerCreatePredefined>>, TError,{data: CreatePredefinedIntegrationDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerCreatePredefined>>, TError,{data: CreatePredefinedIntegrationDto}, TContext> => {

const mutationKey = ['mcpIntegrationsControllerCreatePredefined'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof mcpIntegrationsControllerCreatePredefined>>, {data: CreatePredefinedIntegrationDto}> = (props) => {
          const {data} = props ?? {};

          return  mcpIntegrationsControllerCreatePredefined(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type McpIntegrationsControllerCreatePredefinedMutationResult = NonNullable<Awaited<ReturnType<typeof mcpIntegrationsControllerCreatePredefined>>>
    export type McpIntegrationsControllerCreatePredefinedMutationBody = CreatePredefinedIntegrationDto
    export type McpIntegrationsControllerCreatePredefinedMutationError = void

    /**
 * @summary Create a new predefined MCP integration
 */
export const useMcpIntegrationsControllerCreatePredefined = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerCreatePredefined>>, TError,{data: CreatePredefinedIntegrationDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof mcpIntegrationsControllerCreatePredefined>>,
        TError,
        {data: CreatePredefinedIntegrationDto},
        TContext
      > => {

      const mutationOptions = getMcpIntegrationsControllerCreatePredefinedMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Create a new custom MCP integration
 */
export const mcpIntegrationsControllerCreateCustom = (
    createCustomIntegrationDto: CreateCustomIntegrationDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<McpIntegrationResponseDto>(
      {url: `/mcp-integrations/custom`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createCustomIntegrationDto, signal
    },
      );
    }
  


export const getMcpIntegrationsControllerCreateCustomMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerCreateCustom>>, TError,{data: CreateCustomIntegrationDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerCreateCustom>>, TError,{data: CreateCustomIntegrationDto}, TContext> => {

const mutationKey = ['mcpIntegrationsControllerCreateCustom'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof mcpIntegrationsControllerCreateCustom>>, {data: CreateCustomIntegrationDto}> = (props) => {
          const {data} = props ?? {};

          return  mcpIntegrationsControllerCreateCustom(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type McpIntegrationsControllerCreateCustomMutationResult = NonNullable<Awaited<ReturnType<typeof mcpIntegrationsControllerCreateCustom>>>
    export type McpIntegrationsControllerCreateCustomMutationBody = CreateCustomIntegrationDto
    export type McpIntegrationsControllerCreateCustomMutationError = void

    /**
 * @summary Create a new custom MCP integration
 */
export const useMcpIntegrationsControllerCreateCustom = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerCreateCustom>>, TError,{data: CreateCustomIntegrationDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof mcpIntegrationsControllerCreateCustom>>,
        TError,
        {data: CreateCustomIntegrationDto},
        TContext
      > => {

      const mutationOptions = getMcpIntegrationsControllerCreateCustomMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary List all MCP integrations for organization
 */
export const mcpIntegrationsControllerList = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<McpIntegrationResponseDto[]>(
      {url: `/mcp-integrations`, method: 'GET', signal
    },
      );
    }
  

export const getMcpIntegrationsControllerListQueryKey = () => {
    return [`/mcp-integrations`] as const;
    }

    
export const getMcpIntegrationsControllerListQueryOptions = <TData = Awaited<ReturnType<typeof mcpIntegrationsControllerList>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMcpIntegrationsControllerListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof mcpIntegrationsControllerList>>> = ({ signal }) => mcpIntegrationsControllerList(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type McpIntegrationsControllerListQueryResult = NonNullable<Awaited<ReturnType<typeof mcpIntegrationsControllerList>>>
export type McpIntegrationsControllerListQueryError = unknown


export function useMcpIntegrationsControllerList<TData = Awaited<ReturnType<typeof mcpIntegrationsControllerList>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof mcpIntegrationsControllerList>>,
          TError,
          Awaited<ReturnType<typeof mcpIntegrationsControllerList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMcpIntegrationsControllerList<TData = Awaited<ReturnType<typeof mcpIntegrationsControllerList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof mcpIntegrationsControllerList>>,
          TError,
          Awaited<ReturnType<typeof mcpIntegrationsControllerList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMcpIntegrationsControllerList<TData = Awaited<ReturnType<typeof mcpIntegrationsControllerList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List all MCP integrations for organization
 */

export function useMcpIntegrationsControllerList<TData = Awaited<ReturnType<typeof mcpIntegrationsControllerList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getMcpIntegrationsControllerListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary List available predefined MCP integration configurations
 */
export const mcpIntegrationsControllerListPredefinedConfigs = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<PredefinedConfigResponseDto[]>(
      {url: `/mcp-integrations/predefined/available`, method: 'GET', signal
    },
      );
    }
  

export const getMcpIntegrationsControllerListPredefinedConfigsQueryKey = () => {
    return [`/mcp-integrations/predefined/available`] as const;
    }

    
export const getMcpIntegrationsControllerListPredefinedConfigsQueryOptions = <TData = Awaited<ReturnType<typeof mcpIntegrationsControllerListPredefinedConfigs>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerListPredefinedConfigs>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMcpIntegrationsControllerListPredefinedConfigsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof mcpIntegrationsControllerListPredefinedConfigs>>> = ({ signal }) => mcpIntegrationsControllerListPredefinedConfigs(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerListPredefinedConfigs>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type McpIntegrationsControllerListPredefinedConfigsQueryResult = NonNullable<Awaited<ReturnType<typeof mcpIntegrationsControllerListPredefinedConfigs>>>
export type McpIntegrationsControllerListPredefinedConfigsQueryError = unknown


export function useMcpIntegrationsControllerListPredefinedConfigs<TData = Awaited<ReturnType<typeof mcpIntegrationsControllerListPredefinedConfigs>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerListPredefinedConfigs>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof mcpIntegrationsControllerListPredefinedConfigs>>,
          TError,
          Awaited<ReturnType<typeof mcpIntegrationsControllerListPredefinedConfigs>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMcpIntegrationsControllerListPredefinedConfigs<TData = Awaited<ReturnType<typeof mcpIntegrationsControllerListPredefinedConfigs>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerListPredefinedConfigs>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof mcpIntegrationsControllerListPredefinedConfigs>>,
          TError,
          Awaited<ReturnType<typeof mcpIntegrationsControllerListPredefinedConfigs>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMcpIntegrationsControllerListPredefinedConfigs<TData = Awaited<ReturnType<typeof mcpIntegrationsControllerListPredefinedConfigs>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerListPredefinedConfigs>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List available predefined MCP integration configurations
 */

export function useMcpIntegrationsControllerListPredefinedConfigs<TData = Awaited<ReturnType<typeof mcpIntegrationsControllerListPredefinedConfigs>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerListPredefinedConfigs>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getMcpIntegrationsControllerListPredefinedConfigsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary List all available (enabled) MCP integrations for organization
 */
export const mcpIntegrationsControllerListAvailable = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<McpIntegrationResponseDto[]>(
      {url: `/mcp-integrations/available`, method: 'GET', signal
    },
      );
    }
  

export const getMcpIntegrationsControllerListAvailableQueryKey = () => {
    return [`/mcp-integrations/available`] as const;
    }

    
export const getMcpIntegrationsControllerListAvailableQueryOptions = <TData = Awaited<ReturnType<typeof mcpIntegrationsControllerListAvailable>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerListAvailable>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMcpIntegrationsControllerListAvailableQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof mcpIntegrationsControllerListAvailable>>> = ({ signal }) => mcpIntegrationsControllerListAvailable(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerListAvailable>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type McpIntegrationsControllerListAvailableQueryResult = NonNullable<Awaited<ReturnType<typeof mcpIntegrationsControllerListAvailable>>>
export type McpIntegrationsControllerListAvailableQueryError = unknown


export function useMcpIntegrationsControllerListAvailable<TData = Awaited<ReturnType<typeof mcpIntegrationsControllerListAvailable>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerListAvailable>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof mcpIntegrationsControllerListAvailable>>,
          TError,
          Awaited<ReturnType<typeof mcpIntegrationsControllerListAvailable>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMcpIntegrationsControllerListAvailable<TData = Awaited<ReturnType<typeof mcpIntegrationsControllerListAvailable>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerListAvailable>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof mcpIntegrationsControllerListAvailable>>,
          TError,
          Awaited<ReturnType<typeof mcpIntegrationsControllerListAvailable>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMcpIntegrationsControllerListAvailable<TData = Awaited<ReturnType<typeof mcpIntegrationsControllerListAvailable>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerListAvailable>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List all available (enabled) MCP integrations for organization
 */

export function useMcpIntegrationsControllerListAvailable<TData = Awaited<ReturnType<typeof mcpIntegrationsControllerListAvailable>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerListAvailable>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getMcpIntegrationsControllerListAvailableQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get MCP integration by ID
 */
export const mcpIntegrationsControllerGetById = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<McpIntegrationResponseDto>(
      {url: `/mcp-integrations/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getMcpIntegrationsControllerGetByIdQueryKey = (id: string,) => {
    return [`/mcp-integrations/${id}`] as const;
    }

    
export const getMcpIntegrationsControllerGetByIdQueryOptions = <TData = Awaited<ReturnType<typeof mcpIntegrationsControllerGetById>>, TError = void>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerGetById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMcpIntegrationsControllerGetByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof mcpIntegrationsControllerGetById>>> = ({ signal }) => mcpIntegrationsControllerGetById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerGetById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type McpIntegrationsControllerGetByIdQueryResult = NonNullable<Awaited<ReturnType<typeof mcpIntegrationsControllerGetById>>>
export type McpIntegrationsControllerGetByIdQueryError = void


export function useMcpIntegrationsControllerGetById<TData = Awaited<ReturnType<typeof mcpIntegrationsControllerGetById>>, TError = void>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerGetById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof mcpIntegrationsControllerGetById>>,
          TError,
          Awaited<ReturnType<typeof mcpIntegrationsControllerGetById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMcpIntegrationsControllerGetById<TData = Awaited<ReturnType<typeof mcpIntegrationsControllerGetById>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerGetById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof mcpIntegrationsControllerGetById>>,
          TError,
          Awaited<ReturnType<typeof mcpIntegrationsControllerGetById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMcpIntegrationsControllerGetById<TData = Awaited<ReturnType<typeof mcpIntegrationsControllerGetById>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerGetById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get MCP integration by ID
 */

export function useMcpIntegrationsControllerGetById<TData = Awaited<ReturnType<typeof mcpIntegrationsControllerGetById>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerGetById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getMcpIntegrationsControllerGetByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update MCP integration
 */
export const mcpIntegrationsControllerUpdate = (
    id: string,
    updateMcpIntegrationDto: UpdateMcpIntegrationDto,
 ) => {
      
      
      return customAxiosInstance<McpIntegrationResponseDto>(
      {url: `/mcp-integrations/${id}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateMcpIntegrationDto
    },
      );
    }
  


export const getMcpIntegrationsControllerUpdateMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerUpdate>>, TError,{id: string;data: UpdateMcpIntegrationDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerUpdate>>, TError,{id: string;data: UpdateMcpIntegrationDto}, TContext> => {

const mutationKey = ['mcpIntegrationsControllerUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof mcpIntegrationsControllerUpdate>>, {id: string;data: UpdateMcpIntegrationDto}> = (props) => {
          const {id,data} = props ?? {};

          return  mcpIntegrationsControllerUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type McpIntegrationsControllerUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof mcpIntegrationsControllerUpdate>>>
    export type McpIntegrationsControllerUpdateMutationBody = UpdateMcpIntegrationDto
    export type McpIntegrationsControllerUpdateMutationError = void

    /**
 * @summary Update MCP integration
 */
export const useMcpIntegrationsControllerUpdate = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerUpdate>>, TError,{id: string;data: UpdateMcpIntegrationDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof mcpIntegrationsControllerUpdate>>,
        TError,
        {id: string;data: UpdateMcpIntegrationDto},
        TContext
      > => {

      const mutationOptions = getMcpIntegrationsControllerUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Delete MCP integration
 */
export const mcpIntegrationsControllerDelete = (
    id: string,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/mcp-integrations/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getMcpIntegrationsControllerDeleteMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerDelete>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerDelete>>, TError,{id: string}, TContext> => {

const mutationKey = ['mcpIntegrationsControllerDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof mcpIntegrationsControllerDelete>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  mcpIntegrationsControllerDelete(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type McpIntegrationsControllerDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof mcpIntegrationsControllerDelete>>>
    
    export type McpIntegrationsControllerDeleteMutationError = void

    /**
 * @summary Delete MCP integration
 */
export const useMcpIntegrationsControllerDelete = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerDelete>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof mcpIntegrationsControllerDelete>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getMcpIntegrationsControllerDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Enable MCP integration
 */
export const mcpIntegrationsControllerEnable = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<McpIntegrationResponseDto>(
      {url: `/mcp-integrations/${id}/enable`, method: 'POST', signal
    },
      );
    }
  


export const getMcpIntegrationsControllerEnableMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerEnable>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerEnable>>, TError,{id: string}, TContext> => {

const mutationKey = ['mcpIntegrationsControllerEnable'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof mcpIntegrationsControllerEnable>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  mcpIntegrationsControllerEnable(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type McpIntegrationsControllerEnableMutationResult = NonNullable<Awaited<ReturnType<typeof mcpIntegrationsControllerEnable>>>
    
    export type McpIntegrationsControllerEnableMutationError = void

    /**
 * @summary Enable MCP integration
 */
export const useMcpIntegrationsControllerEnable = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerEnable>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof mcpIntegrationsControllerEnable>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getMcpIntegrationsControllerEnableMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Disable MCP integration
 */
export const mcpIntegrationsControllerDisable = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<McpIntegrationResponseDto>(
      {url: `/mcp-integrations/${id}/disable`, method: 'POST', signal
    },
      );
    }
  


export const getMcpIntegrationsControllerDisableMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerDisable>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerDisable>>, TError,{id: string}, TContext> => {

const mutationKey = ['mcpIntegrationsControllerDisable'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof mcpIntegrationsControllerDisable>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  mcpIntegrationsControllerDisable(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type McpIntegrationsControllerDisableMutationResult = NonNullable<Awaited<ReturnType<typeof mcpIntegrationsControllerDisable>>>
    
    export type McpIntegrationsControllerDisableMutationError = void

    /**
 * @summary Disable MCP integration
 */
export const useMcpIntegrationsControllerDisable = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerDisable>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof mcpIntegrationsControllerDisable>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getMcpIntegrationsControllerDisableMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Validate MCP integration connection
 */
export const mcpIntegrationsControllerValidate = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<ValidationResponseDto>(
      {url: `/mcp-integrations/${id}/validate`, method: 'POST', signal
    },
      );
    }
  


export const getMcpIntegrationsControllerValidateMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerValidate>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerValidate>>, TError,{id: string}, TContext> => {

const mutationKey = ['mcpIntegrationsControllerValidate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof mcpIntegrationsControllerValidate>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  mcpIntegrationsControllerValidate(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type McpIntegrationsControllerValidateMutationResult = NonNullable<Awaited<ReturnType<typeof mcpIntegrationsControllerValidate>>>
    
    export type McpIntegrationsControllerValidateMutationError = void

    /**
 * @summary Validate MCP integration connection
 */
export const useMcpIntegrationsControllerValidate = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof mcpIntegrationsControllerValidate>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof mcpIntegrationsControllerValidate>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getMcpIntegrationsControllerValidateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary List all teams for the current organization
 */
export const teamsControllerListTeams = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<TeamResponseDto[]>(
      {url: `/teams`, method: 'GET', signal
    },
      );
    }
  

export const getTeamsControllerListTeamsQueryKey = () => {
    return [`/teams`] as const;
    }

    
export const getTeamsControllerListTeamsQueryOptions = <TData = Awaited<ReturnType<typeof teamsControllerListTeams>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsControllerListTeams>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTeamsControllerListTeamsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof teamsControllerListTeams>>> = ({ signal }) => teamsControllerListTeams(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof teamsControllerListTeams>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TeamsControllerListTeamsQueryResult = NonNullable<Awaited<ReturnType<typeof teamsControllerListTeams>>>
export type TeamsControllerListTeamsQueryError = void


export function useTeamsControllerListTeams<TData = Awaited<ReturnType<typeof teamsControllerListTeams>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsControllerListTeams>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof teamsControllerListTeams>>,
          TError,
          Awaited<ReturnType<typeof teamsControllerListTeams>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTeamsControllerListTeams<TData = Awaited<ReturnType<typeof teamsControllerListTeams>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsControllerListTeams>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof teamsControllerListTeams>>,
          TError,
          Awaited<ReturnType<typeof teamsControllerListTeams>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTeamsControllerListTeams<TData = Awaited<ReturnType<typeof teamsControllerListTeams>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsControllerListTeams>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List all teams for the current organization
 */

export function useTeamsControllerListTeams<TData = Awaited<ReturnType<typeof teamsControllerListTeams>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsControllerListTeams>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTeamsControllerListTeamsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a new team for the current organization
 */
export const teamsControllerCreateTeam = (
    createTeamDto: CreateTeamDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<TeamResponseDto>(
      {url: `/teams`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createTeamDto, signal
    },
      );
    }
  


export const getTeamsControllerCreateTeamMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof teamsControllerCreateTeam>>, TError,{data: CreateTeamDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof teamsControllerCreateTeam>>, TError,{data: CreateTeamDto}, TContext> => {

const mutationKey = ['teamsControllerCreateTeam'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof teamsControllerCreateTeam>>, {data: CreateTeamDto}> = (props) => {
          const {data} = props ?? {};

          return  teamsControllerCreateTeam(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TeamsControllerCreateTeamMutationResult = NonNullable<Awaited<ReturnType<typeof teamsControllerCreateTeam>>>
    export type TeamsControllerCreateTeamMutationBody = CreateTeamDto
    export type TeamsControllerCreateTeamMutationError = void

    /**
 * @summary Create a new team for the current organization
 */
export const useTeamsControllerCreateTeam = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof teamsControllerCreateTeam>>, TError,{data: CreateTeamDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof teamsControllerCreateTeam>>,
        TError,
        {data: CreateTeamDto},
        TContext
      > => {

      const mutationOptions = getTeamsControllerCreateTeamMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary List teams the current user is a member of
 */
export const teamsControllerListMyTeams = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<TeamResponseDto[]>(
      {url: `/teams/me`, method: 'GET', signal
    },
      );
    }
  

export const getTeamsControllerListMyTeamsQueryKey = () => {
    return [`/teams/me`] as const;
    }

    
export const getTeamsControllerListMyTeamsQueryOptions = <TData = Awaited<ReturnType<typeof teamsControllerListMyTeams>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsControllerListMyTeams>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTeamsControllerListMyTeamsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof teamsControllerListMyTeams>>> = ({ signal }) => teamsControllerListMyTeams(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof teamsControllerListMyTeams>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TeamsControllerListMyTeamsQueryResult = NonNullable<Awaited<ReturnType<typeof teamsControllerListMyTeams>>>
export type TeamsControllerListMyTeamsQueryError = void


export function useTeamsControllerListMyTeams<TData = Awaited<ReturnType<typeof teamsControllerListMyTeams>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsControllerListMyTeams>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof teamsControllerListMyTeams>>,
          TError,
          Awaited<ReturnType<typeof teamsControllerListMyTeams>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTeamsControllerListMyTeams<TData = Awaited<ReturnType<typeof teamsControllerListMyTeams>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsControllerListMyTeams>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof teamsControllerListMyTeams>>,
          TError,
          Awaited<ReturnType<typeof teamsControllerListMyTeams>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTeamsControllerListMyTeams<TData = Awaited<ReturnType<typeof teamsControllerListMyTeams>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsControllerListMyTeams>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List teams the current user is a member of
 */

export function useTeamsControllerListMyTeams<TData = Awaited<ReturnType<typeof teamsControllerListMyTeams>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsControllerListMyTeams>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTeamsControllerListMyTeamsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get a team by ID
 */
export const teamsControllerGetTeam = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<TeamResponseDto>(
      {url: `/teams/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getTeamsControllerGetTeamQueryKey = (id: string,) => {
    return [`/teams/${id}`] as const;
    }

    
export const getTeamsControllerGetTeamQueryOptions = <TData = Awaited<ReturnType<typeof teamsControllerGetTeam>>, TError = void>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsControllerGetTeam>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTeamsControllerGetTeamQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof teamsControllerGetTeam>>> = ({ signal }) => teamsControllerGetTeam(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof teamsControllerGetTeam>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TeamsControllerGetTeamQueryResult = NonNullable<Awaited<ReturnType<typeof teamsControllerGetTeam>>>
export type TeamsControllerGetTeamQueryError = void


export function useTeamsControllerGetTeam<TData = Awaited<ReturnType<typeof teamsControllerGetTeam>>, TError = void>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsControllerGetTeam>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof teamsControllerGetTeam>>,
          TError,
          Awaited<ReturnType<typeof teamsControllerGetTeam>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTeamsControllerGetTeam<TData = Awaited<ReturnType<typeof teamsControllerGetTeam>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsControllerGetTeam>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof teamsControllerGetTeam>>,
          TError,
          Awaited<ReturnType<typeof teamsControllerGetTeam>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTeamsControllerGetTeam<TData = Awaited<ReturnType<typeof teamsControllerGetTeam>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsControllerGetTeam>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a team by ID
 */

export function useTeamsControllerGetTeam<TData = Awaited<ReturnType<typeof teamsControllerGetTeam>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsControllerGetTeam>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTeamsControllerGetTeamQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update a team in the current organization
 */
export const teamsControllerUpdateTeam = (
    id: string,
    updateTeamDto: UpdateTeamDto,
 ) => {
      
      
      return customAxiosInstance<TeamResponseDto>(
      {url: `/teams/${id}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateTeamDto
    },
      );
    }
  


export const getTeamsControllerUpdateTeamMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof teamsControllerUpdateTeam>>, TError,{id: string;data: UpdateTeamDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof teamsControllerUpdateTeam>>, TError,{id: string;data: UpdateTeamDto}, TContext> => {

const mutationKey = ['teamsControllerUpdateTeam'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof teamsControllerUpdateTeam>>, {id: string;data: UpdateTeamDto}> = (props) => {
          const {id,data} = props ?? {};

          return  teamsControllerUpdateTeam(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TeamsControllerUpdateTeamMutationResult = NonNullable<Awaited<ReturnType<typeof teamsControllerUpdateTeam>>>
    export type TeamsControllerUpdateTeamMutationBody = UpdateTeamDto
    export type TeamsControllerUpdateTeamMutationError = void

    /**
 * @summary Update a team in the current organization
 */
export const useTeamsControllerUpdateTeam = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof teamsControllerUpdateTeam>>, TError,{id: string;data: UpdateTeamDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof teamsControllerUpdateTeam>>,
        TError,
        {id: string;data: UpdateTeamDto},
        TContext
      > => {

      const mutationOptions = getTeamsControllerUpdateTeamMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Delete a team from the current organization
 */
export const teamsControllerDeleteTeam = (
    id: string,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/teams/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getTeamsControllerDeleteTeamMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof teamsControllerDeleteTeam>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof teamsControllerDeleteTeam>>, TError,{id: string}, TContext> => {

const mutationKey = ['teamsControllerDeleteTeam'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof teamsControllerDeleteTeam>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  teamsControllerDeleteTeam(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TeamsControllerDeleteTeamMutationResult = NonNullable<Awaited<ReturnType<typeof teamsControllerDeleteTeam>>>
    
    export type TeamsControllerDeleteTeamMutationError = void

    /**
 * @summary Delete a team from the current organization
 */
export const useTeamsControllerDeleteTeam = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof teamsControllerDeleteTeam>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof teamsControllerDeleteTeam>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getTeamsControllerDeleteTeamMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary List members of a team
 */
export const teamsControllerListTeamMembers = (
    id: string,
    params?: TeamsControllerListTeamMembersParams,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<PaginatedTeamMembersResponseDto>(
      {url: `/teams/${id}/members`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getTeamsControllerListTeamMembersQueryKey = (id: string,
    params?: TeamsControllerListTeamMembersParams,) => {
    return [`/teams/${id}/members`, ...(params ? [params]: [])] as const;
    }

    
export const getTeamsControllerListTeamMembersQueryOptions = <TData = Awaited<ReturnType<typeof teamsControllerListTeamMembers>>, TError = void>(id: string,
    params?: TeamsControllerListTeamMembersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsControllerListTeamMembers>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTeamsControllerListTeamMembersQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof teamsControllerListTeamMembers>>> = ({ signal }) => teamsControllerListTeamMembers(id,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof teamsControllerListTeamMembers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TeamsControllerListTeamMembersQueryResult = NonNullable<Awaited<ReturnType<typeof teamsControllerListTeamMembers>>>
export type TeamsControllerListTeamMembersQueryError = void


export function useTeamsControllerListTeamMembers<TData = Awaited<ReturnType<typeof teamsControllerListTeamMembers>>, TError = void>(
 id: string,
    params: undefined |  TeamsControllerListTeamMembersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsControllerListTeamMembers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof teamsControllerListTeamMembers>>,
          TError,
          Awaited<ReturnType<typeof teamsControllerListTeamMembers>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTeamsControllerListTeamMembers<TData = Awaited<ReturnType<typeof teamsControllerListTeamMembers>>, TError = void>(
 id: string,
    params?: TeamsControllerListTeamMembersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsControllerListTeamMembers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof teamsControllerListTeamMembers>>,
          TError,
          Awaited<ReturnType<typeof teamsControllerListTeamMembers>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTeamsControllerListTeamMembers<TData = Awaited<ReturnType<typeof teamsControllerListTeamMembers>>, TError = void>(
 id: string,
    params?: TeamsControllerListTeamMembersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsControllerListTeamMembers>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List members of a team
 */

export function useTeamsControllerListTeamMembers<TData = Awaited<ReturnType<typeof teamsControllerListTeamMembers>>, TError = void>(
 id: string,
    params?: TeamsControllerListTeamMembersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsControllerListTeamMembers>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTeamsControllerListTeamMembersQueryOptions(id,params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Add a user to a team
 */
export const teamsControllerAddTeamMember = (
    id: string,
    addTeamMemberDto: AddTeamMemberDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<TeamMemberResponseDto>(
      {url: `/teams/${id}/members`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: addTeamMemberDto, signal
    },
      );
    }
  


export const getTeamsControllerAddTeamMemberMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof teamsControllerAddTeamMember>>, TError,{id: string;data: AddTeamMemberDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof teamsControllerAddTeamMember>>, TError,{id: string;data: AddTeamMemberDto}, TContext> => {

const mutationKey = ['teamsControllerAddTeamMember'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof teamsControllerAddTeamMember>>, {id: string;data: AddTeamMemberDto}> = (props) => {
          const {id,data} = props ?? {};

          return  teamsControllerAddTeamMember(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TeamsControllerAddTeamMemberMutationResult = NonNullable<Awaited<ReturnType<typeof teamsControllerAddTeamMember>>>
    export type TeamsControllerAddTeamMemberMutationBody = AddTeamMemberDto
    export type TeamsControllerAddTeamMemberMutationError = void

    /**
 * @summary Add a user to a team
 */
export const useTeamsControllerAddTeamMember = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof teamsControllerAddTeamMember>>, TError,{id: string;data: AddTeamMemberDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof teamsControllerAddTeamMember>>,
        TError,
        {id: string;data: AddTeamMemberDto},
        TContext
      > => {

      const mutationOptions = getTeamsControllerAddTeamMemberMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Remove a user from a team
 */
export const teamsControllerRemoveTeamMember = (
    id: string,
    userId: string,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/teams/${id}/members/${userId}`, method: 'DELETE'
    },
      );
    }
  


export const getTeamsControllerRemoveTeamMemberMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof teamsControllerRemoveTeamMember>>, TError,{id: string;userId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof teamsControllerRemoveTeamMember>>, TError,{id: string;userId: string}, TContext> => {

const mutationKey = ['teamsControllerRemoveTeamMember'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof teamsControllerRemoveTeamMember>>, {id: string;userId: string}> = (props) => {
          const {id,userId} = props ?? {};

          return  teamsControllerRemoveTeamMember(id,userId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TeamsControllerRemoveTeamMemberMutationResult = NonNullable<Awaited<ReturnType<typeof teamsControllerRemoveTeamMember>>>
    
    export type TeamsControllerRemoveTeamMemberMutationError = void

    /**
 * @summary Remove a user from a team
 */
export const useTeamsControllerRemoveTeamMember = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof teamsControllerRemoveTeamMember>>, TError,{id: string;userId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof teamsControllerRemoveTeamMember>>,
        TError,
        {id: string;userId: string},
        TContext
      > => {

      const mutationOptions = getTeamsControllerRemoveTeamMemberMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Create a new skill
 */
export const skillsControllerCreate = (
    createSkillDto: CreateSkillDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<SkillResponseDto>(
      {url: `/skills`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createSkillDto, signal
    },
      );
    }
  


export const getSkillsControllerCreateMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof skillsControllerCreate>>, TError,{data: CreateSkillDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof skillsControllerCreate>>, TError,{data: CreateSkillDto}, TContext> => {

const mutationKey = ['skillsControllerCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof skillsControllerCreate>>, {data: CreateSkillDto}> = (props) => {
          const {data} = props ?? {};

          return  skillsControllerCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SkillsControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof skillsControllerCreate>>>
    export type SkillsControllerCreateMutationBody = CreateSkillDto
    export type SkillsControllerCreateMutationError = void

    /**
 * @summary Create a new skill
 */
export const useSkillsControllerCreate = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof skillsControllerCreate>>, TError,{data: CreateSkillDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof skillsControllerCreate>>,
        TError,
        {data: CreateSkillDto},
        TContext
      > => {

      const mutationOptions = getSkillsControllerCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get all skills for the current user
 */
export const skillsControllerFindAll = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<SkillResponseDto[]>(
      {url: `/skills`, method: 'GET', signal
    },
      );
    }
  

export const getSkillsControllerFindAllQueryKey = () => {
    return [`/skills`] as const;
    }

    
export const getSkillsControllerFindAllQueryOptions = <TData = Awaited<ReturnType<typeof skillsControllerFindAll>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof skillsControllerFindAll>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSkillsControllerFindAllQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof skillsControllerFindAll>>> = ({ signal }) => skillsControllerFindAll(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof skillsControllerFindAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SkillsControllerFindAllQueryResult = NonNullable<Awaited<ReturnType<typeof skillsControllerFindAll>>>
export type SkillsControllerFindAllQueryError = unknown


export function useSkillsControllerFindAll<TData = Awaited<ReturnType<typeof skillsControllerFindAll>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof skillsControllerFindAll>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof skillsControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof skillsControllerFindAll>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSkillsControllerFindAll<TData = Awaited<ReturnType<typeof skillsControllerFindAll>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof skillsControllerFindAll>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof skillsControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof skillsControllerFindAll>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSkillsControllerFindAll<TData = Awaited<ReturnType<typeof skillsControllerFindAll>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof skillsControllerFindAll>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all skills for the current user
 */

export function useSkillsControllerFindAll<TData = Awaited<ReturnType<typeof skillsControllerFindAll>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof skillsControllerFindAll>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSkillsControllerFindAllQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get a skill by ID
 */
export const skillsControllerFindOne = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<SkillResponseDto>(
      {url: `/skills/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getSkillsControllerFindOneQueryKey = (id: string,) => {
    return [`/skills/${id}`] as const;
    }

    
export const getSkillsControllerFindOneQueryOptions = <TData = Awaited<ReturnType<typeof skillsControllerFindOne>>, TError = void>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof skillsControllerFindOne>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSkillsControllerFindOneQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof skillsControllerFindOne>>> = ({ signal }) => skillsControllerFindOne(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof skillsControllerFindOne>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SkillsControllerFindOneQueryResult = NonNullable<Awaited<ReturnType<typeof skillsControllerFindOne>>>
export type SkillsControllerFindOneQueryError = void


export function useSkillsControllerFindOne<TData = Awaited<ReturnType<typeof skillsControllerFindOne>>, TError = void>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof skillsControllerFindOne>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof skillsControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof skillsControllerFindOne>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSkillsControllerFindOne<TData = Awaited<ReturnType<typeof skillsControllerFindOne>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof skillsControllerFindOne>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof skillsControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof skillsControllerFindOne>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSkillsControllerFindOne<TData = Awaited<ReturnType<typeof skillsControllerFindOne>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof skillsControllerFindOne>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a skill by ID
 */

export function useSkillsControllerFindOne<TData = Awaited<ReturnType<typeof skillsControllerFindOne>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof skillsControllerFindOne>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSkillsControllerFindOneQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update a skill
 */
export const skillsControllerUpdate = (
    id: string,
    updateSkillDto: UpdateSkillDto,
 ) => {
      
      
      return customAxiosInstance<SkillResponseDto>(
      {url: `/skills/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateSkillDto
    },
      );
    }
  


export const getSkillsControllerUpdateMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof skillsControllerUpdate>>, TError,{id: string;data: UpdateSkillDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof skillsControllerUpdate>>, TError,{id: string;data: UpdateSkillDto}, TContext> => {

const mutationKey = ['skillsControllerUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof skillsControllerUpdate>>, {id: string;data: UpdateSkillDto}> = (props) => {
          const {id,data} = props ?? {};

          return  skillsControllerUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SkillsControllerUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof skillsControllerUpdate>>>
    export type SkillsControllerUpdateMutationBody = UpdateSkillDto
    export type SkillsControllerUpdateMutationError = void

    /**
 * @summary Update a skill
 */
export const useSkillsControllerUpdate = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof skillsControllerUpdate>>, TError,{id: string;data: UpdateSkillDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof skillsControllerUpdate>>,
        TError,
        {id: string;data: UpdateSkillDto},
        TContext
      > => {

      const mutationOptions = getSkillsControllerUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Delete a skill
 */
export const skillsControllerDelete = (
    id: string,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/skills/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getSkillsControllerDeleteMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof skillsControllerDelete>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof skillsControllerDelete>>, TError,{id: string}, TContext> => {

const mutationKey = ['skillsControllerDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof skillsControllerDelete>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  skillsControllerDelete(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SkillsControllerDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof skillsControllerDelete>>>
    
    export type SkillsControllerDeleteMutationError = void

    /**
 * @summary Delete a skill
 */
export const useSkillsControllerDelete = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof skillsControllerDelete>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof skillsControllerDelete>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getSkillsControllerDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Toggle skill active/inactive status
 */
export const skillsControllerToggleActive = (
    id: string,
 ) => {
      
      
      return customAxiosInstance<SkillResponseDto>(
      {url: `/skills/${id}/toggle-active`, method: 'PATCH'
    },
      );
    }
  


export const getSkillsControllerToggleActiveMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof skillsControllerToggleActive>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof skillsControllerToggleActive>>, TError,{id: string}, TContext> => {

const mutationKey = ['skillsControllerToggleActive'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof skillsControllerToggleActive>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  skillsControllerToggleActive(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SkillsControllerToggleActiveMutationResult = NonNullable<Awaited<ReturnType<typeof skillsControllerToggleActive>>>
    
    export type SkillsControllerToggleActiveMutationError = void

    /**
 * @summary Toggle skill active/inactive status
 */
export const useSkillsControllerToggleActive = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof skillsControllerToggleActive>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof skillsControllerToggleActive>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getSkillsControllerToggleActiveMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get all sources for a skill
 */
export const skillsControllerGetSkillSources = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<SkillSourceResponseDto[]>(
      {url: `/skills/${id}/sources`, method: 'GET', signal
    },
      );
    }
  

export const getSkillsControllerGetSkillSourcesQueryKey = (id: string,) => {
    return [`/skills/${id}/sources`] as const;
    }

    
export const getSkillsControllerGetSkillSourcesQueryOptions = <TData = Awaited<ReturnType<typeof skillsControllerGetSkillSources>>, TError = void>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof skillsControllerGetSkillSources>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSkillsControllerGetSkillSourcesQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof skillsControllerGetSkillSources>>> = ({ signal }) => skillsControllerGetSkillSources(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof skillsControllerGetSkillSources>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SkillsControllerGetSkillSourcesQueryResult = NonNullable<Awaited<ReturnType<typeof skillsControllerGetSkillSources>>>
export type SkillsControllerGetSkillSourcesQueryError = void


export function useSkillsControllerGetSkillSources<TData = Awaited<ReturnType<typeof skillsControllerGetSkillSources>>, TError = void>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof skillsControllerGetSkillSources>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof skillsControllerGetSkillSources>>,
          TError,
          Awaited<ReturnType<typeof skillsControllerGetSkillSources>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSkillsControllerGetSkillSources<TData = Awaited<ReturnType<typeof skillsControllerGetSkillSources>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof skillsControllerGetSkillSources>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof skillsControllerGetSkillSources>>,
          TError,
          Awaited<ReturnType<typeof skillsControllerGetSkillSources>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSkillsControllerGetSkillSources<TData = Awaited<ReturnType<typeof skillsControllerGetSkillSources>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof skillsControllerGetSkillSources>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all sources for a skill
 */

export function useSkillsControllerGetSkillSources<TData = Awaited<ReturnType<typeof skillsControllerGetSkillSources>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof skillsControllerGetSkillSources>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSkillsControllerGetSkillSourcesQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Add a file source to a skill
 */
export const skillsControllerAddFileSource = (
    id: string,
    skillsControllerAddFileSourceBody: SkillsControllerAddFileSourceBody,
 signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`file`, skillsControllerAddFileSourceBody.file)

      return customAxiosInstance<SkillResponseDto>(
      {url: `/skills/${id}/sources/file`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      );
    }
  


export const getSkillsControllerAddFileSourceMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof skillsControllerAddFileSource>>, TError,{id: string;data: SkillsControllerAddFileSourceBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof skillsControllerAddFileSource>>, TError,{id: string;data: SkillsControllerAddFileSourceBody}, TContext> => {

const mutationKey = ['skillsControllerAddFileSource'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof skillsControllerAddFileSource>>, {id: string;data: SkillsControllerAddFileSourceBody}> = (props) => {
          const {id,data} = props ?? {};

          return  skillsControllerAddFileSource(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SkillsControllerAddFileSourceMutationResult = NonNullable<Awaited<ReturnType<typeof skillsControllerAddFileSource>>>
    export type SkillsControllerAddFileSourceMutationBody = SkillsControllerAddFileSourceBody
    export type SkillsControllerAddFileSourceMutationError = void

    /**
 * @summary Add a file source to a skill
 */
export const useSkillsControllerAddFileSource = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof skillsControllerAddFileSource>>, TError,{id: string;data: SkillsControllerAddFileSourceBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof skillsControllerAddFileSource>>,
        TError,
        {id: string;data: SkillsControllerAddFileSourceBody},
        TContext
      > => {

      const mutationOptions = getSkillsControllerAddFileSourceMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Remove a source from a skill
 */
export const skillsControllerRemoveSource = (
    id: string,
    sourceId: string,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/skills/${id}/sources/${sourceId}`, method: 'DELETE'
    },
      );
    }
  


export const getSkillsControllerRemoveSourceMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof skillsControllerRemoveSource>>, TError,{id: string;sourceId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof skillsControllerRemoveSource>>, TError,{id: string;sourceId: string}, TContext> => {

const mutationKey = ['skillsControllerRemoveSource'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof skillsControllerRemoveSource>>, {id: string;sourceId: string}> = (props) => {
          const {id,sourceId} = props ?? {};

          return  skillsControllerRemoveSource(id,sourceId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SkillsControllerRemoveSourceMutationResult = NonNullable<Awaited<ReturnType<typeof skillsControllerRemoveSource>>>
    
    export type SkillsControllerRemoveSourceMutationError = void

    /**
 * @summary Remove a source from a skill
 */
export const useSkillsControllerRemoveSource = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof skillsControllerRemoveSource>>, TError,{id: string;sourceId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof skillsControllerRemoveSource>>,
        TError,
        {id: string;sourceId: string},
        TContext
      > => {

      const mutationOptions = getSkillsControllerRemoveSourceMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Assign MCP integration to skill
 */
export const skillsControllerAssignMcpIntegration = (
    skillId: string,
    integrationId: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<SkillResponseDto>(
      {url: `/skills/${skillId}/mcp-integrations/${integrationId}`, method: 'POST', signal
    },
      );
    }
  


export const getSkillsControllerAssignMcpIntegrationMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof skillsControllerAssignMcpIntegration>>, TError,{skillId: string;integrationId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof skillsControllerAssignMcpIntegration>>, TError,{skillId: string;integrationId: string}, TContext> => {

const mutationKey = ['skillsControllerAssignMcpIntegration'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof skillsControllerAssignMcpIntegration>>, {skillId: string;integrationId: string}> = (props) => {
          const {skillId,integrationId} = props ?? {};

          return  skillsControllerAssignMcpIntegration(skillId,integrationId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SkillsControllerAssignMcpIntegrationMutationResult = NonNullable<Awaited<ReturnType<typeof skillsControllerAssignMcpIntegration>>>
    
    export type SkillsControllerAssignMcpIntegrationMutationError = void

    /**
 * @summary Assign MCP integration to skill
 */
export const useSkillsControllerAssignMcpIntegration = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof skillsControllerAssignMcpIntegration>>, TError,{skillId: string;integrationId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof skillsControllerAssignMcpIntegration>>,
        TError,
        {skillId: string;integrationId: string},
        TContext
      > => {

      const mutationOptions = getSkillsControllerAssignMcpIntegrationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Unassign MCP integration from skill
 */
export const skillsControllerUnassignMcpIntegration = (
    skillId: string,
    integrationId: string,
 ) => {
      
      
      return customAxiosInstance<SkillResponseDto>(
      {url: `/skills/${skillId}/mcp-integrations/${integrationId}`, method: 'DELETE'
    },
      );
    }
  


export const getSkillsControllerUnassignMcpIntegrationMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof skillsControllerUnassignMcpIntegration>>, TError,{skillId: string;integrationId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof skillsControllerUnassignMcpIntegration>>, TError,{skillId: string;integrationId: string}, TContext> => {

const mutationKey = ['skillsControllerUnassignMcpIntegration'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof skillsControllerUnassignMcpIntegration>>, {skillId: string;integrationId: string}> = (props) => {
          const {skillId,integrationId} = props ?? {};

          return  skillsControllerUnassignMcpIntegration(skillId,integrationId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SkillsControllerUnassignMcpIntegrationMutationResult = NonNullable<Awaited<ReturnType<typeof skillsControllerUnassignMcpIntegration>>>
    
    export type SkillsControllerUnassignMcpIntegrationMutationError = void

    /**
 * @summary Unassign MCP integration from skill
 */
export const useSkillsControllerUnassignMcpIntegration = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof skillsControllerUnassignMcpIntegration>>, TError,{skillId: string;integrationId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof skillsControllerUnassignMcpIntegration>>,
        TError,
        {skillId: string;integrationId: string},
        TContext
      > => {

      const mutationOptions = getSkillsControllerUnassignMcpIntegrationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary List MCP integrations assigned to skill
 */
export const skillsControllerListSkillMcpIntegrations = (
    skillId: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<McpIntegrationResponseDto[]>(
      {url: `/skills/${skillId}/mcp-integrations`, method: 'GET', signal
    },
      );
    }
  

export const getSkillsControllerListSkillMcpIntegrationsQueryKey = (skillId: string,) => {
    return [`/skills/${skillId}/mcp-integrations`] as const;
    }

    
export const getSkillsControllerListSkillMcpIntegrationsQueryOptions = <TData = Awaited<ReturnType<typeof skillsControllerListSkillMcpIntegrations>>, TError = void>(skillId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof skillsControllerListSkillMcpIntegrations>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSkillsControllerListSkillMcpIntegrationsQueryKey(skillId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof skillsControllerListSkillMcpIntegrations>>> = ({ signal }) => skillsControllerListSkillMcpIntegrations(skillId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(skillId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof skillsControllerListSkillMcpIntegrations>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SkillsControllerListSkillMcpIntegrationsQueryResult = NonNullable<Awaited<ReturnType<typeof skillsControllerListSkillMcpIntegrations>>>
export type SkillsControllerListSkillMcpIntegrationsQueryError = void


export function useSkillsControllerListSkillMcpIntegrations<TData = Awaited<ReturnType<typeof skillsControllerListSkillMcpIntegrations>>, TError = void>(
 skillId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof skillsControllerListSkillMcpIntegrations>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof skillsControllerListSkillMcpIntegrations>>,
          TError,
          Awaited<ReturnType<typeof skillsControllerListSkillMcpIntegrations>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSkillsControllerListSkillMcpIntegrations<TData = Awaited<ReturnType<typeof skillsControllerListSkillMcpIntegrations>>, TError = void>(
 skillId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof skillsControllerListSkillMcpIntegrations>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof skillsControllerListSkillMcpIntegrations>>,
          TError,
          Awaited<ReturnType<typeof skillsControllerListSkillMcpIntegrations>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSkillsControllerListSkillMcpIntegrations<TData = Awaited<ReturnType<typeof skillsControllerListSkillMcpIntegrations>>, TError = void>(
 skillId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof skillsControllerListSkillMcpIntegrations>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List MCP integrations assigned to skill
 */

export function useSkillsControllerListSkillMcpIntegrations<TData = Awaited<ReturnType<typeof skillsControllerListSkillMcpIntegrations>>, TError = void>(
 skillId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof skillsControllerListSkillMcpIntegrations>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSkillsControllerListSkillMcpIntegrationsQueryOptions(skillId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Sends a user message (with optional image attachments) and returns a server-sent events stream with the AI response. Images are processed transactionally with the message.
 * @summary Send a message with optional images and receive streaming response
 */
export const runsControllerSendMessage = (
    runsControllerSendMessageBody: RunsControllerSendMessageBody,
 signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`threadId`, runsControllerSendMessageBody.threadId)
if(runsControllerSendMessageBody.text !== undefined) {
 formData.append(`text`, runsControllerSendMessageBody.text)
 }
if(runsControllerSendMessageBody.images !== undefined) {
 runsControllerSendMessageBody.images.forEach(value => formData.append(`images`, value));
 }
if(runsControllerSendMessageBody.imageAltTexts !== undefined) {
 formData.append(`imageAltTexts`, runsControllerSendMessageBody.imageAltTexts)
 }
if(runsControllerSendMessageBody.toolResult !== undefined) {
 formData.append(`toolResult`, runsControllerSendMessageBody.toolResult)
 }
if(runsControllerSendMessageBody.streaming !== undefined) {
 formData.append(`streaming`, runsControllerSendMessageBody.streaming.toString())
 }

      return customAxiosInstance<RunsControllerSendMessage200>(
      {url: `/runs/send-message`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      );
    }
  


export const getRunsControllerSendMessageMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof runsControllerSendMessage>>, TError,{data: RunsControllerSendMessageBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof runsControllerSendMessage>>, TError,{data: RunsControllerSendMessageBody}, TContext> => {

const mutationKey = ['runsControllerSendMessage'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof runsControllerSendMessage>>, {data: RunsControllerSendMessageBody}> = (props) => {
          const {data} = props ?? {};

          return  runsControllerSendMessage(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RunsControllerSendMessageMutationResult = NonNullable<Awaited<ReturnType<typeof runsControllerSendMessage>>>
    export type RunsControllerSendMessageMutationBody = RunsControllerSendMessageBody
    export type RunsControllerSendMessageMutationError = void

    /**
 * @summary Send a message with optional images and receive streaming response
 */
export const useRunsControllerSendMessage = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof runsControllerSendMessage>>, TError,{data: RunsControllerSendMessageBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof runsControllerSendMessage>>,
        TError,
        {data: RunsControllerSendMessageBody},
        TContext
      > => {

      const mutationOptions = getRunsControllerSendMessageMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Create a new trial for an organization. Only accessible to users with the super admin system role.
 * @summary Create a new trial
 */
export const superAdminTrialsControllerCreateTrial = (
    createTrialRequestDto: CreateTrialRequestDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<SuperAdminTrialResponseDto>(
      {url: `/super-admin/trials`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createTrialRequestDto, signal
    },
      );
    }
  


export const getSuperAdminTrialsControllerCreateTrialMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminTrialsControllerCreateTrial>>, TError,{data: CreateTrialRequestDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof superAdminTrialsControllerCreateTrial>>, TError,{data: CreateTrialRequestDto}, TContext> => {

const mutationKey = ['superAdminTrialsControllerCreateTrial'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof superAdminTrialsControllerCreateTrial>>, {data: CreateTrialRequestDto}> = (props) => {
          const {data} = props ?? {};

          return  superAdminTrialsControllerCreateTrial(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuperAdminTrialsControllerCreateTrialMutationResult = NonNullable<Awaited<ReturnType<typeof superAdminTrialsControllerCreateTrial>>>
    export type SuperAdminTrialsControllerCreateTrialMutationBody = CreateTrialRequestDto
    export type SuperAdminTrialsControllerCreateTrialMutationError = void

    /**
 * @summary Create a new trial
 */
export const useSuperAdminTrialsControllerCreateTrial = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminTrialsControllerCreateTrial>>, TError,{data: CreateTrialRequestDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof superAdminTrialsControllerCreateTrial>>,
        TError,
        {data: CreateTrialRequestDto},
        TContext
      > => {

      const mutationOptions = getSuperAdminTrialsControllerCreateTrialMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a trial by its organization ID. Only accessible to users with the super admin system role.
 * @summary Get a trial by organization ID
 */
export const superAdminTrialsControllerGetTrialByOrgId = (
    orgId: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<SuperAdminTrialResponseDtoNullable>(
      {url: `/super-admin/trials/${orgId}`, method: 'GET', signal
    },
      );
    }
  

export const getSuperAdminTrialsControllerGetTrialByOrgIdQueryKey = (orgId: string,) => {
    return [`/super-admin/trials/${orgId}`] as const;
    }

    
export const getSuperAdminTrialsControllerGetTrialByOrgIdQueryOptions = <TData = Awaited<ReturnType<typeof superAdminTrialsControllerGetTrialByOrgId>>, TError = void>(orgId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminTrialsControllerGetTrialByOrgId>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSuperAdminTrialsControllerGetTrialByOrgIdQueryKey(orgId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof superAdminTrialsControllerGetTrialByOrgId>>> = ({ signal }) => superAdminTrialsControllerGetTrialByOrgId(orgId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orgId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof superAdminTrialsControllerGetTrialByOrgId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SuperAdminTrialsControllerGetTrialByOrgIdQueryResult = NonNullable<Awaited<ReturnType<typeof superAdminTrialsControllerGetTrialByOrgId>>>
export type SuperAdminTrialsControllerGetTrialByOrgIdQueryError = void


export function useSuperAdminTrialsControllerGetTrialByOrgId<TData = Awaited<ReturnType<typeof superAdminTrialsControllerGetTrialByOrgId>>, TError = void>(
 orgId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminTrialsControllerGetTrialByOrgId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof superAdminTrialsControllerGetTrialByOrgId>>,
          TError,
          Awaited<ReturnType<typeof superAdminTrialsControllerGetTrialByOrgId>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSuperAdminTrialsControllerGetTrialByOrgId<TData = Awaited<ReturnType<typeof superAdminTrialsControllerGetTrialByOrgId>>, TError = void>(
 orgId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminTrialsControllerGetTrialByOrgId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof superAdminTrialsControllerGetTrialByOrgId>>,
          TError,
          Awaited<ReturnType<typeof superAdminTrialsControllerGetTrialByOrgId>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSuperAdminTrialsControllerGetTrialByOrgId<TData = Awaited<ReturnType<typeof superAdminTrialsControllerGetTrialByOrgId>>, TError = void>(
 orgId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminTrialsControllerGetTrialByOrgId>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a trial by organization ID
 */

export function useSuperAdminTrialsControllerGetTrialByOrgId<TData = Awaited<ReturnType<typeof superAdminTrialsControllerGetTrialByOrgId>>, TError = void>(
 orgId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminTrialsControllerGetTrialByOrgId>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSuperAdminTrialsControllerGetTrialByOrgIdQueryOptions(orgId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update a trial for an organization. Can update maxMessages and/or messagesSent. Only accessible to users with the super admin system role.
 * @summary Update a trial
 */
export const superAdminTrialsControllerUpdateTrial = (
    orgId: string,
    updateTrialRequestDto: UpdateTrialRequestDto,
 ) => {
      
      
      return customAxiosInstance<SuperAdminTrialResponseDto>(
      {url: `/super-admin/trials/${orgId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateTrialRequestDto
    },
      );
    }
  


export const getSuperAdminTrialsControllerUpdateTrialMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminTrialsControllerUpdateTrial>>, TError,{orgId: string;data: UpdateTrialRequestDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof superAdminTrialsControllerUpdateTrial>>, TError,{orgId: string;data: UpdateTrialRequestDto}, TContext> => {

const mutationKey = ['superAdminTrialsControllerUpdateTrial'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof superAdminTrialsControllerUpdateTrial>>, {orgId: string;data: UpdateTrialRequestDto}> = (props) => {
          const {orgId,data} = props ?? {};

          return  superAdminTrialsControllerUpdateTrial(orgId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SuperAdminTrialsControllerUpdateTrialMutationResult = NonNullable<Awaited<ReturnType<typeof superAdminTrialsControllerUpdateTrial>>>
    export type SuperAdminTrialsControllerUpdateTrialMutationBody = UpdateTrialRequestDto
    export type SuperAdminTrialsControllerUpdateTrialMutationError = void

    /**
 * @summary Update a trial
 */
export const useSuperAdminTrialsControllerUpdateTrial = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof superAdminTrialsControllerUpdateTrial>>, TError,{orgId: string;data: UpdateTrialRequestDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof superAdminTrialsControllerUpdateTrial>>,
        TError,
        {orgId: string;data: UpdateTrialRequestDto},
        TContext
      > => {

      const mutationOptions = getSuperAdminTrialsControllerUpdateTrialMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Returns configuration settings for the usage dashboard, including deployment mode. This endpoint helps the frontend determine which features to show based on the deployment type.
 * @summary Get usage dashboard configuration
 */
export const usageControllerGetUsageConfig = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<UsageConfigResponseDto>(
      {url: `/usage/config`, method: 'GET', signal
    },
      );
    }
  

export const getUsageControllerGetUsageConfigQueryKey = () => {
    return [`/usage/config`] as const;
    }

    
export const getUsageControllerGetUsageConfigQueryOptions = <TData = Awaited<ReturnType<typeof usageControllerGetUsageConfig>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usageControllerGetUsageConfig>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUsageControllerGetUsageConfigQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usageControllerGetUsageConfig>>> = ({ signal }) => usageControllerGetUsageConfig(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usageControllerGetUsageConfig>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UsageControllerGetUsageConfigQueryResult = NonNullable<Awaited<ReturnType<typeof usageControllerGetUsageConfig>>>
export type UsageControllerGetUsageConfigQueryError = unknown


export function useUsageControllerGetUsageConfig<TData = Awaited<ReturnType<typeof usageControllerGetUsageConfig>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof usageControllerGetUsageConfig>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usageControllerGetUsageConfig>>,
          TError,
          Awaited<ReturnType<typeof usageControllerGetUsageConfig>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsageControllerGetUsageConfig<TData = Awaited<ReturnType<typeof usageControllerGetUsageConfig>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usageControllerGetUsageConfig>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usageControllerGetUsageConfig>>,
          TError,
          Awaited<ReturnType<typeof usageControllerGetUsageConfig>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsageControllerGetUsageConfig<TData = Awaited<ReturnType<typeof usageControllerGetUsageConfig>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usageControllerGetUsageConfig>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get usage dashboard configuration
 */

export function useUsageControllerGetUsageConfig<TData = Awaited<ReturnType<typeof usageControllerGetUsageConfig>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usageControllerGetUsageConfig>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUsageControllerGetUsageConfigQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns aggregated usage statistics including total tokens, requests, and active users. Dates are optional - if not provided, shows all usage.
 * @summary Get overall usage statistics
 */
export const usageControllerGetUsageStats = (
    params?: UsageControllerGetUsageStatsParams,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<UsageStatsResponseDto>(
      {url: `/usage/stats`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getUsageControllerGetUsageStatsQueryKey = (params?: UsageControllerGetUsageStatsParams,) => {
    return [`/usage/stats`, ...(params ? [params]: [])] as const;
    }

    
export const getUsageControllerGetUsageStatsQueryOptions = <TData = Awaited<ReturnType<typeof usageControllerGetUsageStats>>, TError = unknown>(params?: UsageControllerGetUsageStatsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usageControllerGetUsageStats>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUsageControllerGetUsageStatsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usageControllerGetUsageStats>>> = ({ signal }) => usageControllerGetUsageStats(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usageControllerGetUsageStats>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UsageControllerGetUsageStatsQueryResult = NonNullable<Awaited<ReturnType<typeof usageControllerGetUsageStats>>>
export type UsageControllerGetUsageStatsQueryError = unknown


export function useUsageControllerGetUsageStats<TData = Awaited<ReturnType<typeof usageControllerGetUsageStats>>, TError = unknown>(
 params: undefined |  UsageControllerGetUsageStatsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof usageControllerGetUsageStats>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usageControllerGetUsageStats>>,
          TError,
          Awaited<ReturnType<typeof usageControllerGetUsageStats>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsageControllerGetUsageStats<TData = Awaited<ReturnType<typeof usageControllerGetUsageStats>>, TError = unknown>(
 params?: UsageControllerGetUsageStatsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usageControllerGetUsageStats>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usageControllerGetUsageStats>>,
          TError,
          Awaited<ReturnType<typeof usageControllerGetUsageStats>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsageControllerGetUsageStats<TData = Awaited<ReturnType<typeof usageControllerGetUsageStats>>, TError = unknown>(
 params?: UsageControllerGetUsageStatsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usageControllerGetUsageStats>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get overall usage statistics
 */

export function useUsageControllerGetUsageStats<TData = Awaited<ReturnType<typeof usageControllerGetUsageStats>>, TError = unknown>(
 params?: UsageControllerGetUsageStatsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usageControllerGetUsageStats>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUsageControllerGetUsageStatsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns usage statistics grouped by model provider (OpenAI, Anthropic, etc.) with optional time series data for trend analysis. Useful for provider comparison charts. Dates are optional - if not provided, shows all usage.
 * @summary Get usage statistics by provider
 */
export const usageControllerGetProviderUsage = (
    params?: UsageControllerGetProviderUsageParams,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<ProviderUsageResponseDto>(
      {url: `/usage/providers`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getUsageControllerGetProviderUsageQueryKey = (params?: UsageControllerGetProviderUsageParams,) => {
    return [`/usage/providers`, ...(params ? [params]: [])] as const;
    }

    
export const getUsageControllerGetProviderUsageQueryOptions = <TData = Awaited<ReturnType<typeof usageControllerGetProviderUsage>>, TError = unknown>(params?: UsageControllerGetProviderUsageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usageControllerGetProviderUsage>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUsageControllerGetProviderUsageQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usageControllerGetProviderUsage>>> = ({ signal }) => usageControllerGetProviderUsage(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usageControllerGetProviderUsage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UsageControllerGetProviderUsageQueryResult = NonNullable<Awaited<ReturnType<typeof usageControllerGetProviderUsage>>>
export type UsageControllerGetProviderUsageQueryError = unknown


export function useUsageControllerGetProviderUsage<TData = Awaited<ReturnType<typeof usageControllerGetProviderUsage>>, TError = unknown>(
 params: undefined |  UsageControllerGetProviderUsageParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof usageControllerGetProviderUsage>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usageControllerGetProviderUsage>>,
          TError,
          Awaited<ReturnType<typeof usageControllerGetProviderUsage>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsageControllerGetProviderUsage<TData = Awaited<ReturnType<typeof usageControllerGetProviderUsage>>, TError = unknown>(
 params?: UsageControllerGetProviderUsageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usageControllerGetProviderUsage>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usageControllerGetProviderUsage>>,
          TError,
          Awaited<ReturnType<typeof usageControllerGetProviderUsage>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsageControllerGetProviderUsage<TData = Awaited<ReturnType<typeof usageControllerGetProviderUsage>>, TError = unknown>(
 params?: UsageControllerGetProviderUsageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usageControllerGetProviderUsage>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get usage statistics by provider
 */

export function useUsageControllerGetProviderUsage<TData = Awaited<ReturnType<typeof usageControllerGetProviderUsage>>, TError = unknown>(
 params?: UsageControllerGetProviderUsageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usageControllerGetProviderUsage>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUsageControllerGetProviderUsageQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns rows aligned by date with tokens per provider. Shape: { timeSeries: [{ date, values: { [provider]: tokens } }] }
 * @summary Get provider usage time series aligned by date (chart-ready)
 */
export const usageControllerGetProviderUsageChart = (
    params?: UsageControllerGetProviderUsageChartParams,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<ProviderUsageChartResponseDto>(
      {url: `/usage/providers/chart`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getUsageControllerGetProviderUsageChartQueryKey = (params?: UsageControllerGetProviderUsageChartParams,) => {
    return [`/usage/providers/chart`, ...(params ? [params]: [])] as const;
    }

    
export const getUsageControllerGetProviderUsageChartQueryOptions = <TData = Awaited<ReturnType<typeof usageControllerGetProviderUsageChart>>, TError = unknown>(params?: UsageControllerGetProviderUsageChartParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usageControllerGetProviderUsageChart>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUsageControllerGetProviderUsageChartQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usageControllerGetProviderUsageChart>>> = ({ signal }) => usageControllerGetProviderUsageChart(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usageControllerGetProviderUsageChart>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UsageControllerGetProviderUsageChartQueryResult = NonNullable<Awaited<ReturnType<typeof usageControllerGetProviderUsageChart>>>
export type UsageControllerGetProviderUsageChartQueryError = unknown


export function useUsageControllerGetProviderUsageChart<TData = Awaited<ReturnType<typeof usageControllerGetProviderUsageChart>>, TError = unknown>(
 params: undefined |  UsageControllerGetProviderUsageChartParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof usageControllerGetProviderUsageChart>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usageControllerGetProviderUsageChart>>,
          TError,
          Awaited<ReturnType<typeof usageControllerGetProviderUsageChart>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsageControllerGetProviderUsageChart<TData = Awaited<ReturnType<typeof usageControllerGetProviderUsageChart>>, TError = unknown>(
 params?: UsageControllerGetProviderUsageChartParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usageControllerGetProviderUsageChart>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usageControllerGetProviderUsageChart>>,
          TError,
          Awaited<ReturnType<typeof usageControllerGetProviderUsageChart>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsageControllerGetProviderUsageChart<TData = Awaited<ReturnType<typeof usageControllerGetProviderUsageChart>>, TError = unknown>(
 params?: UsageControllerGetProviderUsageChartParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usageControllerGetProviderUsageChart>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get provider usage time series aligned by date (chart-ready)
 */

export function useUsageControllerGetProviderUsageChart<TData = Awaited<ReturnType<typeof usageControllerGetProviderUsageChart>>, TError = unknown>(
 params?: UsageControllerGetProviderUsageChartParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usageControllerGetProviderUsageChart>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUsageControllerGetProviderUsageChartQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns usage statistics grouped by individual models with percentage distribution. Dates are optional - if not provided, shows all usage.
 * @summary Get usage distribution by model
 */
export const usageControllerGetModelDistribution = (
    params?: UsageControllerGetModelDistributionParams,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<ModelDistributionResponseDto>(
      {url: `/usage/models`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getUsageControllerGetModelDistributionQueryKey = (params?: UsageControllerGetModelDistributionParams,) => {
    return [`/usage/models`, ...(params ? [params]: [])] as const;
    }

    
export const getUsageControllerGetModelDistributionQueryOptions = <TData = Awaited<ReturnType<typeof usageControllerGetModelDistribution>>, TError = unknown>(params?: UsageControllerGetModelDistributionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usageControllerGetModelDistribution>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUsageControllerGetModelDistributionQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usageControllerGetModelDistribution>>> = ({ signal }) => usageControllerGetModelDistribution(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usageControllerGetModelDistribution>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UsageControllerGetModelDistributionQueryResult = NonNullable<Awaited<ReturnType<typeof usageControllerGetModelDistribution>>>
export type UsageControllerGetModelDistributionQueryError = unknown


export function useUsageControllerGetModelDistribution<TData = Awaited<ReturnType<typeof usageControllerGetModelDistribution>>, TError = unknown>(
 params: undefined |  UsageControllerGetModelDistributionParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof usageControllerGetModelDistribution>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usageControllerGetModelDistribution>>,
          TError,
          Awaited<ReturnType<typeof usageControllerGetModelDistribution>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsageControllerGetModelDistribution<TData = Awaited<ReturnType<typeof usageControllerGetModelDistribution>>, TError = unknown>(
 params?: UsageControllerGetModelDistributionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usageControllerGetModelDistribution>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usageControllerGetModelDistribution>>,
          TError,
          Awaited<ReturnType<typeof usageControllerGetModelDistribution>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsageControllerGetModelDistribution<TData = Awaited<ReturnType<typeof usageControllerGetModelDistribution>>, TError = unknown>(
 params?: UsageControllerGetModelDistributionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usageControllerGetModelDistribution>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get usage distribution by model
 */

export function useUsageControllerGetModelDistribution<TData = Awaited<ReturnType<typeof usageControllerGetModelDistribution>>, TError = unknown>(
 params?: UsageControllerGetModelDistributionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usageControllerGetModelDistribution>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUsageControllerGetModelDistributionQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns paginated user usage statistics with search, sorting, and filtering capabilities. Includes activity status. Dates are optional - if not provided, shows all usage.
 * @summary Get usage statistics by user
 */
export const usageControllerGetUserUsage = (
    params?: UsageControllerGetUserUsageParams,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<UserUsageResponseDto>(
      {url: `/usage/users`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getUsageControllerGetUserUsageQueryKey = (params?: UsageControllerGetUserUsageParams,) => {
    return [`/usage/users`, ...(params ? [params]: [])] as const;
    }

    
export const getUsageControllerGetUserUsageQueryOptions = <TData = Awaited<ReturnType<typeof usageControllerGetUserUsage>>, TError = unknown>(params?: UsageControllerGetUserUsageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usageControllerGetUserUsage>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUsageControllerGetUserUsageQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usageControllerGetUserUsage>>> = ({ signal }) => usageControllerGetUserUsage(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usageControllerGetUserUsage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UsageControllerGetUserUsageQueryResult = NonNullable<Awaited<ReturnType<typeof usageControllerGetUserUsage>>>
export type UsageControllerGetUserUsageQueryError = unknown


export function useUsageControllerGetUserUsage<TData = Awaited<ReturnType<typeof usageControllerGetUserUsage>>, TError = unknown>(
 params: undefined |  UsageControllerGetUserUsageParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof usageControllerGetUserUsage>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usageControllerGetUserUsage>>,
          TError,
          Awaited<ReturnType<typeof usageControllerGetUserUsage>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsageControllerGetUserUsage<TData = Awaited<ReturnType<typeof usageControllerGetUserUsage>>, TError = unknown>(
 params?: UsageControllerGetUserUsageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usageControllerGetUserUsage>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usageControllerGetUserUsage>>,
          TError,
          Awaited<ReturnType<typeof usageControllerGetUserUsage>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsageControllerGetUserUsage<TData = Awaited<ReturnType<typeof usageControllerGetUserUsage>>, TError = unknown>(
 params?: UsageControllerGetUserUsageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usageControllerGetUserUsage>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get usage statistics by user
 */

export function useUsageControllerGetUserUsage<TData = Awaited<ReturnType<typeof usageControllerGetUserUsage>>, TError = unknown>(
 params?: UsageControllerGetUserUsageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usageControllerGetUserUsage>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUsageControllerGetUserUsageQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get usage dashboard configuration for an organization
 */
export const superAdminUsageControllerGetUsageConfig = (
    orgId: unknown,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<UsageConfigResponseDto>(
      {url: `/super-admin/usage/${orgId}/config`, method: 'GET', signal
    },
      );
    }
  

export const getSuperAdminUsageControllerGetUsageConfigQueryKey = (orgId: unknown,) => {
    return [`/super-admin/usage/${orgId}/config`] as const;
    }

    
export const getSuperAdminUsageControllerGetUsageConfigQueryOptions = <TData = Awaited<ReturnType<typeof superAdminUsageControllerGetUsageConfig>>, TError = unknown>(orgId: unknown, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminUsageControllerGetUsageConfig>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSuperAdminUsageControllerGetUsageConfigQueryKey(orgId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof superAdminUsageControllerGetUsageConfig>>> = ({ signal }) => superAdminUsageControllerGetUsageConfig(orgId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orgId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof superAdminUsageControllerGetUsageConfig>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SuperAdminUsageControllerGetUsageConfigQueryResult = NonNullable<Awaited<ReturnType<typeof superAdminUsageControllerGetUsageConfig>>>
export type SuperAdminUsageControllerGetUsageConfigQueryError = unknown


export function useSuperAdminUsageControllerGetUsageConfig<TData = Awaited<ReturnType<typeof superAdminUsageControllerGetUsageConfig>>, TError = unknown>(
 orgId: unknown, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminUsageControllerGetUsageConfig>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof superAdminUsageControllerGetUsageConfig>>,
          TError,
          Awaited<ReturnType<typeof superAdminUsageControllerGetUsageConfig>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSuperAdminUsageControllerGetUsageConfig<TData = Awaited<ReturnType<typeof superAdminUsageControllerGetUsageConfig>>, TError = unknown>(
 orgId: unknown, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminUsageControllerGetUsageConfig>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof superAdminUsageControllerGetUsageConfig>>,
          TError,
          Awaited<ReturnType<typeof superAdminUsageControllerGetUsageConfig>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSuperAdminUsageControllerGetUsageConfig<TData = Awaited<ReturnType<typeof superAdminUsageControllerGetUsageConfig>>, TError = unknown>(
 orgId: unknown, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminUsageControllerGetUsageConfig>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get usage dashboard configuration for an organization
 */

export function useSuperAdminUsageControllerGetUsageConfig<TData = Awaited<ReturnType<typeof superAdminUsageControllerGetUsageConfig>>, TError = unknown>(
 orgId: unknown, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminUsageControllerGetUsageConfig>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSuperAdminUsageControllerGetUsageConfigQueryOptions(orgId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get overall usage statistics for an organization
 */
export const superAdminUsageControllerGetUsageStats = (
    orgId: string,
    params?: SuperAdminUsageControllerGetUsageStatsParams,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<UsageStatsResponseDto>(
      {url: `/super-admin/usage/${orgId}/stats`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getSuperAdminUsageControllerGetUsageStatsQueryKey = (orgId: string,
    params?: SuperAdminUsageControllerGetUsageStatsParams,) => {
    return [`/super-admin/usage/${orgId}/stats`, ...(params ? [params]: [])] as const;
    }

    
export const getSuperAdminUsageControllerGetUsageStatsQueryOptions = <TData = Awaited<ReturnType<typeof superAdminUsageControllerGetUsageStats>>, TError = unknown>(orgId: string,
    params?: SuperAdminUsageControllerGetUsageStatsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminUsageControllerGetUsageStats>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSuperAdminUsageControllerGetUsageStatsQueryKey(orgId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof superAdminUsageControllerGetUsageStats>>> = ({ signal }) => superAdminUsageControllerGetUsageStats(orgId,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orgId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof superAdminUsageControllerGetUsageStats>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SuperAdminUsageControllerGetUsageStatsQueryResult = NonNullable<Awaited<ReturnType<typeof superAdminUsageControllerGetUsageStats>>>
export type SuperAdminUsageControllerGetUsageStatsQueryError = unknown


export function useSuperAdminUsageControllerGetUsageStats<TData = Awaited<ReturnType<typeof superAdminUsageControllerGetUsageStats>>, TError = unknown>(
 orgId: string,
    params: undefined |  SuperAdminUsageControllerGetUsageStatsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminUsageControllerGetUsageStats>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof superAdminUsageControllerGetUsageStats>>,
          TError,
          Awaited<ReturnType<typeof superAdminUsageControllerGetUsageStats>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSuperAdminUsageControllerGetUsageStats<TData = Awaited<ReturnType<typeof superAdminUsageControllerGetUsageStats>>, TError = unknown>(
 orgId: string,
    params?: SuperAdminUsageControllerGetUsageStatsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminUsageControllerGetUsageStats>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof superAdminUsageControllerGetUsageStats>>,
          TError,
          Awaited<ReturnType<typeof superAdminUsageControllerGetUsageStats>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSuperAdminUsageControllerGetUsageStats<TData = Awaited<ReturnType<typeof superAdminUsageControllerGetUsageStats>>, TError = unknown>(
 orgId: string,
    params?: SuperAdminUsageControllerGetUsageStatsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminUsageControllerGetUsageStats>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get overall usage statistics for an organization
 */

export function useSuperAdminUsageControllerGetUsageStats<TData = Awaited<ReturnType<typeof superAdminUsageControllerGetUsageStats>>, TError = unknown>(
 orgId: string,
    params?: SuperAdminUsageControllerGetUsageStatsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminUsageControllerGetUsageStats>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSuperAdminUsageControllerGetUsageStatsQueryOptions(orgId,params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get usage distribution by model for an organization
 */
export const superAdminUsageControllerGetModelDistribution = (
    orgId: string,
    params?: SuperAdminUsageControllerGetModelDistributionParams,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<ModelDistributionResponseDto>(
      {url: `/super-admin/usage/${orgId}/models`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getSuperAdminUsageControllerGetModelDistributionQueryKey = (orgId: string,
    params?: SuperAdminUsageControllerGetModelDistributionParams,) => {
    return [`/super-admin/usage/${orgId}/models`, ...(params ? [params]: [])] as const;
    }

    
export const getSuperAdminUsageControllerGetModelDistributionQueryOptions = <TData = Awaited<ReturnType<typeof superAdminUsageControllerGetModelDistribution>>, TError = unknown>(orgId: string,
    params?: SuperAdminUsageControllerGetModelDistributionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminUsageControllerGetModelDistribution>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSuperAdminUsageControllerGetModelDistributionQueryKey(orgId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof superAdminUsageControllerGetModelDistribution>>> = ({ signal }) => superAdminUsageControllerGetModelDistribution(orgId,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orgId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof superAdminUsageControllerGetModelDistribution>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SuperAdminUsageControllerGetModelDistributionQueryResult = NonNullable<Awaited<ReturnType<typeof superAdminUsageControllerGetModelDistribution>>>
export type SuperAdminUsageControllerGetModelDistributionQueryError = unknown


export function useSuperAdminUsageControllerGetModelDistribution<TData = Awaited<ReturnType<typeof superAdminUsageControllerGetModelDistribution>>, TError = unknown>(
 orgId: string,
    params: undefined |  SuperAdminUsageControllerGetModelDistributionParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminUsageControllerGetModelDistribution>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof superAdminUsageControllerGetModelDistribution>>,
          TError,
          Awaited<ReturnType<typeof superAdminUsageControllerGetModelDistribution>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSuperAdminUsageControllerGetModelDistribution<TData = Awaited<ReturnType<typeof superAdminUsageControllerGetModelDistribution>>, TError = unknown>(
 orgId: string,
    params?: SuperAdminUsageControllerGetModelDistributionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminUsageControllerGetModelDistribution>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof superAdminUsageControllerGetModelDistribution>>,
          TError,
          Awaited<ReturnType<typeof superAdminUsageControllerGetModelDistribution>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSuperAdminUsageControllerGetModelDistribution<TData = Awaited<ReturnType<typeof superAdminUsageControllerGetModelDistribution>>, TError = unknown>(
 orgId: string,
    params?: SuperAdminUsageControllerGetModelDistributionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminUsageControllerGetModelDistribution>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get usage distribution by model for an organization
 */

export function useSuperAdminUsageControllerGetModelDistribution<TData = Awaited<ReturnType<typeof superAdminUsageControllerGetModelDistribution>>, TError = unknown>(
 orgId: string,
    params?: SuperAdminUsageControllerGetModelDistributionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminUsageControllerGetModelDistribution>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSuperAdminUsageControllerGetModelDistributionQueryOptions(orgId,params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get usage statistics by provider for an organization
 */
export const superAdminUsageDataControllerGetProviderUsage = (
    orgId: string,
    params?: SuperAdminUsageDataControllerGetProviderUsageParams,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<ProviderUsageResponseDto>(
      {url: `/super-admin/usage/${orgId}/providers`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getSuperAdminUsageDataControllerGetProviderUsageQueryKey = (orgId: string,
    params?: SuperAdminUsageDataControllerGetProviderUsageParams,) => {
    return [`/super-admin/usage/${orgId}/providers`, ...(params ? [params]: [])] as const;
    }

    
export const getSuperAdminUsageDataControllerGetProviderUsageQueryOptions = <TData = Awaited<ReturnType<typeof superAdminUsageDataControllerGetProviderUsage>>, TError = unknown>(orgId: string,
    params?: SuperAdminUsageDataControllerGetProviderUsageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminUsageDataControllerGetProviderUsage>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSuperAdminUsageDataControllerGetProviderUsageQueryKey(orgId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof superAdminUsageDataControllerGetProviderUsage>>> = ({ signal }) => superAdminUsageDataControllerGetProviderUsage(orgId,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orgId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof superAdminUsageDataControllerGetProviderUsage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SuperAdminUsageDataControllerGetProviderUsageQueryResult = NonNullable<Awaited<ReturnType<typeof superAdminUsageDataControllerGetProviderUsage>>>
export type SuperAdminUsageDataControllerGetProviderUsageQueryError = unknown


export function useSuperAdminUsageDataControllerGetProviderUsage<TData = Awaited<ReturnType<typeof superAdminUsageDataControllerGetProviderUsage>>, TError = unknown>(
 orgId: string,
    params: undefined |  SuperAdminUsageDataControllerGetProviderUsageParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminUsageDataControllerGetProviderUsage>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof superAdminUsageDataControllerGetProviderUsage>>,
          TError,
          Awaited<ReturnType<typeof superAdminUsageDataControllerGetProviderUsage>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSuperAdminUsageDataControllerGetProviderUsage<TData = Awaited<ReturnType<typeof superAdminUsageDataControllerGetProviderUsage>>, TError = unknown>(
 orgId: string,
    params?: SuperAdminUsageDataControllerGetProviderUsageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminUsageDataControllerGetProviderUsage>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof superAdminUsageDataControllerGetProviderUsage>>,
          TError,
          Awaited<ReturnType<typeof superAdminUsageDataControllerGetProviderUsage>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSuperAdminUsageDataControllerGetProviderUsage<TData = Awaited<ReturnType<typeof superAdminUsageDataControllerGetProviderUsage>>, TError = unknown>(
 orgId: string,
    params?: SuperAdminUsageDataControllerGetProviderUsageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminUsageDataControllerGetProviderUsage>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get usage statistics by provider for an organization
 */

export function useSuperAdminUsageDataControllerGetProviderUsage<TData = Awaited<ReturnType<typeof superAdminUsageDataControllerGetProviderUsage>>, TError = unknown>(
 orgId: string,
    params?: SuperAdminUsageDataControllerGetProviderUsageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminUsageDataControllerGetProviderUsage>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSuperAdminUsageDataControllerGetProviderUsageQueryOptions(orgId,params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get provider usage time series for an organization (chart-ready)
 */
export const superAdminUsageDataControllerGetProviderUsageChart = (
    orgId: string,
    params?: SuperAdminUsageDataControllerGetProviderUsageChartParams,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<ProviderUsageChartResponseDto>(
      {url: `/super-admin/usage/${orgId}/providers/chart`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getSuperAdminUsageDataControllerGetProviderUsageChartQueryKey = (orgId: string,
    params?: SuperAdminUsageDataControllerGetProviderUsageChartParams,) => {
    return [`/super-admin/usage/${orgId}/providers/chart`, ...(params ? [params]: [])] as const;
    }

    
export const getSuperAdminUsageDataControllerGetProviderUsageChartQueryOptions = <TData = Awaited<ReturnType<typeof superAdminUsageDataControllerGetProviderUsageChart>>, TError = unknown>(orgId: string,
    params?: SuperAdminUsageDataControllerGetProviderUsageChartParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminUsageDataControllerGetProviderUsageChart>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSuperAdminUsageDataControllerGetProviderUsageChartQueryKey(orgId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof superAdminUsageDataControllerGetProviderUsageChart>>> = ({ signal }) => superAdminUsageDataControllerGetProviderUsageChart(orgId,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orgId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof superAdminUsageDataControllerGetProviderUsageChart>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SuperAdminUsageDataControllerGetProviderUsageChartQueryResult = NonNullable<Awaited<ReturnType<typeof superAdminUsageDataControllerGetProviderUsageChart>>>
export type SuperAdminUsageDataControllerGetProviderUsageChartQueryError = unknown


export function useSuperAdminUsageDataControllerGetProviderUsageChart<TData = Awaited<ReturnType<typeof superAdminUsageDataControllerGetProviderUsageChart>>, TError = unknown>(
 orgId: string,
    params: undefined |  SuperAdminUsageDataControllerGetProviderUsageChartParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminUsageDataControllerGetProviderUsageChart>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof superAdminUsageDataControllerGetProviderUsageChart>>,
          TError,
          Awaited<ReturnType<typeof superAdminUsageDataControllerGetProviderUsageChart>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSuperAdminUsageDataControllerGetProviderUsageChart<TData = Awaited<ReturnType<typeof superAdminUsageDataControllerGetProviderUsageChart>>, TError = unknown>(
 orgId: string,
    params?: SuperAdminUsageDataControllerGetProviderUsageChartParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminUsageDataControllerGetProviderUsageChart>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof superAdminUsageDataControllerGetProviderUsageChart>>,
          TError,
          Awaited<ReturnType<typeof superAdminUsageDataControllerGetProviderUsageChart>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSuperAdminUsageDataControllerGetProviderUsageChart<TData = Awaited<ReturnType<typeof superAdminUsageDataControllerGetProviderUsageChart>>, TError = unknown>(
 orgId: string,
    params?: SuperAdminUsageDataControllerGetProviderUsageChartParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminUsageDataControllerGetProviderUsageChart>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get provider usage time series for an organization (chart-ready)
 */

export function useSuperAdminUsageDataControllerGetProviderUsageChart<TData = Awaited<ReturnType<typeof superAdminUsageDataControllerGetProviderUsageChart>>, TError = unknown>(
 orgId: string,
    params?: SuperAdminUsageDataControllerGetProviderUsageChartParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminUsageDataControllerGetProviderUsageChart>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSuperAdminUsageDataControllerGetProviderUsageChartQueryOptions(orgId,params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get usage statistics by user for an organization
 */
export const superAdminUsageDataControllerGetUserUsage = (
    orgId: string,
    params?: SuperAdminUsageDataControllerGetUserUsageParams,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<UserUsageResponseDto>(
      {url: `/super-admin/usage/${orgId}/users`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getSuperAdminUsageDataControllerGetUserUsageQueryKey = (orgId: string,
    params?: SuperAdminUsageDataControllerGetUserUsageParams,) => {
    return [`/super-admin/usage/${orgId}/users`, ...(params ? [params]: [])] as const;
    }

    
export const getSuperAdminUsageDataControllerGetUserUsageQueryOptions = <TData = Awaited<ReturnType<typeof superAdminUsageDataControllerGetUserUsage>>, TError = unknown>(orgId: string,
    params?: SuperAdminUsageDataControllerGetUserUsageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminUsageDataControllerGetUserUsage>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSuperAdminUsageDataControllerGetUserUsageQueryKey(orgId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof superAdminUsageDataControllerGetUserUsage>>> = ({ signal }) => superAdminUsageDataControllerGetUserUsage(orgId,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orgId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof superAdminUsageDataControllerGetUserUsage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SuperAdminUsageDataControllerGetUserUsageQueryResult = NonNullable<Awaited<ReturnType<typeof superAdminUsageDataControllerGetUserUsage>>>
export type SuperAdminUsageDataControllerGetUserUsageQueryError = unknown


export function useSuperAdminUsageDataControllerGetUserUsage<TData = Awaited<ReturnType<typeof superAdminUsageDataControllerGetUserUsage>>, TError = unknown>(
 orgId: string,
    params: undefined |  SuperAdminUsageDataControllerGetUserUsageParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminUsageDataControllerGetUserUsage>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof superAdminUsageDataControllerGetUserUsage>>,
          TError,
          Awaited<ReturnType<typeof superAdminUsageDataControllerGetUserUsage>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSuperAdminUsageDataControllerGetUserUsage<TData = Awaited<ReturnType<typeof superAdminUsageDataControllerGetUserUsage>>, TError = unknown>(
 orgId: string,
    params?: SuperAdminUsageDataControllerGetUserUsageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminUsageDataControllerGetUserUsage>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof superAdminUsageDataControllerGetUserUsage>>,
          TError,
          Awaited<ReturnType<typeof superAdminUsageDataControllerGetUserUsage>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSuperAdminUsageDataControllerGetUserUsage<TData = Awaited<ReturnType<typeof superAdminUsageDataControllerGetUserUsage>>, TError = unknown>(
 orgId: string,
    params?: SuperAdminUsageDataControllerGetUserUsageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminUsageDataControllerGetUserUsage>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get usage statistics by user for an organization
 */

export function useSuperAdminUsageDataControllerGetUserUsage<TData = Awaited<ReturnType<typeof superAdminUsageDataControllerGetUserUsage>>, TError = unknown>(
 orgId: string,
    params?: SuperAdminUsageDataControllerGetUserUsageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminUsageDataControllerGetUserUsage>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSuperAdminUsageDataControllerGetUserUsageQueryOptions(orgId,params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get global provider usage time series across all organizations (chart-ready)
 */
export const superAdminGlobalUsageControllerGetGlobalProviderUsageChart = (
    params?: SuperAdminGlobalUsageControllerGetGlobalProviderUsageChartParams,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<ProviderUsageChartResponseDto>(
      {url: `/super-admin/global-usage/providers/chart`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getSuperAdminGlobalUsageControllerGetGlobalProviderUsageChartQueryKey = (params?: SuperAdminGlobalUsageControllerGetGlobalProviderUsageChartParams,) => {
    return [`/super-admin/global-usage/providers/chart`, ...(params ? [params]: [])] as const;
    }

    
export const getSuperAdminGlobalUsageControllerGetGlobalProviderUsageChartQueryOptions = <TData = Awaited<ReturnType<typeof superAdminGlobalUsageControllerGetGlobalProviderUsageChart>>, TError = unknown>(params?: SuperAdminGlobalUsageControllerGetGlobalProviderUsageChartParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminGlobalUsageControllerGetGlobalProviderUsageChart>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSuperAdminGlobalUsageControllerGetGlobalProviderUsageChartQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof superAdminGlobalUsageControllerGetGlobalProviderUsageChart>>> = ({ signal }) => superAdminGlobalUsageControllerGetGlobalProviderUsageChart(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof superAdminGlobalUsageControllerGetGlobalProviderUsageChart>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SuperAdminGlobalUsageControllerGetGlobalProviderUsageChartQueryResult = NonNullable<Awaited<ReturnType<typeof superAdminGlobalUsageControllerGetGlobalProviderUsageChart>>>
export type SuperAdminGlobalUsageControllerGetGlobalProviderUsageChartQueryError = unknown


export function useSuperAdminGlobalUsageControllerGetGlobalProviderUsageChart<TData = Awaited<ReturnType<typeof superAdminGlobalUsageControllerGetGlobalProviderUsageChart>>, TError = unknown>(
 params: undefined |  SuperAdminGlobalUsageControllerGetGlobalProviderUsageChartParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminGlobalUsageControllerGetGlobalProviderUsageChart>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof superAdminGlobalUsageControllerGetGlobalProviderUsageChart>>,
          TError,
          Awaited<ReturnType<typeof superAdminGlobalUsageControllerGetGlobalProviderUsageChart>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSuperAdminGlobalUsageControllerGetGlobalProviderUsageChart<TData = Awaited<ReturnType<typeof superAdminGlobalUsageControllerGetGlobalProviderUsageChart>>, TError = unknown>(
 params?: SuperAdminGlobalUsageControllerGetGlobalProviderUsageChartParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminGlobalUsageControllerGetGlobalProviderUsageChart>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof superAdminGlobalUsageControllerGetGlobalProviderUsageChart>>,
          TError,
          Awaited<ReturnType<typeof superAdminGlobalUsageControllerGetGlobalProviderUsageChart>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSuperAdminGlobalUsageControllerGetGlobalProviderUsageChart<TData = Awaited<ReturnType<typeof superAdminGlobalUsageControllerGetGlobalProviderUsageChart>>, TError = unknown>(
 params?: SuperAdminGlobalUsageControllerGetGlobalProviderUsageChartParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminGlobalUsageControllerGetGlobalProviderUsageChart>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get global provider usage time series across all organizations (chart-ready)
 */

export function useSuperAdminGlobalUsageControllerGetGlobalProviderUsageChart<TData = Awaited<ReturnType<typeof superAdminGlobalUsageControllerGetGlobalProviderUsageChart>>, TError = unknown>(
 params?: SuperAdminGlobalUsageControllerGetGlobalProviderUsageChartParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminGlobalUsageControllerGetGlobalProviderUsageChart>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSuperAdminGlobalUsageControllerGetGlobalProviderUsageChartQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get global model distribution across all organizations
 */
export const superAdminGlobalUsageControllerGetGlobalModelDistribution = (
    params?: SuperAdminGlobalUsageControllerGetGlobalModelDistributionParams,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<ModelDistributionResponseDto>(
      {url: `/super-admin/global-usage/models`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getSuperAdminGlobalUsageControllerGetGlobalModelDistributionQueryKey = (params?: SuperAdminGlobalUsageControllerGetGlobalModelDistributionParams,) => {
    return [`/super-admin/global-usage/models`, ...(params ? [params]: [])] as const;
    }

    
export const getSuperAdminGlobalUsageControllerGetGlobalModelDistributionQueryOptions = <TData = Awaited<ReturnType<typeof superAdminGlobalUsageControllerGetGlobalModelDistribution>>, TError = unknown>(params?: SuperAdminGlobalUsageControllerGetGlobalModelDistributionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminGlobalUsageControllerGetGlobalModelDistribution>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSuperAdminGlobalUsageControllerGetGlobalModelDistributionQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof superAdminGlobalUsageControllerGetGlobalModelDistribution>>> = ({ signal }) => superAdminGlobalUsageControllerGetGlobalModelDistribution(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof superAdminGlobalUsageControllerGetGlobalModelDistribution>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SuperAdminGlobalUsageControllerGetGlobalModelDistributionQueryResult = NonNullable<Awaited<ReturnType<typeof superAdminGlobalUsageControllerGetGlobalModelDistribution>>>
export type SuperAdminGlobalUsageControllerGetGlobalModelDistributionQueryError = unknown


export function useSuperAdminGlobalUsageControllerGetGlobalModelDistribution<TData = Awaited<ReturnType<typeof superAdminGlobalUsageControllerGetGlobalModelDistribution>>, TError = unknown>(
 params: undefined |  SuperAdminGlobalUsageControllerGetGlobalModelDistributionParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminGlobalUsageControllerGetGlobalModelDistribution>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof superAdminGlobalUsageControllerGetGlobalModelDistribution>>,
          TError,
          Awaited<ReturnType<typeof superAdminGlobalUsageControllerGetGlobalModelDistribution>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSuperAdminGlobalUsageControllerGetGlobalModelDistribution<TData = Awaited<ReturnType<typeof superAdminGlobalUsageControllerGetGlobalModelDistribution>>, TError = unknown>(
 params?: SuperAdminGlobalUsageControllerGetGlobalModelDistributionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminGlobalUsageControllerGetGlobalModelDistribution>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof superAdminGlobalUsageControllerGetGlobalModelDistribution>>,
          TError,
          Awaited<ReturnType<typeof superAdminGlobalUsageControllerGetGlobalModelDistribution>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSuperAdminGlobalUsageControllerGetGlobalModelDistribution<TData = Awaited<ReturnType<typeof superAdminGlobalUsageControllerGetGlobalModelDistribution>>, TError = unknown>(
 params?: SuperAdminGlobalUsageControllerGetGlobalModelDistributionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminGlobalUsageControllerGetGlobalModelDistribution>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get global model distribution across all organizations
 */

export function useSuperAdminGlobalUsageControllerGetGlobalModelDistribution<TData = Awaited<ReturnType<typeof superAdminGlobalUsageControllerGetGlobalModelDistribution>>, TError = unknown>(
 params?: SuperAdminGlobalUsageControllerGetGlobalModelDistributionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof superAdminGlobalUsageControllerGetGlobalModelDistribution>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSuperAdminGlobalUsageControllerGetGlobalModelDistributionQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a new prompt
 */
export const promptsControllerCreate = (
    createPromptDto: CreatePromptDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<PromptResponseDto>(
      {url: `/prompts`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createPromptDto, signal
    },
      );
    }
  


export const getPromptsControllerCreateMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof promptsControllerCreate>>, TError,{data: CreatePromptDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof promptsControllerCreate>>, TError,{data: CreatePromptDto}, TContext> => {

const mutationKey = ['promptsControllerCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof promptsControllerCreate>>, {data: CreatePromptDto}> = (props) => {
          const {data} = props ?? {};

          return  promptsControllerCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PromptsControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof promptsControllerCreate>>>
    export type PromptsControllerCreateMutationBody = CreatePromptDto
    export type PromptsControllerCreateMutationError = void

    /**
 * @summary Create a new prompt
 */
export const usePromptsControllerCreate = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof promptsControllerCreate>>, TError,{data: CreatePromptDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof promptsControllerCreate>>,
        TError,
        {data: CreatePromptDto},
        TContext
      > => {

      const mutationOptions = getPromptsControllerCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get all prompts for the current user
 */
export const promptsControllerFindAll = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<PromptResponseDto[]>(
      {url: `/prompts`, method: 'GET', signal
    },
      );
    }
  

export const getPromptsControllerFindAllQueryKey = () => {
    return [`/prompts`] as const;
    }

    
export const getPromptsControllerFindAllQueryOptions = <TData = Awaited<ReturnType<typeof promptsControllerFindAll>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof promptsControllerFindAll>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPromptsControllerFindAllQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof promptsControllerFindAll>>> = ({ signal }) => promptsControllerFindAll(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof promptsControllerFindAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PromptsControllerFindAllQueryResult = NonNullable<Awaited<ReturnType<typeof promptsControllerFindAll>>>
export type PromptsControllerFindAllQueryError = void


export function usePromptsControllerFindAll<TData = Awaited<ReturnType<typeof promptsControllerFindAll>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof promptsControllerFindAll>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof promptsControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof promptsControllerFindAll>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePromptsControllerFindAll<TData = Awaited<ReturnType<typeof promptsControllerFindAll>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof promptsControllerFindAll>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof promptsControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof promptsControllerFindAll>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePromptsControllerFindAll<TData = Awaited<ReturnType<typeof promptsControllerFindAll>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof promptsControllerFindAll>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all prompts for the current user
 */

export function usePromptsControllerFindAll<TData = Awaited<ReturnType<typeof promptsControllerFindAll>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof promptsControllerFindAll>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPromptsControllerFindAllQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get a prompt by ID
 */
export const promptsControllerFindOne = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<PromptResponseDto>(
      {url: `/prompts/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getPromptsControllerFindOneQueryKey = (id: string,) => {
    return [`/prompts/${id}`] as const;
    }

    
export const getPromptsControllerFindOneQueryOptions = <TData = Awaited<ReturnType<typeof promptsControllerFindOne>>, TError = void>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof promptsControllerFindOne>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPromptsControllerFindOneQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof promptsControllerFindOne>>> = ({ signal }) => promptsControllerFindOne(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof promptsControllerFindOne>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PromptsControllerFindOneQueryResult = NonNullable<Awaited<ReturnType<typeof promptsControllerFindOne>>>
export type PromptsControllerFindOneQueryError = void


export function usePromptsControllerFindOne<TData = Awaited<ReturnType<typeof promptsControllerFindOne>>, TError = void>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof promptsControllerFindOne>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof promptsControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof promptsControllerFindOne>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePromptsControllerFindOne<TData = Awaited<ReturnType<typeof promptsControllerFindOne>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof promptsControllerFindOne>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof promptsControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof promptsControllerFindOne>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePromptsControllerFindOne<TData = Awaited<ReturnType<typeof promptsControllerFindOne>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof promptsControllerFindOne>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a prompt by ID
 */

export function usePromptsControllerFindOne<TData = Awaited<ReturnType<typeof promptsControllerFindOne>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof promptsControllerFindOne>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPromptsControllerFindOneQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update a prompt
 */
export const promptsControllerUpdate = (
    id: string,
    updatePromptDto: UpdatePromptDto,
 ) => {
      
      
      return customAxiosInstance<PromptResponseDto>(
      {url: `/prompts/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updatePromptDto
    },
      );
    }
  


export const getPromptsControllerUpdateMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof promptsControllerUpdate>>, TError,{id: string;data: UpdatePromptDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof promptsControllerUpdate>>, TError,{id: string;data: UpdatePromptDto}, TContext> => {

const mutationKey = ['promptsControllerUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof promptsControllerUpdate>>, {id: string;data: UpdatePromptDto}> = (props) => {
          const {id,data} = props ?? {};

          return  promptsControllerUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PromptsControllerUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof promptsControllerUpdate>>>
    export type PromptsControllerUpdateMutationBody = UpdatePromptDto
    export type PromptsControllerUpdateMutationError = void

    /**
 * @summary Update a prompt
 */
export const usePromptsControllerUpdate = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof promptsControllerUpdate>>, TError,{id: string;data: UpdatePromptDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof promptsControllerUpdate>>,
        TError,
        {id: string;data: UpdatePromptDto},
        TContext
      > => {

      const mutationOptions = getPromptsControllerUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Delete a prompt
 */
export const promptsControllerDelete = (
    id: string,
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/prompts/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getPromptsControllerDeleteMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof promptsControllerDelete>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof promptsControllerDelete>>, TError,{id: string}, TContext> => {

const mutationKey = ['promptsControllerDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof promptsControllerDelete>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  promptsControllerDelete(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PromptsControllerDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof promptsControllerDelete>>>
    
    export type PromptsControllerDeleteMutationError = void

    /**
 * @summary Delete a prompt
 */
export const usePromptsControllerDelete = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof promptsControllerDelete>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof promptsControllerDelete>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getPromptsControllerDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Upload an audio file and receive the transcribed text. Supports webm, mp4, mp3, wav, and m4a formats.
 * @summary Transcribe audio file to text
 */
export const transcriptionsControllerTranscribe = (
    transcriptionsControllerTranscribeBody: TranscriptionsControllerTranscribeBody,
 signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`file`, transcriptionsControllerTranscribeBody.file)
if(transcriptionsControllerTranscribeBody.language !== undefined) {
 formData.append(`language`, transcriptionsControllerTranscribeBody.language)
 }

      return customAxiosInstance<TranscriptionResponseDto>(
      {url: `/transcriptions`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      );
    }
  


export const getTranscriptionsControllerTranscribeMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof transcriptionsControllerTranscribe>>, TError,{data: TranscriptionsControllerTranscribeBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof transcriptionsControllerTranscribe>>, TError,{data: TranscriptionsControllerTranscribeBody}, TContext> => {

const mutationKey = ['transcriptionsControllerTranscribe'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof transcriptionsControllerTranscribe>>, {data: TranscriptionsControllerTranscribeBody}> = (props) => {
          const {data} = props ?? {};

          return  transcriptionsControllerTranscribe(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TranscriptionsControllerTranscribeMutationResult = NonNullable<Awaited<ReturnType<typeof transcriptionsControllerTranscribe>>>
    export type TranscriptionsControllerTranscribeMutationBody = TranscriptionsControllerTranscribeBody
    export type TranscriptionsControllerTranscribeMutationError = void

    /**
 * @summary Transcribe audio file to text
 */
export const useTranscriptionsControllerTranscribe = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof transcriptionsControllerTranscribe>>, TError,{data: TranscriptionsControllerTranscribeBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof transcriptionsControllerTranscribe>>,
        TError,
        {data: TranscriptionsControllerTranscribeBody},
        TContext
      > => {

      const mutationOptions = getTranscriptionsControllerTranscribeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Returns the custom system prompt for the authenticated user, or null if not set.
 * @summary Get the user system prompt
 */
export const chatSettingsControllerGetSystemPrompt = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<UserSystemPromptResponseDto>(
      {url: `/chat-settings/system-prompt`, method: 'GET', signal
    },
      );
    }
  

export const getChatSettingsControllerGetSystemPromptQueryKey = () => {
    return [`/chat-settings/system-prompt`] as const;
    }

    
export const getChatSettingsControllerGetSystemPromptQueryOptions = <TData = Awaited<ReturnType<typeof chatSettingsControllerGetSystemPrompt>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof chatSettingsControllerGetSystemPrompt>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getChatSettingsControllerGetSystemPromptQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof chatSettingsControllerGetSystemPrompt>>> = ({ signal }) => chatSettingsControllerGetSystemPrompt(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof chatSettingsControllerGetSystemPrompt>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ChatSettingsControllerGetSystemPromptQueryResult = NonNullable<Awaited<ReturnType<typeof chatSettingsControllerGetSystemPrompt>>>
export type ChatSettingsControllerGetSystemPromptQueryError = unknown


export function useChatSettingsControllerGetSystemPrompt<TData = Awaited<ReturnType<typeof chatSettingsControllerGetSystemPrompt>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof chatSettingsControllerGetSystemPrompt>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof chatSettingsControllerGetSystemPrompt>>,
          TError,
          Awaited<ReturnType<typeof chatSettingsControllerGetSystemPrompt>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useChatSettingsControllerGetSystemPrompt<TData = Awaited<ReturnType<typeof chatSettingsControllerGetSystemPrompt>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof chatSettingsControllerGetSystemPrompt>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof chatSettingsControllerGetSystemPrompt>>,
          TError,
          Awaited<ReturnType<typeof chatSettingsControllerGetSystemPrompt>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useChatSettingsControllerGetSystemPrompt<TData = Awaited<ReturnType<typeof chatSettingsControllerGetSystemPrompt>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof chatSettingsControllerGetSystemPrompt>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get the user system prompt
 */

export function useChatSettingsControllerGetSystemPrompt<TData = Awaited<ReturnType<typeof chatSettingsControllerGetSystemPrompt>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof chatSettingsControllerGetSystemPrompt>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getChatSettingsControllerGetSystemPromptQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Creates or replaces the custom system prompt for the authenticated user.
 * @summary Set or update the user system prompt
 */
export const chatSettingsControllerUpsertSystemPrompt = (
    upsertUserSystemPromptDto: UpsertUserSystemPromptDto,
 ) => {
      
      
      return customAxiosInstance<UserSystemPromptResponseDto>(
      {url: `/chat-settings/system-prompt`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: upsertUserSystemPromptDto
    },
      );
    }
  


export const getChatSettingsControllerUpsertSystemPromptMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof chatSettingsControllerUpsertSystemPrompt>>, TError,{data: UpsertUserSystemPromptDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof chatSettingsControllerUpsertSystemPrompt>>, TError,{data: UpsertUserSystemPromptDto}, TContext> => {

const mutationKey = ['chatSettingsControllerUpsertSystemPrompt'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof chatSettingsControllerUpsertSystemPrompt>>, {data: UpsertUserSystemPromptDto}> = (props) => {
          const {data} = props ?? {};

          return  chatSettingsControllerUpsertSystemPrompt(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ChatSettingsControllerUpsertSystemPromptMutationResult = NonNullable<Awaited<ReturnType<typeof chatSettingsControllerUpsertSystemPrompt>>>
    export type ChatSettingsControllerUpsertSystemPromptMutationBody = UpsertUserSystemPromptDto
    export type ChatSettingsControllerUpsertSystemPromptMutationError = void

    /**
 * @summary Set or update the user system prompt
 */
export const useChatSettingsControllerUpsertSystemPrompt = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof chatSettingsControllerUpsertSystemPrompt>>, TError,{data: UpsertUserSystemPromptDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof chatSettingsControllerUpsertSystemPrompt>>,
        TError,
        {data: UpsertUserSystemPromptDto},
        TContext
      > => {

      const mutationOptions = getChatSettingsControllerUpsertSystemPromptMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Deletes the custom system prompt for the authenticated user.
 * @summary Delete the user system prompt
 */
export const chatSettingsControllerDeleteSystemPrompt = (
    
 ) => {
      
      
      return customAxiosInstance<void>(
      {url: `/chat-settings/system-prompt`, method: 'DELETE'
    },
      );
    }
  


export const getChatSettingsControllerDeleteSystemPromptMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof chatSettingsControllerDeleteSystemPrompt>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof chatSettingsControllerDeleteSystemPrompt>>, TError,void, TContext> => {

const mutationKey = ['chatSettingsControllerDeleteSystemPrompt'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof chatSettingsControllerDeleteSystemPrompt>>, void> = () => {
          

          return  chatSettingsControllerDeleteSystemPrompt()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ChatSettingsControllerDeleteSystemPromptMutationResult = NonNullable<Awaited<ReturnType<typeof chatSettingsControllerDeleteSystemPrompt>>>
    
    export type ChatSettingsControllerDeleteSystemPromptMutationError = unknown

    /**
 * @summary Delete the user system prompt
 */
export const useChatSettingsControllerDeleteSystemPrompt = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof chatSettingsControllerDeleteSystemPrompt>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof chatSettingsControllerDeleteSystemPrompt>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getChatSettingsControllerDeleteSystemPromptMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Authenticate user with email and password. Sets authentication cookies on successful login.
 * @summary User login
 */
export const authenticationControllerLogin = (
    loginDto: LoginDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<SuccessResponseDto>(
      {url: `/auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: loginDto, signal
    },
      );
    }
  


export const getAuthenticationControllerLoginMutationOptions = <TError = ErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticationControllerLogin>>, TError,{data: LoginDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof authenticationControllerLogin>>, TError,{data: LoginDto}, TContext> => {

const mutationKey = ['authenticationControllerLogin'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authenticationControllerLogin>>, {data: LoginDto}> = (props) => {
          const {data} = props ?? {};

          return  authenticationControllerLogin(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthenticationControllerLoginMutationResult = NonNullable<Awaited<ReturnType<typeof authenticationControllerLogin>>>
    export type AuthenticationControllerLoginMutationBody = LoginDto
    export type AuthenticationControllerLoginMutationError = ErrorResponseDto

    /**
 * @summary User login
 */
export const useAuthenticationControllerLogin = <TError = ErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticationControllerLogin>>, TError,{data: LoginDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authenticationControllerLogin>>,
        TError,
        {data: LoginDto},
        TContext
      > => {

      const mutationOptions = getAuthenticationControllerLoginMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Register a new user account with email, password, and organization name. Automatically logs in the user and sets authentication cookies.
 * @summary User registration
 */
export const authenticationControllerRegister = (
    registerDto: RegisterDto,
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<SuccessResponseDto>(
      {url: `/auth/register`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: registerDto, signal
    },
      );
    }
  


export const getAuthenticationControllerRegisterMutationOptions = <TError = ErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticationControllerRegister>>, TError,{data: RegisterDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof authenticationControllerRegister>>, TError,{data: RegisterDto}, TContext> => {

const mutationKey = ['authenticationControllerRegister'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authenticationControllerRegister>>, {data: RegisterDto}> = (props) => {
          const {data} = props ?? {};

          return  authenticationControllerRegister(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthenticationControllerRegisterMutationResult = NonNullable<Awaited<ReturnType<typeof authenticationControllerRegister>>>
    export type AuthenticationControllerRegisterMutationBody = RegisterDto
    export type AuthenticationControllerRegisterMutationError = ErrorResponseDto

    /**
 * @summary User registration
 */
export const useAuthenticationControllerRegister = <TError = ErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticationControllerRegister>>, TError,{data: RegisterDto}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authenticationControllerRegister>>,
        TError,
        {data: RegisterDto},
        TContext
      > => {

      const mutationOptions = getAuthenticationControllerRegisterMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Refresh expired access tokens using the refresh token stored in cookies. Returns new authentication cookies.
 * @summary Refresh authentication tokens
 */
export const authenticationControllerRefresh = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<SuccessResponseDto>(
      {url: `/auth/refresh`, method: 'POST', signal
    },
      );
    }
  


export const getAuthenticationControllerRefreshMutationOptions = <TError = ErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticationControllerRefresh>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof authenticationControllerRefresh>>, TError,void, TContext> => {

const mutationKey = ['authenticationControllerRefresh'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authenticationControllerRefresh>>, void> = () => {
          

          return  authenticationControllerRefresh()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthenticationControllerRefreshMutationResult = NonNullable<Awaited<ReturnType<typeof authenticationControllerRefresh>>>
    
    export type AuthenticationControllerRefreshMutationError = ErrorResponseDto

    /**
 * @summary Refresh authentication tokens
 */
export const useAuthenticationControllerRefresh = <TError = ErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticationControllerRefresh>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authenticationControllerRefresh>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getAuthenticationControllerRefreshMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get the current authenticated user's email and role. If access token is expired but refresh token is valid, automatically refreshes tokens and sets new cookies.
 * @summary Get current user information
 */
export const authenticationControllerMe = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<MeResponseDto>(
      {url: `/auth/me`, method: 'GET', signal
    },
      );
    }
  

export const getAuthenticationControllerMeQueryKey = () => {
    return [`/auth/me`] as const;
    }

    
export const getAuthenticationControllerMeQueryOptions = <TData = Awaited<ReturnType<typeof authenticationControllerMe>>, TError = ErrorResponseDto>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authenticationControllerMe>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthenticationControllerMeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authenticationControllerMe>>> = ({ signal }) => authenticationControllerMe(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof authenticationControllerMe>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AuthenticationControllerMeQueryResult = NonNullable<Awaited<ReturnType<typeof authenticationControllerMe>>>
export type AuthenticationControllerMeQueryError = ErrorResponseDto


export function useAuthenticationControllerMe<TData = Awaited<ReturnType<typeof authenticationControllerMe>>, TError = ErrorResponseDto>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof authenticationControllerMe>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authenticationControllerMe>>,
          TError,
          Awaited<ReturnType<typeof authenticationControllerMe>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthenticationControllerMe<TData = Awaited<ReturnType<typeof authenticationControllerMe>>, TError = ErrorResponseDto>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authenticationControllerMe>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authenticationControllerMe>>,
          TError,
          Awaited<ReturnType<typeof authenticationControllerMe>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthenticationControllerMe<TData = Awaited<ReturnType<typeof authenticationControllerMe>>, TError = ErrorResponseDto>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authenticationControllerMe>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get current user information
 */

export function useAuthenticationControllerMe<TData = Awaited<ReturnType<typeof authenticationControllerMe>>, TError = ErrorResponseDto>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authenticationControllerMe>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAuthenticationControllerMeQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Log out the current user by clearing authentication cookies.
 * @summary User logout
 */
export const authenticationControllerLogout = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxiosInstance<SuccessResponseDto>(
      {url: `/auth/logout`, method: 'POST', signal
    },
      );
    }
  


export const getAuthenticationControllerLogoutMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticationControllerLogout>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof authenticationControllerLogout>>, TError,void, TContext> => {

const mutationKey = ['authenticationControllerLogout'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authenticationControllerLogout>>, void> = () => {
          

          return  authenticationControllerLogout()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthenticationControllerLogoutMutationResult = NonNullable<Awaited<ReturnType<typeof authenticationControllerLogout>>>
    
    export type AuthenticationControllerLogoutMutationError = unknown

    /**
 * @summary User logout
 */
export const useAuthenticationControllerLogout = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticationControllerLogout>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authenticationControllerLogout>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getAuthenticationControllerLogoutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
