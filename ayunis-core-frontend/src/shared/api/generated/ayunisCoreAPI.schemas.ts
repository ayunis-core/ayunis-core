/**
 * Generated by orval v7.21.0 üç∫
 * Do not edit manually.
 * Ayunis Core API
 * The Ayunis Core API description
 * OpenAPI spec version: 1.0
 */
export interface IsCloudResponseDto {
  /** Whether the deployment is running in a cloud environment */
  isCloud: boolean;
  /** Whether new user registration is disabled */
  isRegistrationDisabled: boolean;
}

/**
 * The provider of the model
 */
export type ModelWithConfigResponseDtoProvider = typeof ModelWithConfigResponseDtoProvider[keyof typeof ModelWithConfigResponseDtoProvider];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelWithConfigResponseDtoProvider = {
  openai: 'openai',
  anthropic: 'anthropic',
  bedrock: 'bedrock',
  mistral: 'mistral',
  ollama: 'ollama',
  synaforce: 'synaforce',
  ayunis: 'ayunis',
  otc: 'otc',
  azure: 'azure',
  gemini: 'gemini',
  stackit: 'stackit',
} as const;

export interface ModelWithConfigResponseDto {
  /** The id of the model */
  modelId: string;
  /**
   * The id of the model. Null if the model is not permitted.
   * @nullable
   */
  permittedModelId: string | null;
  /** The name of the model */
  name: string;
  /** The provider of the model */
  provider: ModelWithConfigResponseDtoProvider;
  /** The display name of the model */
  displayName: string;
  /** Whether the model can stream */
  canStream: boolean;
  /** Whether the model can reason */
  isReasoning: boolean;
  /** Whether the model can use tools */
  canUseTools: boolean;
  /** Whether the model supports vision (image processing) */
  canVision: boolean;
  /** Whether the model is permitted to be used */
  isPermitted: boolean;
  /** Whether the model is the default model */
  isDefault: boolean;
  /** Whether the model is an embedding model */
  isEmbedding: boolean;
  /**
   * Whether this model enforces anonymous mode. Null if not permitted.
   * @nullable
   */
  anonymousOnly: boolean | null;
}

/**
 * The model provider identifier
 */
export type ModelProviderInfoResponseDtoProvider = typeof ModelProviderInfoResponseDtoProvider[keyof typeof ModelProviderInfoResponseDtoProvider];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelProviderInfoResponseDtoProvider = {
  openai: 'openai',
  anthropic: 'anthropic',
  bedrock: 'bedrock',
  mistral: 'mistral',
  ollama: 'ollama',
  synaforce: 'synaforce',
  ayunis: 'ayunis',
  otc: 'otc',
  azure: 'azure',
  gemini: 'gemini',
  stackit: 'stackit',
} as const;

/**
 * The location where the provider hosts their services
 */
export type ModelProviderInfoResponseDtoHostedIn = typeof ModelProviderInfoResponseDtoHostedIn[keyof typeof ModelProviderInfoResponseDtoHostedIn];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelProviderInfoResponseDtoHostedIn = {
  DE: 'DE',
  EU: 'EU',
  US: 'US',
  SELF_HOSTED: 'SELF_HOSTED',
  AYUNIS: 'AYUNIS',
} as const;

export interface ModelProviderInfoResponseDto {
  /** The model provider identifier */
  provider: ModelProviderInfoResponseDtoProvider;
  /** The display name of the model provider */
  displayName: string;
  /** The location where the provider hosts their services */
  hostedIn: ModelProviderInfoResponseDtoHostedIn;
}

export interface CreatePermittedModelDto {
  /** The id of the model */
  modelId: string;
  /** Whether this model should enforce anonymous mode */
  anonymousOnly?: boolean;
}

export interface UpdatePermittedModelDto {
  /** Whether this model should enforce anonymous mode */
  anonymousOnly: boolean;
}

/**
 * The provider of the model
 */
export type PermittedLanguageModelResponseDtoProvider = typeof PermittedLanguageModelResponseDtoProvider[keyof typeof PermittedLanguageModelResponseDtoProvider];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PermittedLanguageModelResponseDtoProvider = {
  openai: 'openai',
  anthropic: 'anthropic',
  bedrock: 'bedrock',
  mistral: 'mistral',
  ollama: 'ollama',
  synaforce: 'synaforce',
  ayunis: 'ayunis',
  otc: 'otc',
  azure: 'azure',
  gemini: 'gemini',
  stackit: 'stackit',
} as const;

/**
 * The type of the model (always language)
 */
export type PermittedLanguageModelResponseDtoType = typeof PermittedLanguageModelResponseDtoType[keyof typeof PermittedLanguageModelResponseDtoType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PermittedLanguageModelResponseDtoType = {
  language: 'language',
} as const;

export interface PermittedLanguageModelResponseDto {
  /** The id of the permitted model */
  id: string;
  /** The name of the model */
  name: string;
  /** The provider of the model */
  provider: PermittedLanguageModelResponseDtoProvider;
  /** The display name of the provider */
  providerDisplayName: string;
  /** The display name of the model */
  displayName: string;
  /** The type of the model (always language) */
  type: PermittedLanguageModelResponseDtoType;
  /** Whether the model is archived */
  isArchived: boolean;
  /** Whether the model can stream */
  canStream: boolean;
  /** Whether the model can reason */
  isReasoning: boolean;
  /** Whether the model supports vision (image processing) */
  canVision: boolean;
  /** Whether this model enforces anonymous mode */
  anonymousOnly: boolean;
}

/**
 * The permitted language model
 * @nullable
 */
export type PermittedLanguageModelResponseDtoNullablePermittedLanguageModel = PermittedLanguageModelResponseDto | null;

export interface PermittedLanguageModelResponseDtoNullable {
  /**
   * The permitted language model
   * @nullable
   */
  permittedLanguageModel: PermittedLanguageModelResponseDtoNullablePermittedLanguageModel;
}

export interface SetUserDefaultModelDto {
  /** The ID of the permitted model to set as default */
  permittedModelId: string;
}

export interface SetOrgDefaultModelDto {
  /** The ID of the permitted model to set as organization default */
  permittedModelId: string;
}

export interface EmbeddingModelEnabledResponseDto {
  /** Whether the organization has an embedding model enabled */
  isEmbeddingModelEnabled: boolean;
}

/**
 * The provider of the model
 */
export type PermittedEmbeddingModelResponseDtoProvider = typeof PermittedEmbeddingModelResponseDtoProvider[keyof typeof PermittedEmbeddingModelResponseDtoProvider];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PermittedEmbeddingModelResponseDtoProvider = {
  openai: 'openai',
  anthropic: 'anthropic',
  bedrock: 'bedrock',
  mistral: 'mistral',
  ollama: 'ollama',
  synaforce: 'synaforce',
  ayunis: 'ayunis',
  otc: 'otc',
  azure: 'azure',
  gemini: 'gemini',
  stackit: 'stackit',
} as const;

/**
 * The type of the model (always embedding)
 */
export type PermittedEmbeddingModelResponseDtoType = typeof PermittedEmbeddingModelResponseDtoType[keyof typeof PermittedEmbeddingModelResponseDtoType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PermittedEmbeddingModelResponseDtoType = {
  embedding: 'embedding',
} as const;

export interface PermittedEmbeddingModelResponseDto {
  /** The id of the permitted model */
  id: string;
  /** The name of the model */
  name: string;
  /** The provider of the model */
  provider: PermittedEmbeddingModelResponseDtoProvider;
  /** The display name of the provider */
  providerDisplayName: string;
  /** The display name of the model */
  displayName: string;
  /** The type of the model (always embedding) */
  type: PermittedEmbeddingModelResponseDtoType;
  /** Whether the model is archived */
  isArchived: boolean;
  /**
   * The number of dimensions for embeddings
   * @nullable
   */
  dimensions: number | null;
}

/**
 * The provider of the model
 */
export type CreateLanguageModelRequestDtoProvider = typeof CreateLanguageModelRequestDtoProvider[keyof typeof CreateLanguageModelRequestDtoProvider];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateLanguageModelRequestDtoProvider = {
  openai: 'openai',
  anthropic: 'anthropic',
  bedrock: 'bedrock',
  mistral: 'mistral',
  ollama: 'ollama',
  synaforce: 'synaforce',
  ayunis: 'ayunis',
  otc: 'otc',
  azure: 'azure',
  gemini: 'gemini',
  stackit: 'stackit',
} as const;

export interface CreateLanguageModelRequestDto {
  /** The name of the model */
  name: string;
  /** The provider of the model */
  provider: CreateLanguageModelRequestDtoProvider;
  /** The display name of the model */
  displayName: string;
  /** Whether the model supports streaming */
  canStream: boolean;
  /** Whether the model supports tool use */
  canUseTools: boolean;
  /** Whether the model has reasoning capabilities */
  isReasoning: boolean;
  /** Whether the model supports vision (image processing) */
  canVision: boolean;
  /** Whether the model is archived */
  isArchived: boolean;
}

/**
 * The provider of the model
 */
export type UpdateLanguageModelRequestDtoProvider = typeof UpdateLanguageModelRequestDtoProvider[keyof typeof UpdateLanguageModelRequestDtoProvider];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UpdateLanguageModelRequestDtoProvider = {
  openai: 'openai',
  anthropic: 'anthropic',
  bedrock: 'bedrock',
  mistral: 'mistral',
  ollama: 'ollama',
  synaforce: 'synaforce',
  ayunis: 'ayunis',
  otc: 'otc',
  azure: 'azure',
  gemini: 'gemini',
  stackit: 'stackit',
} as const;

export interface UpdateLanguageModelRequestDto {
  /** The name of the model */
  name: string;
  /** The provider of the model */
  provider: UpdateLanguageModelRequestDtoProvider;
  /** The display name of the model */
  displayName: string;
  /** Whether the model supports streaming */
  canStream: boolean;
  /** Whether the model supports tool use */
  canUseTools: boolean;
  /** Whether the model has reasoning capabilities */
  isReasoning: boolean;
  /** Whether the model supports vision (image processing) */
  canVision: boolean;
  /** Whether the model is archived */
  isArchived: boolean;
}

/**
 * The provider of the model
 */
export type CreateEmbeddingModelRequestDtoProvider = typeof CreateEmbeddingModelRequestDtoProvider[keyof typeof CreateEmbeddingModelRequestDtoProvider];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateEmbeddingModelRequestDtoProvider = {
  openai: 'openai',
  anthropic: 'anthropic',
  bedrock: 'bedrock',
  mistral: 'mistral',
  ollama: 'ollama',
  synaforce: 'synaforce',
  ayunis: 'ayunis',
  otc: 'otc',
  azure: 'azure',
  gemini: 'gemini',
  stackit: 'stackit',
} as const;

/**
 * The dimensions of the embedding
 */
export type CreateEmbeddingModelRequestDtoDimensions = typeof CreateEmbeddingModelRequestDtoDimensions[keyof typeof CreateEmbeddingModelRequestDtoDimensions];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateEmbeddingModelRequestDtoDimensions = {
  NUMBER_1024: 1024,
  NUMBER_1536: 1536,
  NUMBER_2560: 2560,
} as const;

export interface CreateEmbeddingModelRequestDto {
  /** The name of the model */
  name: string;
  /** The provider of the model */
  provider: CreateEmbeddingModelRequestDtoProvider;
  /** The display name of the model */
  displayName: string;
  /** The dimensions of the embedding */
  dimensions: CreateEmbeddingModelRequestDtoDimensions;
  /** Whether the model is archived */
  isArchived: boolean;
}

/**
 * The provider of the model
 */
export type UpdateEmbeddingModelRequestDtoProvider = typeof UpdateEmbeddingModelRequestDtoProvider[keyof typeof UpdateEmbeddingModelRequestDtoProvider];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UpdateEmbeddingModelRequestDtoProvider = {
  openai: 'openai',
  anthropic: 'anthropic',
  bedrock: 'bedrock',
  mistral: 'mistral',
  ollama: 'ollama',
  synaforce: 'synaforce',
  ayunis: 'ayunis',
  otc: 'otc',
  azure: 'azure',
  gemini: 'gemini',
  stackit: 'stackit',
} as const;

/**
 * The dimensions of the embedding
 */
export type UpdateEmbeddingModelRequestDtoDimensions = typeof UpdateEmbeddingModelRequestDtoDimensions[keyof typeof UpdateEmbeddingModelRequestDtoDimensions];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UpdateEmbeddingModelRequestDtoDimensions = {
  NUMBER_1024: 1024,
  NUMBER_1536: 1536,
  NUMBER_2560: 2560,
} as const;

export interface UpdateEmbeddingModelRequestDto {
  /** The name of the model */
  name: string;
  /** The provider of the model */
  provider: UpdateEmbeddingModelRequestDtoProvider;
  /** The display name of the model */
  displayName: string;
  /** The dimensions of the embedding */
  dimensions: UpdateEmbeddingModelRequestDtoDimensions;
  /** Whether the model is archived */
  isArchived: boolean;
}

/**
 * The provider of the model
 */
export type LanguageModelResponseDtoProvider = typeof LanguageModelResponseDtoProvider[keyof typeof LanguageModelResponseDtoProvider];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LanguageModelResponseDtoProvider = {
  openai: 'openai',
  anthropic: 'anthropic',
  bedrock: 'bedrock',
  mistral: 'mistral',
  ollama: 'ollama',
  synaforce: 'synaforce',
  ayunis: 'ayunis',
  otc: 'otc',
  azure: 'azure',
  gemini: 'gemini',
  stackit: 'stackit',
} as const;

/**
 * The type of the model (always language)
 */
export type LanguageModelResponseDtoType = typeof LanguageModelResponseDtoType[keyof typeof LanguageModelResponseDtoType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LanguageModelResponseDtoType = {
  language: 'language',
} as const;

export interface LanguageModelResponseDto {
  /** The unique identifier of the model */
  id: string;
  /** The name of the model */
  name: string;
  /** The provider of the model */
  provider: LanguageModelResponseDtoProvider;
  /** The display name of the model */
  displayName: string;
  /** The type of the model (always language) */
  type: LanguageModelResponseDtoType;
  /** Whether the model is archived */
  isArchived: boolean;
  /** Whether the model supports streaming */
  canStream: boolean;
  /** Whether the model supports tool use */
  canUseTools: boolean;
  /** Whether the model has reasoning capabilities */
  isReasoning: boolean;
  /** Whether the model supports vision (image processing) */
  canVision: boolean;
  /** The date the model was created */
  createdAt: string;
  /** The date the model was last updated */
  updatedAt: string;
}

/**
 * The provider of the model
 */
export type EmbeddingModelResponseDtoProvider = typeof EmbeddingModelResponseDtoProvider[keyof typeof EmbeddingModelResponseDtoProvider];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EmbeddingModelResponseDtoProvider = {
  openai: 'openai',
  anthropic: 'anthropic',
  bedrock: 'bedrock',
  mistral: 'mistral',
  ollama: 'ollama',
  synaforce: 'synaforce',
  ayunis: 'ayunis',
  otc: 'otc',
  azure: 'azure',
  gemini: 'gemini',
  stackit: 'stackit',
} as const;

/**
 * The type of the model (always embedding)
 */
export type EmbeddingModelResponseDtoType = typeof EmbeddingModelResponseDtoType[keyof typeof EmbeddingModelResponseDtoType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EmbeddingModelResponseDtoType = {
  embedding: 'embedding',
} as const;

/**
 * The dimensions of the embedding
 */
export type EmbeddingModelResponseDtoDimensions = typeof EmbeddingModelResponseDtoDimensions[keyof typeof EmbeddingModelResponseDtoDimensions];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EmbeddingModelResponseDtoDimensions = {
  DIMENSION_1024: 'DIMENSION_1024',
  DIMENSION_1536: 'DIMENSION_1536',
  DIMENSION_2560: 'DIMENSION_2560',
  NUMBER_1024: 1024,
  NUMBER_1536: 1536,
  NUMBER_2560: 2560,
} as const;

export interface EmbeddingModelResponseDto {
  /** The unique identifier of the model */
  id: string;
  /** The name of the model */
  name: string;
  /** The provider of the model */
  provider: EmbeddingModelResponseDtoProvider;
  /** The display name of the model */
  displayName: string;
  /** The type of the model (always embedding) */
  type: EmbeddingModelResponseDtoType;
  /** Whether the model is archived */
  isArchived: boolean;
  /** The dimensions of the embedding */
  dimensions: EmbeddingModelResponseDtoDimensions;
  /** The date the model was created */
  createdAt: string;
  /** The date the model was last updated */
  updatedAt: string;
}

export interface CreateOrgRequestDto {
  /** Organization display name */
  name: string;
}

export interface SuperAdminOrgResponseDto {
  /** Organization unique identifier */
  id: string;
  /** Organization display name */
  name: string;
  /** Date when the organization was created */
  createdAt: string;
}

export interface PaginationDto {
  /** Maximum number of items per page */
  limit: number;
  /** Number of items to skip */
  offset: number;
  /** Total number of items available */
  total?: number;
}

export interface SuperAdminOrgListResponseDto {
  /** Array of organizations for the current page */
  data: SuperAdminOrgResponseDto[];
  /** Pagination metadata */
  pagination: PaginationDto;
}

/**
 * User role
 */
export type UserResponseDtoRole = typeof UserResponseDtoRole[keyof typeof UserResponseDtoRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserResponseDtoRole = {
  admin: 'admin',
  user: 'user',
} as const;

export interface UserResponseDto {
  /** User unique identifier */
  id: string;
  /** User name */
  name: string;
  /** User email address */
  email: string;
  /** User role */
  role: UserResponseDtoRole;
  /** Organization ID the user belongs to */
  orgId: string;
  /** Date when the user was created */
  createdAt: string;
}

export interface PaginatedUsersListResponseDto {
  /** Array of users for the current page */
  data: UserResponseDto[];
  /** Pagination metadata */
  pagination: PaginationDto;
}

/**
 * New role for the user
 */
export type UpdateUserRoleDtoRole = typeof UpdateUserRoleDtoRole[keyof typeof UpdateUserRoleDtoRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UpdateUserRoleDtoRole = {
  admin: 'admin',
  user: 'user',
} as const;

export interface UpdateUserRoleDto {
  /** New role for the user */
  role: UpdateUserRoleDtoRole;
}

export interface UpdateUserNameDto {
  /**
   * New name for the user
   * @minLength 1
   * @maxLength 100
   */
  name: string;
}

export interface UpdatePasswordDto {
  /**
   * Current password for verification
   * @minLength 8
   */
  currentPassword: string;
  /**
   * New password
   * @minLength 8
   */
  newPassword: string;
  /**
   * Confirmation of the new password
   * @minLength 8
   */
  newPasswordConfirmation: string;
}

export interface ConfirmEmailDto {
  /** JWT token for email confirmation */
  token: string;
}

export interface ResendEmailConfirmationDto {
  /** Email address to resend confirmation to */
  email: string;
}

export interface ForgotPasswordDto {
  /** Email address to send password reset link to */
  email: string;
}

export interface ResetPasswordDto {
  /** Password reset token from email */
  resetToken: string;
  /**
   * New password
   * @minLength 8
   */
  newPassword: string;
  /**
   * Confirm new password
   * @minLength 8
   */
  newPasswordConfirmation: string;
}

/**
 * Role for the user
 */
export type CreateUserDtoRole = typeof CreateUserDtoRole[keyof typeof CreateUserDtoRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateUserDtoRole = {
  admin: 'admin',
  user: 'user',
} as const;

export interface CreateUserDto {
  /** Email address for the user */
  email: string;
  /** Name of the user */
  name: string;
  /** Role for the user */
  role: CreateUserDtoRole;
  /** Send password reset email */
  sendPasswordResetEmail: boolean;
}

/**
 * Role to assign to the invited user
 */
export type CreateInviteDtoRole = typeof CreateInviteDtoRole[keyof typeof CreateInviteDtoRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateInviteDtoRole = {
  admin: 'admin',
  user: 'user',
} as const;

export interface CreateInviteDto {
  /** Email address of the person to invite */
  email: string;
  /** Role to assign to the invited user */
  role: CreateInviteDtoRole;
}

export interface CreateInviteResponseDto {
  /**
   * URL of the invite, returned when not using email configuration
   * @nullable
   */
  url: string | null;
}

/**
 * Role to assign to the invited user
 */
export type CreateBulkInviteItemDtoRole = typeof CreateBulkInviteItemDtoRole[keyof typeof CreateBulkInviteItemDtoRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateBulkInviteItemDtoRole = {
  admin: 'admin',
  user: 'user',
} as const;

export interface CreateBulkInviteItemDto {
  /** Email address of the person to invite */
  email: string;
  /** Role to assign to the invited user */
  role: CreateBulkInviteItemDtoRole;
}

export interface CreateBulkInvitesDto {
  /**
   * Array of invites to create
   * @minItems 1
   * @maxItems 500
   */
  invites: CreateBulkInviteItemDto[];
}

/**
 * Role assigned to the invited user
 */
export type BulkInviteResultDtoRole = typeof BulkInviteResultDtoRole[keyof typeof BulkInviteResultDtoRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BulkInviteResultDtoRole = {
  admin: 'admin',
  user: 'user',
} as const;

export interface BulkInviteResultDto {
  /** Email address of the invited user */
  email: string;
  /** Role assigned to the invited user */
  role: BulkInviteResultDtoRole;
  /** Whether the invite was created successfully */
  success: boolean;
  /**
   * Invitation URL (only populated when email configuration is unavailable)
   * @nullable
   */
  url: string | null;
  /**
   * Error code if the invite failed
   * @nullable
   */
  errorCode: string | null;
  /**
   * Error message if the invite failed
   * @nullable
   */
  errorMessage: string | null;
}

export interface CreateBulkInvitesResponseDto {
  /** Total number of invites in the request */
  totalCount: number;
  /** Number of invites created successfully */
  successCount: number;
  /** Number of invites that failed */
  failureCount: number;
  /** Individual results for each invite */
  results: BulkInviteResultDto[];
}

/**
 * Role assigned to the invited user
 */
export type InviteResponseDtoRole = typeof InviteResponseDtoRole[keyof typeof InviteResponseDtoRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InviteResponseDtoRole = {
  admin: 'admin',
  user: 'user',
} as const;

/**
 * Current status of the invite
 */
export type InviteResponseDtoStatus = typeof InviteResponseDtoStatus[keyof typeof InviteResponseDtoStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InviteResponseDtoStatus = {
  pending: 'pending',
  accepted: 'accepted',
  expired: 'expired',
} as const;

export interface InviteResponseDto {
  /** Unique identifier of the invite */
  id: string;
  /** Email address of the invited user */
  email: string;
  /** Role assigned to the invited user */
  role: InviteResponseDtoRole;
  /** Current status of the invite */
  status: InviteResponseDtoStatus;
  /** Date when the invite was sent */
  sentDate: string;
  /** Date when the invite expires */
  expiresAt: string;
  /** Date when the invite was accepted (if applicable) */
  acceptedAt?: string;
}

export interface PaginatedInvitesListResponseDto {
  /** Array of invites for the current page */
  data: InviteResponseDto[];
  /** Pagination metadata */
  pagination: PaginationDto;
}

/**
 * Role assigned to the invited user
 */
export type InviteDetailResponseDtoRole = typeof InviteDetailResponseDtoRole[keyof typeof InviteDetailResponseDtoRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InviteDetailResponseDtoRole = {
  admin: 'admin',
  user: 'user',
} as const;

/**
 * Current status of the invite
 */
export type InviteDetailResponseDtoStatus = typeof InviteDetailResponseDtoStatus[keyof typeof InviteDetailResponseDtoStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InviteDetailResponseDtoStatus = {
  pending: 'pending',
  accepted: 'accepted',
  expired: 'expired',
} as const;

export interface InviteDetailResponseDto {
  /** Unique identifier of the invite */
  id: string;
  /** Email address of the invited user */
  email: string;
  /** Role assigned to the invited user */
  role: InviteDetailResponseDtoRole;
  /** Current status of the invite */
  status: InviteDetailResponseDtoStatus;
  /** Date when the invite was sent */
  sentDate: string;
  /** Date when the invite expires */
  expiresAt: string;
  /** Date when the invite was accepted (if applicable) */
  acceptedAt?: string;
  /** Name of the organization */
  organizationName: string;
}

export interface AcceptInviteDto {
  /** JWT token from the invite */
  inviteToken: string;
  /** Name of the user accepting the invite */
  userName: string;
  /** Password of the user accepting the invite */
  password: string;
  /** Marketing acceptance */
  hasAcceptedMarketing: boolean;
}

export interface AcceptInviteResponseDto {
  /** ID of the accepted invite */
  inviteId: string;
  /** Email of the user who accepted the invite */
  email: string;
  /** Organization ID the user was invited to */
  orgId: string;
}

export interface DeleteAllPendingInvitesResponseDto {
  /** Number of invites deleted */
  deletedCount: number;
}

export interface SubscriptionBillingInfoResponseDto {
  /** Company name */
  companyName: string;
  /** Street */
  street: string;
  /** Number */
  houseNumber: string;
  /** City */
  city: string;
  /** Postal code */
  postalCode: string;
  /** Country */
  country: string;
  /** USt-ID */
  vatNumber?: string;
}

/**
 * Date when the subscription was cancelled (if applicable)
 */
export type SubscriptionResponseDtoCancelledAt = { [key: string]: unknown };

/**
 * Renewal cycle of the subscription
 */
export type SubscriptionResponseDtoRenewalCycle = typeof SubscriptionResponseDtoRenewalCycle[keyof typeof SubscriptionResponseDtoRenewalCycle];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SubscriptionResponseDtoRenewalCycle = {
  monthly: 'monthly',
  yearly: 'yearly',
} as const;

export interface SubscriptionResponseDto {
  /** Unique identifier of the subscription */
  id: string;
  /** Date when the subscription was created */
  createdAt: string;
  /** Date when the subscription was last updated */
  updatedAt: string;
  /** Date when the subscription was cancelled (if applicable) */
  cancelledAt?: SubscriptionResponseDtoCancelledAt;
  /** Organization ID associated with the subscription */
  orgId: string;
  /** Number of seats in the subscription */
  noOfSeats: number;
  /** Price per seat in the subscription */
  pricePerSeat: number;
  /** Renewal cycle of the subscription */
  renewalCycle: SubscriptionResponseDtoRenewalCycle;
  /** Date that serves as the anchor for renewal cycles */
  renewalCycleAnchor: string;
  /** Number of available seats (total seats minus invites) */
  availableSeats: number;
  /** Date of the next renewal */
  nextRenewalDate: string;
  /** Billing information */
  billingInfo: SubscriptionBillingInfoResponseDto;
}

export interface SubscriptionResponseDtoNullable {
  /** Subscription */
  subscription?: SubscriptionResponseDto;
}

export interface CreateSubscriptionRequestDto {
  /**
   * Number of seats for the subscription
   * @minimum 1
   */
  noOfSeats?: number;
  /** Company name for the subscription */
  companyName: string;
  /** Sub text for the subscription */
  subText?: string;
  /** Street for the subscription */
  street: string;
  /** House number for the subscription */
  houseNumber: string;
  /** Postal code for the subscription */
  postalCode: string;
  /** City for the subscription */
  city: string;
  /** Country for the subscription */
  country: string;
  /** VAT number for the subscription */
  vatNumber?: string;
}

export interface ActiveSubscriptionResponseDto {
  /** Whether the organization has an active subscription */
  hasActiveSubscription: boolean;
}

export interface UpdateBillingInfoDto {
  /** Company name for the subscription */
  companyName: string;
  /** Street for the subscription */
  street: string;
  /** House number for the subscription */
  houseNumber: string;
  /** Postal code for the subscription */
  postalCode: string;
  /** City for the subscription */
  city: string;
  /** Country for the subscription */
  country: string;
  /** VAT number for the subscription */
  vatNumber?: string;
}

export interface PriceResponseDto {
  /** Current price per seat per month in the configured currency */
  pricePerSeatMonthly: number;
}

export interface UpdateSeatsDto { [key: string]: unknown }

export interface UploadFileResponseDto {
  /** Name of the uploaded object */
  objectName: string;
  /** Size of the uploaded file in bytes */
  size: number;
  /** ETag of the uploaded object */
  etag: string;
  /** Content type of the uploaded file */
  contentType?: string;
  /** Last modified date of the uploaded object */
  lastModified?: string;
}

export interface RetrieveUrlDto {
  /** URL to retrieve content from */
  url: string;
}

export interface CreateThreadDto {
  /** The id of the model */
  modelId?: string;
  /** The id of the agent */
  agentId?: string;
  /** Enable anonymous mode for this thread */
  isAnonymous?: boolean;
}

/**
 * Role of the message sender
 */
export type UserMessageResponseDtoRole = typeof UserMessageResponseDtoRole[keyof typeof UserMessageResponseDtoRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserMessageResponseDtoRole = {
  user: 'user',
} as const;

export type UserMessageResponseDtoContentItem = TextMessageContentResponseDto | ImageMessageContentResponseDto;

export interface UserMessageResponseDto {
  /** Unique identifier for the message */
  id: string;
  /** Thread ID this message belongs to */
  threadId: string;
  /** Creation timestamp */
  createdAt: string;
  /** Role of the message sender */
  role: UserMessageResponseDtoRole;
  /** Array of content items for user messages (text and/or images) */
  content: UserMessageResponseDtoContentItem[];
}

/**
 * Role of the message sender
 */
export type SystemMessageResponseDtoRole = typeof SystemMessageResponseDtoRole[keyof typeof SystemMessageResponseDtoRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SystemMessageResponseDtoRole = {
  system: 'system',
} as const;

export interface SystemMessageResponseDto {
  /** Unique identifier for the message */
  id: string;
  /** Thread ID this message belongs to */
  threadId: string;
  /** Creation timestamp */
  createdAt: string;
  /** Role of the message sender */
  role: SystemMessageResponseDtoRole;
  /** Array of text content items for system messages */
  content: TextMessageContentResponseDto[];
}

/**
 * Role of the message sender
 */
export type AssistantMessageResponseDtoRole = typeof AssistantMessageResponseDtoRole[keyof typeof AssistantMessageResponseDtoRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AssistantMessageResponseDtoRole = {
  assistant: 'assistant',
} as const;

export type AssistantMessageResponseDtoContentItem = TextMessageContentResponseDto | ToolUseMessageContentResponseDto | ThinkingMessageContentResponseDto;

export interface AssistantMessageResponseDto {
  /** Unique identifier for the message */
  id: string;
  /** Thread ID this message belongs to */
  threadId: string;
  /** Creation timestamp */
  createdAt: string;
  /** Role of the message sender */
  role: AssistantMessageResponseDtoRole;
  /** Array of content items for assistant messages (text or tool use) */
  content: AssistantMessageResponseDtoContentItem[];
}

/**
 * Role of the message sender
 */
export type ToolResultMessageResponseDtoRole = typeof ToolResultMessageResponseDtoRole[keyof typeof ToolResultMessageResponseDtoRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ToolResultMessageResponseDtoRole = {
  tool: 'tool',
} as const;

export interface ToolResultMessageResponseDto {
  /** Unique identifier for the message */
  id: string;
  /** Thread ID this message belongs to */
  threadId: string;
  /** Creation timestamp */
  createdAt: string;
  /** Role of the message sender */
  role: ToolResultMessageResponseDtoRole;
  /** Array of tool result content items for tool messages */
  content: ToolResultMessageContentResponseDto[];
}

/**
 * Type of the message content
 */
export type TextMessageContentResponseDtoType = typeof TextMessageContentResponseDtoType[keyof typeof TextMessageContentResponseDtoType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TextMessageContentResponseDtoType = {
  text: 'text',
  tool_use: 'tool_use',
  tool_result: 'tool_result',
  thinking: 'thinking',
  image: 'image',
} as const;

export interface TextMessageContentResponseDto {
  /** Type of the message content */
  type: TextMessageContentResponseDtoType;
  /** The text content of the message */
  text: string;
}

/**
 * Type of the message content
 */
export type ToolUseMessageContentResponseDtoType = typeof ToolUseMessageContentResponseDtoType[keyof typeof ToolUseMessageContentResponseDtoType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ToolUseMessageContentResponseDtoType = {
  text: 'text',
  tool_use: 'tool_use',
  tool_result: 'tool_result',
  thinking: 'thinking',
  image: 'image',
} as const;

/**
 * Parameters passed to the tool
 */
export type ToolUseMessageContentResponseDtoParams = { [key: string]: unknown };

export interface ToolUseMessageContentResponseDto {
  /** Type of the message content */
  type: ToolUseMessageContentResponseDtoType;
  /** Unique identifier for the tool call */
  id: string;
  /** Name of the tool being used */
  name: string;
  /** Parameters passed to the tool */
  params: ToolUseMessageContentResponseDtoParams;
}

/**
 * Type of the message content
 */
export type ToolResultMessageContentResponseDtoType = typeof ToolResultMessageContentResponseDtoType[keyof typeof ToolResultMessageContentResponseDtoType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ToolResultMessageContentResponseDtoType = {
  text: 'text',
  tool_use: 'tool_use',
  tool_result: 'tool_result',
  thinking: 'thinking',
  image: 'image',
} as const;

export interface ToolResultMessageContentResponseDto {
  /** Type of the message content */
  type: ToolResultMessageContentResponseDtoType;
  /** Identifier of the tool call this result belongs to */
  toolId: string;
  /** Name of the tool that generated this result */
  toolName: string;
  /** The result returned by the tool */
  result: string;
}

/**
 * Type of the message content
 */
export type ThinkingMessageContentResponseDtoType = typeof ThinkingMessageContentResponseDtoType[keyof typeof ThinkingMessageContentResponseDtoType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ThinkingMessageContentResponseDtoType = {
  text: 'text',
  tool_use: 'tool_use',
  tool_result: 'tool_result',
  thinking: 'thinking',
  image: 'image',
} as const;

export interface ThinkingMessageContentResponseDto {
  /** Type of the message content */
  type: ThinkingMessageContentResponseDtoType;
  /** The thinking content of the message */
  thinking: string;
}

/**
 * Type of the message content
 */
export type ImageMessageContentResponseDtoType = typeof ImageMessageContentResponseDtoType[keyof typeof ImageMessageContentResponseDtoType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ImageMessageContentResponseDtoType = {
  text: 'text',
  tool_use: 'tool_use',
  tool_result: 'tool_result',
  thinking: 'thinking',
  image: 'image',
} as const;

export interface ImageMessageContentResponseDto {
  /** Type of the message content */
  type: ImageMessageContentResponseDtoType;
  /** Internal image reference (e.g. MinIO object name or /storage/:objectName path) */
  imageUrl: string;
  /** Optional alternative text for the image */
  altText?: string;
}

export interface ModelResponseDto {
  /** The unique identifier of the model */
  id: string;
  /** The name of the model */
  name: string;
  /** The provider of the model */
  provider: string;
  /** The display name of the model */
  displayName: string;
  /** Whether this model requires anonymous mode (PII redaction) */
  anonymousOnly: boolean;
  /** Whether the model supports vision (image processing) */
  canVision: boolean;
}

/**
 * Type of source
 */
export type SourceResponseDtoType = typeof SourceResponseDtoType[keyof typeof SourceResponseDtoType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SourceResponseDtoType = {
  text: 'text',
  data: 'data',
} as const;

/**
 * Creator of the source
 */
export type SourceResponseDtoCreatedBy = typeof SourceResponseDtoCreatedBy[keyof typeof SourceResponseDtoCreatedBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SourceResponseDtoCreatedBy = {
  user: 'user',
  llm: 'llm',
  system: 'system',
} as const;

export interface SourceResponseDto {
  /** Unique identifier for the source */
  id: string;
  /** Thread ID this source belongs to */
  threadId: string;
  /** Name of the source */
  name: string;
  /** Type of source */
  type: SourceResponseDtoType;
  /** Creator of the source */
  createdBy: SourceResponseDtoCreatedBy;
  /** Creation timestamp */
  createdAt: string;
  /** Last update timestamp */
  updatedAt: string;
}

/**
 * Type of source
 */
export type FileSourceResponseDtoType = typeof FileSourceResponseDtoType[keyof typeof FileSourceResponseDtoType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FileSourceResponseDtoType = {
  text: 'text',
  data: 'data',
} as const;

/**
 * Creator of the source
 */
export type FileSourceResponseDtoCreatedBy = typeof FileSourceResponseDtoCreatedBy[keyof typeof FileSourceResponseDtoCreatedBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FileSourceResponseDtoCreatedBy = {
  user: 'user',
  llm: 'llm',
  system: 'system',
} as const;

/**
 * Type of text
 */
export type FileSourceResponseDtoTextType = typeof FileSourceResponseDtoTextType[keyof typeof FileSourceResponseDtoTextType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FileSourceResponseDtoTextType = {
  file: 'file',
  web: 'web',
} as const;

/**
 * Type of file
 */
export type FileSourceResponseDtoFileType = typeof FileSourceResponseDtoFileType[keyof typeof FileSourceResponseDtoFileType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FileSourceResponseDtoFileType = {
  pdf: 'pdf',
  docx: 'docx',
  pptx: 'pptx',
} as const;

export interface FileSourceResponseDto {
  /** Unique identifier for the source */
  id: string;
  /** Thread ID this source belongs to */
  threadId: string;
  /** Name of the source */
  name: string;
  /** Type of source */
  type: FileSourceResponseDtoType;
  /** Creator of the source */
  createdBy: FileSourceResponseDtoCreatedBy;
  /** Creation timestamp */
  createdAt: string;
  /** Last update timestamp */
  updatedAt: string;
  /** Type of text */
  textType: FileSourceResponseDtoTextType;
  /** Type of file */
  fileType: FileSourceResponseDtoFileType;
}

/**
 * Type of source
 */
export type UrlSourceResponseDtoType = typeof UrlSourceResponseDtoType[keyof typeof UrlSourceResponseDtoType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UrlSourceResponseDtoType = {
  text: 'text',
  data: 'data',
} as const;

/**
 * Creator of the source
 */
export type UrlSourceResponseDtoCreatedBy = typeof UrlSourceResponseDtoCreatedBy[keyof typeof UrlSourceResponseDtoCreatedBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UrlSourceResponseDtoCreatedBy = {
  user: 'user',
  llm: 'llm',
  system: 'system',
} as const;

/**
 * Type of text
 */
export type UrlSourceResponseDtoTextType = typeof UrlSourceResponseDtoTextType[keyof typeof UrlSourceResponseDtoTextType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UrlSourceResponseDtoTextType = {
  file: 'file',
  web: 'web',
} as const;

export interface UrlSourceResponseDto {
  /** Unique identifier for the source */
  id: string;
  /** Thread ID this source belongs to */
  threadId: string;
  /** Name of the source */
  name: string;
  /** Type of source */
  type: UrlSourceResponseDtoType;
  /** Creator of the source */
  createdBy: UrlSourceResponseDtoCreatedBy;
  /** Creation timestamp */
  createdAt: string;
  /** Last update timestamp */
  updatedAt: string;
  /** Type of text */
  textType: UrlSourceResponseDtoTextType;
  /** URL of the source */
  url: string;
}

/**
 * Type of source
 */
export type CSVDataSourceResponseDtoType = typeof CSVDataSourceResponseDtoType[keyof typeof CSVDataSourceResponseDtoType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CSVDataSourceResponseDtoType = {
  text: 'text',
  data: 'data',
} as const;

/**
 * Creator of the source
 */
export type CSVDataSourceResponseDtoCreatedBy = typeof CSVDataSourceResponseDtoCreatedBy[keyof typeof CSVDataSourceResponseDtoCreatedBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CSVDataSourceResponseDtoCreatedBy = {
  user: 'user',
  llm: 'llm',
  system: 'system',
} as const;

/**
 * Type of data
 */
export type CSVDataSourceResponseDtoDataType = typeof CSVDataSourceResponseDtoDataType[keyof typeof CSVDataSourceResponseDtoDataType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CSVDataSourceResponseDtoDataType = {
  csv: 'csv',
} as const;

/**
 * CSV data with headers and rows
 */
export type CSVDataSourceResponseDtoData = {
  /** Column headers */
  headers?: string[];
  /** Data rows */
  rows?: string[][];
};

export interface CSVDataSourceResponseDto {
  /** Unique identifier for the source */
  id: string;
  /** Thread ID this source belongs to */
  threadId: string;
  /** Name of the source */
  name: string;
  /** Type of source */
  type: CSVDataSourceResponseDtoType;
  /** Creator of the source */
  createdBy: CSVDataSourceResponseDtoCreatedBy;
  /** Creation timestamp */
  createdAt: string;
  /** Last update timestamp */
  updatedAt: string;
  /** Type of data */
  dataType: CSVDataSourceResponseDtoDataType;
  /** CSV data with headers and rows */
  data: CSVDataSourceResponseDtoData;
}

export type GetThreadResponseDtoMessagesItem = UserMessageResponseDto | SystemMessageResponseDto | AssistantMessageResponseDto | ToolResultMessageResponseDto;

export interface GetThreadResponseDto {
  /** Unique identifier for the thread */
  id: string;
  /** User ID who owns this thread */
  userId: string;
  /** Permitted model ID */
  permittedModelId: string;
  /** Agent ID */
  agentId: string;
  /** Title of the thread */
  title?: string;
  /** Array of messages in the thread (role-specific types) */
  messages: GetThreadResponseDtoMessagesItem[];
  /** Array of sources in the thread */
  sources: SourceResponseDto[];
  /** Creation timestamp */
  createdAt: string;
  /** Last update timestamp */
  updatedAt: string;
  /** Whether the thread is in anonymous mode (PII redaction enabled) */
  isAnonymous: boolean;
  /** Whether the thread has exceeded the token threshold for optimal performance */
  isLongChat: boolean;
}

export interface GetThreadsResponseDtoItem {
  /** Unique identifier for the thread */
  id: string;
  /** Title of the thread */
  title?: string;
  /** Creation timestamp */
  createdAt: string;
  /** Last update timestamp */
  updatedAt: string;
  /** Whether the thread is in anonymous mode (PII redaction enabled) */
  isAnonymous: boolean;
}

export interface GetThreadsResponseDto {
  /** Array of threads for the current page */
  data: GetThreadsResponseDtoItem[];
  /** Pagination metadata */
  pagination: PaginationDto;
}

export interface UpdateThreadTitleDto {
  /**
   * The new title for the thread
   * @minLength 1
   * @maxLength 200
   */
  title: string;
}

/**
 * The type of tool to assign
 */
export type ToolAssignmentDtoType = typeof ToolAssignmentDtoType[keyof typeof ToolAssignmentDtoType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ToolAssignmentDtoType = {
  http: 'http',
  source_query: 'source_query',
  source_get_text: 'source_get_text',
  internet_search: 'internet_search',
  website_content: 'website_content',
  send_email: 'send_email',
  create_calendar_event: 'create_calendar_event',
  code_execution: 'code_execution',
  bar_chart: 'bar_chart',
  line_chart: 'line_chart',
  pie_chart: 'pie_chart',
  mcp_tool: 'mcp_tool',
  mcp_resource: 'mcp_resource',
  mcp_prompt: 'mcp_prompt',
  product_knowledge: 'product_knowledge',
  activate_skill: 'activate_skill',
  create_skill: 'create_skill',
  create_document: 'create_document',
  update_document: 'update_document',
} as const;

export interface ToolAssignmentDto {
  /** The type of tool to assign */
  type: ToolAssignmentDtoType;
  /** The ID of the tool configuration to assign */
  toolConfigId?: string;
}

export interface CreateAgentDto {
  /**
   * The name of the agent
   * @minLength 1
   * @maxLength 255
   */
  name: string;
  /** The instructions for the agent */
  instructions: string;
  /** The ID of the permitted model to use for this agent */
  modelId: string;
  /** The tools to assign to the agent */
  toolAssignments: ToolAssignmentDto[];
}

/**
 * The type of the tool
 */
export type ToolResponseDtoType = typeof ToolResponseDtoType[keyof typeof ToolResponseDtoType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ToolResponseDtoType = {
  http: 'http',
  source_query: 'source_query',
  source_get_text: 'source_get_text',
  internet_search: 'internet_search',
  website_content: 'website_content',
  send_email: 'send_email',
  create_calendar_event: 'create_calendar_event',
  code_execution: 'code_execution',
  bar_chart: 'bar_chart',
  line_chart: 'line_chart',
  pie_chart: 'pie_chart',
  mcp_tool: 'mcp_tool',
  mcp_resource: 'mcp_resource',
  mcp_prompt: 'mcp_prompt',
  product_knowledge: 'product_knowledge',
  activate_skill: 'activate_skill',
  create_skill: 'create_skill',
  create_document: 'create_document',
  update_document: 'update_document',
} as const;

export interface ToolResponseDto {
  /** The type of the tool */
  type: ToolResponseDtoType;
}

/**
 * The type of source
 */
export type AgentSourceResponseDtoType = typeof AgentSourceResponseDtoType[keyof typeof AgentSourceResponseDtoType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AgentSourceResponseDtoType = {
  file: 'file',
  url: 'url',
} as const;

export interface AgentSourceResponseDto {
  /** The unique identifier of the source assignment */
  id: string;
  /** The unique identifier of the source */
  sourceId: string;
  /** The name of the source */
  name: string;
  /** The type of source */
  type: AgentSourceResponseDtoType;
}

export interface AgentResponseDto {
  /** The unique identifier of the agent */
  id: string;
  /** The name of the agent */
  name: string;
  /** The instructions for the agent */
  instructions: string;
  /** The unique identifier of the user who owns this agent */
  userId: string;
  /** The date and time when the agent was created */
  createdAt: string;
  /** The date and time when the agent was last updated */
  updatedAt: string;
  /** The model configuration for this agent */
  model: ModelResponseDto;
  /** The tools assigned to this agent */
  tools: ToolResponseDto[];
  /** The sources assigned to this agent */
  sources: AgentSourceResponseDto[];
  /** Whether this agent is shared with the current user (vs. owned by them) */
  isShared: boolean;
  /** The unique identifier of the user who owns this agent (same as userId) */
  ownerId: string;
}

export interface UpdateAgentDto {
  /**
   * The name of the agent
   * @minLength 1
   * @maxLength 255
   */
  name: string;
  /** The instructions for the agent */
  instructions: string;
  /** The ID of the permitted model to use for this agent */
  modelId: string;
}

/**
 * Type of integration
 */
export type McpIntegrationResponseDtoType = typeof McpIntegrationResponseDtoType[keyof typeof McpIntegrationResponseDtoType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const McpIntegrationResponseDtoType = {
  predefined: 'predefined',
  custom: 'custom',
} as const;

/**
 * Authentication method used
 */
export type McpIntegrationResponseDtoAuthMethod = typeof McpIntegrationResponseDtoAuthMethod[keyof typeof McpIntegrationResponseDtoAuthMethod];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const McpIntegrationResponseDtoAuthMethod = {
  NO_AUTH: 'NO_AUTH',
  BEARER_TOKEN: 'BEARER_TOKEN',
  CUSTOM_HEADER: 'CUSTOM_HEADER',
  OAUTH: 'OAUTH',
} as const;

/**
 * Connection status of the integration
 */
export type McpIntegrationResponseDtoConnectionStatus = typeof McpIntegrationResponseDtoConnectionStatus[keyof typeof McpIntegrationResponseDtoConnectionStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const McpIntegrationResponseDtoConnectionStatus = {
  connected: 'connected',
  disconnected: 'disconnected',
  error: 'error',
  unknown: 'unknown',
} as const;

export interface McpIntegrationResponseDto {
  /** Unique identifier of the integration */
  id: string;
  /** Name of the integration */
  name: string;
  /** Type of integration */
  type: McpIntegrationResponseDtoType;
  /** Predefined integration slug (only for predefined integrations) */
  slug?: string;
  /** Custom server URL (only for custom integrations) */
  serverUrl?: string;
  /** Whether the integration is enabled */
  enabled: boolean;
  /** Organization that owns this integration */
  organizationId: string;
  /** Authentication method used */
  authMethod?: McpIntegrationResponseDtoAuthMethod;
  /** Custom auth header name */
  authHeaderName?: string;
  /** Whether credentials are configured (never exposes actual credentials) */
  hasCredentials: boolean;
  /** Connection status of the integration */
  connectionStatus?: McpIntegrationResponseDtoConnectionStatus;
  /** Last error message if connection failed */
  lastConnectionError?: string;
  /** Timestamp of the last connection check */
  lastConnectionCheck?: string;
  /** Timestamp when the integration was created */
  createdAt: string;
  /** Timestamp when the integration was last updated */
  updatedAt: string;
  /** Whether tools from this integration may return PII data that should be anonymized in anonymous mode */
  returnsPii: boolean;
}

/**
 * Type of entity being shared
 */
export type CreateAgentShareDtoEntityType = typeof CreateAgentShareDtoEntityType[keyof typeof CreateAgentShareDtoEntityType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateAgentShareDtoEntityType = {
  agent: 'agent',
  prompt: 'prompt',
  skill: 'skill',
} as const;

export interface CreateAgentShareDto {
  /** Type of entity being shared */
  entityType: CreateAgentShareDtoEntityType;
  /** ID of the agent to share */
  agentId: string;
  /** ID of the team to share with (if not provided, shares with entire organization) */
  teamId?: string;
}

/**
 * Type of entity being shared
 */
export type ShareResponseDtoEntityType = typeof ShareResponseDtoEntityType[keyof typeof ShareResponseDtoEntityType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ShareResponseDtoEntityType = {
  agent: 'agent',
  prompt: 'prompt',
  skill: 'skill',
} as const;

/**
 * Type of share scope (organization, user, or team)
 */
export type ShareResponseDtoScopeType = typeof ShareResponseDtoScopeType[keyof typeof ShareResponseDtoScopeType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ShareResponseDtoScopeType = {
  org: 'org',
  team: 'team',
} as const;

export interface ShareResponseDto {
  /** Unique identifier of the share */
  id: string;
  /** Type of entity being shared */
  entityType: ShareResponseDtoEntityType;
  /** ID of the entity being shared */
  entityId: string;
  /** Type of share scope (organization, user, or team) */
  scopeType: ShareResponseDtoScopeType;
  /** ID of the user who created the share */
  ownerId: string;
  /** ID of the team (only present for team-scoped shares) */
  teamId?: string;
  /** Name of the team (only present for team-scoped shares) */
  teamName?: string;
  /** When the share was created */
  createdAt: string;
  /** When the share was last updated */
  updatedAt: string;
}

/**
 * Type of entity being shared
 */
export type CreateSkillShareDtoEntityType = typeof CreateSkillShareDtoEntityType[keyof typeof CreateSkillShareDtoEntityType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateSkillShareDtoEntityType = {
  agent: 'agent',
  prompt: 'prompt',
  skill: 'skill',
} as const;

export interface CreateSkillShareDto {
  /** Type of entity being shared */
  entityType: CreateSkillShareDtoEntityType;
  /** ID of the skill to share */
  skillId: string;
  /** ID of the team to share with (if not provided, shares with entire organization) */
  teamId?: string;
}

export interface CreateTeamDto {
  /** The name of the team */
  name: string;
}

export interface UpdateTeamDto {
  /** The new name of the team */
  name: string;
}

export interface TeamResponseDto {
  /** The unique identifier of the team */
  id: string;
  /** The name of the team */
  name: string;
  /** The organization ID the team belongs to */
  orgId: string;
  /** The date and time when the team was created */
  createdAt: string;
  /** The date and time when the team was last updated */
  updatedAt: string;
}

/**
 * The role of the team member in the organization
 */
export type TeamMemberResponseDtoUserRole = typeof TeamMemberResponseDtoUserRole[keyof typeof TeamMemberResponseDtoUserRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TeamMemberResponseDtoUserRole = {
  admin: 'admin',
  user: 'user',
} as const;

export interface TeamMemberResponseDto {
  /** The unique identifier of the team member */
  id: string;
  /** The user ID of the team member */
  userId: string;
  /** The name of the team member */
  userName: string;
  /** The email of the team member */
  userEmail: string;
  /** The role of the team member in the organization */
  userRole: TeamMemberResponseDtoUserRole;
  /** The date when the user joined the team */
  joinedAt: string;
}

export interface PaginatedTeamMembersResponseDto {
  /** Array of team members for the current page */
  data: TeamMemberResponseDto[];
  /** Pagination metadata */
  pagination: PaginationDto;
}

export interface AddTeamMemberDto {
  /** The user ID to add to the team */
  userId: string;
}

export interface ListTeamMembersQueryDto {
  /** Maximum number of items per page */
  limit?: number;
  /** Number of items to skip */
  offset?: number;
}

/**
 * The name/type of the credential field
 */
export type ConfigValueDtoName = typeof ConfigValueDtoName[keyof typeof ConfigValueDtoName];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ConfigValueDtoName = {
  token: 'token',
  clientId: 'clientId',
  clientSecret: 'clientSecret',
} as const;

export interface ConfigValueDto {
  /** The name/type of the credential field */
  name: ConfigValueDtoName;
  /** The value for this credential field (will be encrypted) */
  value: string;
}

/**
 * The predefined integration slug
 */
export type CreatePredefinedIntegrationDtoSlug = typeof CreatePredefinedIntegrationDtoSlug[keyof typeof CreatePredefinedIntegrationDtoSlug];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreatePredefinedIntegrationDtoSlug = {
  TEST: 'TEST',
  LOCABOO: 'LOCABOO',
  LEGAL_CODES: 'LEGAL_CODES',
} as const;

export interface CreatePredefinedIntegrationDto {
  /** The predefined integration slug */
  slug: CreatePredefinedIntegrationDtoSlug;
  /** List of config values for credential fields */
  configValues: ConfigValueDto[];
  /** Whether tools from this integration may return PII data that should be anonymized in anonymous mode. Defaults to true for safety. */
  returnsPii?: boolean;
}

/**
 * Authentication method for the MCP server
 * @nullable
 */
export type CreateCustomIntegrationDtoAuthMethod = typeof CreateCustomIntegrationDtoAuthMethod[keyof typeof CreateCustomIntegrationDtoAuthMethod] | null;


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateCustomIntegrationDtoAuthMethod = {
  NO_AUTH: 'NO_AUTH',
  BEARER_TOKEN: 'BEARER_TOKEN',
  CUSTOM_HEADER: 'CUSTOM_HEADER',
  OAUTH: 'OAUTH',
} as const;

export interface CreateCustomIntegrationDto {
  /**
   * The name for this integration instance
   * @minLength 1
   * @maxLength 255
   */
  name: string;
  /** The URL of the custom MCP server */
  serverUrl: string;
  /**
   * Authentication method for the MCP server
   * @nullable
   */
  authMethod?: CreateCustomIntegrationDtoAuthMethod;
  /** Custom auth header name (e.g., X-API-Key). Required for CUSTOM_HEADER auth method. Ignored for BEARER_TOKEN (always uses Authorization header). */
  authHeaderName?: string;
  /** Authentication credentials (will be encrypted). Required for CUSTOM_HEADER and BEARER_TOKEN auth methods. */
  credentials?: string;
  /** Whether tools from this integration may return PII data that should be anonymized in anonymous mode. Defaults to true for safety. */
  returnsPii?: boolean;
}

/**
 * Input type (text or password)
 */
export type CredentialFieldDtoType = typeof CredentialFieldDtoType[keyof typeof CredentialFieldDtoType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CredentialFieldDtoType = {
  token: 'token',
  clientId: 'clientId',
  clientSecret: 'clientSecret',
} as const;

export interface CredentialFieldDto {
  /** User-friendly label for the credential field */
  label: string;
  /** Input type (text or password) */
  type: CredentialFieldDtoType;
  /** Whether this field is required */
  required: boolean;
  /** Help text to guide users */
  help?: string;
}

/**
 * Authentication method for this integration
 */
export type PredefinedConfigResponseDtoAuthType = typeof PredefinedConfigResponseDtoAuthType[keyof typeof PredefinedConfigResponseDtoAuthType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PredefinedConfigResponseDtoAuthType = {
  NO_AUTH: 'NO_AUTH',
  BEARER_TOKEN: 'BEARER_TOKEN',
  API_KEY: 'API_KEY',
  OAUTH: 'OAUTH',
} as const;

export interface PredefinedConfigResponseDto {
  /** Unique slug identifier for the predefined integration */
  slug: string;
  /** Display name for the integration */
  displayName: string;
  /** Description of what this integration provides */
  description: string;
  /** Authentication method for this integration */
  authType: PredefinedConfigResponseDtoAuthType;
  /** HTTP header name for authentication (if applicable) */
  authHeaderName?: string;
  /** Credential fields required for this integration */
  credentialFields?: CredentialFieldDto[];
}

export interface UpdateMcpIntegrationDto {
  /**
   * The new name for the integration
   * @minLength 1
   * @maxLength 255
   */
  name?: string;
  /** Authentication credentials (will be encrypted). Provide to rotate the stored secret/token. */
  credentials?: string;
  /** Custom auth header name. Only used in combination with CUSTOM_HEADER integrations. */
  authHeaderName?: string;
  /** Whether tools from this integration may return PII data that should be anonymized in anonymous mode. */
  returnsPii?: boolean;
}

/**
 * Discovered capabilities from the MCP server
 */
export type ValidationResponseDtoCapabilities = { [key: string]: unknown };

export interface ValidationResponseDto {
  /** Whether the integration validation succeeded */
  valid: boolean;
  /** Discovered capabilities from the MCP server */
  capabilities: ValidationResponseDtoCapabilities;
  /** Error message if validation failed */
  error?: string;
}

export interface InstallSkillFromMarketplaceDto {
  /** The unique identifier (slug) of the marketplace skill */
  identifier: string;
}

export interface SkillResponseDto {
  /** The unique identifier of the skill */
  id: string;
  /** The name of the skill */
  name: string;
  /** A short description of the skill */
  shortDescription: string;
  /** Detailed instructions for the skill */
  instructions: string;
  /**
   * The marketplace identifier if this skill was installed from the marketplace
   * @nullable
   */
  marketplaceIdentifier: string | null;
  /** Whether the skill is active and available for use in chats */
  isActive: boolean;
  /** The unique identifier of the user who owns this skill */
  userId: string;
  /** The date and time when the skill was created */
  createdAt: string;
  /** The date and time when the skill was last updated */
  updatedAt: string;
  /** Whether the skill is shared with the current user (not owned) */
  isShared: boolean;
}

export interface CreateSkillDto {
  /**
   * The name of the skill (must be unique per user). Only letters, numbers, hyphens, and spaces allowed. Must start and end with a letter or number.
   * @minLength 1
   * @maxLength 255
   */
  name: string;
  /** A short description of the skill (shown in system prompt for LLM to decide activation) */
  shortDescription: string;
  /** Detailed instructions for the skill (injected when the skill is activated) */
  instructions: string;
  /** Whether the skill is active (defaults to false) */
  isActive?: boolean;
}

export interface UpdateSkillDto {
  /**
   * The name of the skill (must be unique per user). Only letters, numbers, hyphens, and spaces allowed. Must start and end with a letter or number.
   * @minLength 1
   * @maxLength 255
   */
  name: string;
  /** A short description of the skill (shown in system prompt for LLM to decide activation) */
  shortDescription: string;
  /** Detailed instructions for the skill (injected when the skill is activated) */
  instructions: string;
}

export interface SkillSourceResponseDto {
  /** The unique identifier of the source */
  id: string;
  /** The name of the source */
  name: string;
  /** The type of source */
  type: string;
}

export interface MarketplaceSkillResponseDto {
  /** Skill UUID */
  id: string;
  /** Unique identifier (slug) */
  identifier: string;
  /** Display name */
  name: string;
  /** Short description for marketplace display */
  shortDescription: string;
  /** Description shown to LLM to decide activation */
  aiDescription: string;
  /** Detailed instructions injected into the conversation when the skill is activated */
  instructions: string;
  /**
   * Skill category ID
   * @nullable
   */
  skillCategoryId?: string | null;
  /**
   * Icon URL
   * @nullable
   */
  iconUrl?: string | null;
  /** Whether the skill is featured */
  featured: boolean;
  /** Whether the skill is published */
  published: boolean;
  /** Whether the skill is pre-installed */
  preInstalled: boolean;
  /** Creation timestamp */
  createdAt: string;
  /** Last update timestamp */
  updatedAt: string;
}

/**
 * Type of the message content
 */
export type MessageContentResponseDtoType = typeof MessageContentResponseDtoType[keyof typeof MessageContentResponseDtoType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MessageContentResponseDtoType = {
  text: 'text',
  tool_use: 'tool_use',
  tool_result: 'tool_result',
  thinking: 'thinking',
  image: 'image',
} as const;

export interface MessageContentResponseDto {
  /** Type of the message content */
  type: MessageContentResponseDtoType;
}

/**
 * Response type identifier
 */
export type RunSessionResponseDtoType = typeof RunSessionResponseDtoType[keyof typeof RunSessionResponseDtoType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RunSessionResponseDtoType = {
  session: 'session',
} as const;

export interface RunSessionResponseDto {
  /** Response type identifier */
  type: RunSessionResponseDtoType;
  /** Indicates successful session establishment */
  success?: boolean;
  /** Indicates if the session is streaming */
  streaming?: boolean;
  /** Thread ID for the session */
  threadId: string;
  /** Session establishment timestamp */
  timestamp: string;
}

/**
 * Response type identifier
 */
export type RunMessageResponseDtoType = typeof RunMessageResponseDtoType[keyof typeof RunMessageResponseDtoType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RunMessageResponseDtoType = {
  message: 'message',
} as const;

/**
 * The message data
 */
export type RunMessageResponseDtoMessage = UserMessageResponseDto | AssistantMessageResponseDto | ToolResultMessageResponseDto | SystemMessageResponseDto;

export interface RunMessageResponseDto {
  /** Response type identifier */
  type: RunMessageResponseDtoType;
  /** The message data */
  message: RunMessageResponseDtoMessage;
  /** Thread ID for the message */
  threadId: string;
  /** Message timestamp */
  timestamp: string;
}

/**
 * Response type identifier
 */
export type RunErrorResponseDtoType = typeof RunErrorResponseDtoType[keyof typeof RunErrorResponseDtoType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RunErrorResponseDtoType = {
  error: 'error',
} as const;

/**
 * Optional additional error details
 */
export type RunErrorResponseDtoDetails = { [key: string]: unknown };

export interface RunErrorResponseDto {
  /** Response type identifier */
  type: RunErrorResponseDtoType;
  /** Error message */
  message: string;
  /** Thread ID where the error occurred */
  threadId: string;
  /** Error timestamp */
  timestamp: string;
  /** Optional error code for categorization */
  code?: string;
  /** Optional additional error details */
  details?: RunErrorResponseDtoDetails;
}

/**
 * Response type identifier
 */
export type RunThreadResponseDtoType = typeof RunThreadResponseDtoType[keyof typeof RunThreadResponseDtoType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RunThreadResponseDtoType = {
  thread: 'thread',
} as const;

/**
 * Type of thread update
 */
export type RunThreadResponseDtoUpdateType = typeof RunThreadResponseDtoUpdateType[keyof typeof RunThreadResponseDtoUpdateType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RunThreadResponseDtoUpdateType = {
  title_updated: 'title_updated',
} as const;

export interface RunThreadResponseDto {
  /** Response type identifier */
  type: RunThreadResponseDtoType;
  /** Thread ID that was updated */
  threadId: string;
  /** Type of thread update */
  updateType: RunThreadResponseDtoUpdateType;
  /** Updated thread title */
  title: string;
  /** Thread update timestamp */
  timestamp: string;
}

/**
 * The type of input
 */
export type TextInputType = typeof TextInputType[keyof typeof TextInputType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TextInputType = {
  text: 'text',
} as const;

export interface TextInput {
  /** The type of input */
  type: TextInputType;
  /** The text content for the inference */
  text: string;
}

/**
 * The type of input
 */
export type ToolResultInputType = typeof ToolResultInputType[keyof typeof ToolResultInputType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ToolResultInputType = {
  tool_result: 'tool_result',
} as const;

export interface ToolResultInput {
  /** The type of input */
  type: ToolResultInputType;
  /** The ID of the tool that produced this result */
  toolId: string;
  /** The name of the tool that produced this result */
  toolName: string;
  /** The result data from the tool execution */
  result: string;
}

export interface SendMessageDto {
  /** The thread to use for the inference. */
  threadId: string;
  /** Text content of the user message (for user input) */
  text?: string;
  /** JSON array of alt texts matching the order of uploaded images */
  imageAltTexts?: string[];
  /** Tool result input (for tool_result type only) */
  toolResult?: ToolResultInput;
  /** Enable streaming mode for real-time response updates */
  streaming?: boolean;
}

export interface SuperAdminTrialResponseDto {
  /** Trial unique identifier */
  id: string;
  /** Organization ID associated with this trial */
  orgId: string;
  /**
   * Number of messages sent in this trial
   * @minimum 0
   */
  messagesSent: number;
  /**
   * Maximum number of messages allowed in this trial
   * @minimum 1
   */
  maxMessages: number;
  /** Date when the trial was created */
  createdAt: string;
  /** Date when the trial was last updated */
  updatedAt: string;
}

export interface SuperAdminTrialResponseDtoNullable {
  /** Trial */
  trial?: SuperAdminTrialResponseDto;
}

export interface CreateTrialRequestDto {
  /** Organization ID for which to create the trial */
  orgId: string;
  /**
   * Maximum number of messages allowed in the trial
   * @minimum 1
   */
  maxMessages: number;
}

export interface UpdateTrialRequestDto {
  /**
   * Maximum number of messages allowed in the trial
   * @minimum 1
   */
  maxMessages?: number;
  /**
   * Number of messages already sent (can be used to reset or adjust)
   * @minimum 0
   */
  messagesSent?: number;
}

export interface UsageConfigResponseDto {
  /** Whether the deployment is self-hosted. Determines feature availability. */
  isSelfHosted: boolean;
}

export interface UsageStatsResponseDto {
  /** Total tokens consumed across all users and models in the specified period */
  totalTokens: number;
  /** Total number of API requests made in the specified period */
  totalRequests: number;
  /** Number of users who made requests within the active user threshold (last 30 days) */
  activeUsers: number;
  /** Total number of unique users who made requests in the specified period */
  totalUsers: number;
  /** List of the most frequently used model names, ordered by usage */
  topModels: string[];
}

export interface TimeSeriesPointDto {
  /** Date of the data point */
  date: string;
  /** Number of tokens at this point */
  tokens: number;
  /** Number of requests at this point */
  requests: number;
}

/**
 * Model provider
 */
export type ProviderUsageDtoProvider = typeof ProviderUsageDtoProvider[keyof typeof ProviderUsageDtoProvider];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProviderUsageDtoProvider = {
  openai: 'openai',
  anthropic: 'anthropic',
  bedrock: 'bedrock',
  mistral: 'mistral',
  ollama: 'ollama',
  synaforce: 'synaforce',
  ayunis: 'ayunis',
  otc: 'otc',
  azure: 'azure',
  gemini: 'gemini',
  stackit: 'stackit',
} as const;

export interface ProviderUsageDto {
  /** Model provider */
  provider: ProviderUsageDtoProvider;
  /** Total tokens for this provider */
  tokens: number;
  /** Total requests for this provider */
  requests: number;
  /** Percentage of total usage */
  percentage: number;
  /** Time series data for this provider */
  timeSeriesData: TimeSeriesPointDto[];
}

export interface ProviderUsageResponseDto {
  /** Provider usage statistics */
  providers: ProviderUsageDto[];
}

export interface ProviderValuesDto {
  /** Tokens for OpenAI */
  openai?: number;
  /** Tokens for Anthropic */
  anthropic?: number;
  /** Tokens for Mistral */
  mistral?: number;
  /** Tokens for Ollama */
  ollama?: number;
  /** Tokens for Synaforce */
  synaforce?: number;
  /** Tokens for Ayunis (internal) */
  ayunis?: number;
}

export interface ProviderTimeSeriesRowDto {
  /** Date of the data point */
  date: string;
  /** Tokens per provider for this date */
  values: ProviderValuesDto;
}

export interface ProviderUsageChartResponseDto {
  /** Aligned time series rows by date with provider token values */
  timeSeries: ProviderTimeSeriesRowDto[];
}

/**
 * Model provider
 */
export type ModelDistributionDtoProvider = typeof ModelDistributionDtoProvider[keyof typeof ModelDistributionDtoProvider];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelDistributionDtoProvider = {
  openai: 'openai',
  anthropic: 'anthropic',
  bedrock: 'bedrock',
  mistral: 'mistral',
  ollama: 'ollama',
  synaforce: 'synaforce',
  ayunis: 'ayunis',
  otc: 'otc',
  azure: 'azure',
  gemini: 'gemini',
  stackit: 'stackit',
} as const;

export interface ModelDistributionDto {
  /** Model ID */
  modelId: string;
  /** Model name */
  modelName: string;
  /** Model display name */
  displayName: string;
  /** Model provider */
  provider: ModelDistributionDtoProvider;
  /** Total tokens for this model */
  tokens: number;
  /** Total requests for this model */
  requests: number;
  /** Percentage of total usage */
  percentage: number;
}

export interface ModelDistributionResponseDto {
  /** Model distribution statistics */
  models: ModelDistributionDto[];
}

export interface UserUsageDto {
  /** User ID */
  userId: string;
  /** User name */
  userName: string;
  /** User email */
  userEmail: string;
  /** Total tokens for this user */
  tokens: number;
  /** Total requests for this user */
  requests: number;
  /**
   * Last activity date (null if no activity)
   * @nullable
   */
  lastActivity: string | null;
  /** Whether the user is considered active */
  isActive: boolean;
}

export interface UserUsageResponseDto {
  /** User usage statistics */
  data: UserUsageDto[];
  /** Pagination metadata */
  pagination: PaginationDto;
}

export interface UserSystemPromptResponseDto {
  /**
   * The custom system prompt for the user, or null if not set
   * @nullable
   */
  systemPrompt: string | null;
}

export interface UpsertUserSystemPromptDto {
  /**
   * The custom system prompt for the user
   * @maxLength 10000
   */
  systemPrompt: string;
}

export interface CreatePromptDto {
  /**
   * The title of the prompt
   * @minLength 1
   * @maxLength 255
   */
  title: string;
  /** The content of the prompt */
  content: string;
}

export interface PromptResponseDto {
  /** The unique identifier of the prompt */
  id: string;
  /** The title of the prompt */
  title: string;
  /** The content of the prompt */
  content: string;
  /** The unique identifier of the user who owns this prompt */
  userId: string;
  /** The date and time when the prompt was created */
  createdAt: string;
  /** The date and time when the prompt was last updated */
  updatedAt: string;
}

export interface UpdatePromptDto {
  /**
   * The title of the prompt
   * @minLength 1
   * @maxLength 255
   */
  title: string;
  /** The content of the prompt */
  content: string;
}

export interface TranscriptionResponseDto {
  /** The transcribed text from the audio file */
  text: string;
}

export interface LoginDto {
  /** Email address for authentication */
  email: string;
  /** Password for authentication */
  password: string;
}

export interface SuccessResponseDto {
  /** Operation success status */
  success: boolean;
}

export interface ErrorResponseDto {
  /** Error message */
  message: string;
}

export interface RegisterDto {
  /** Email address for the user account */
  email: string;
  /** Password for the user account */
  password: string;
  /** Organization name */
  orgName: string;
  /** User name */
  userName: string;
  /** Marketing acceptance */
  marketingAcceptance: boolean;
}

/**
 * User role
 */
export type MeResponseDtoRole = typeof MeResponseDtoRole[keyof typeof MeResponseDtoRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MeResponseDtoRole = {
  admin: 'admin',
  user: 'user',
} as const;

/**
 * User system role
 */
export type MeResponseDtoSystemRole = typeof MeResponseDtoSystemRole[keyof typeof MeResponseDtoSystemRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MeResponseDtoSystemRole = {
  customer: 'customer',
  super_admin: 'super_admin',
} as const;

export interface MeResponseDto {
  /** User email address */
  email: string;
  /** User role */
  role: MeResponseDtoRole;
  /** User system role */
  systemRole: MeResponseDtoSystemRole;
  /** User name */
  name: string;
}

export type AuthorType = typeof AuthorType[keyof typeof AuthorType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthorType = {
  USER: 'USER',
  ASSISTANT: 'ASSISTANT',
} as const;

export type ExportFormatDto = typeof ExportFormatDto[keyof typeof ExportFormatDto];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ExportFormatDto = {
  docx: 'docx',
  pdf: 'pdf',
} as const;

export interface CreateArtifactDto {
  /** @maxLength 500 */
  title: string;
  /** @maxLength 512000 */
  content: string;
  threadId: string;
  authorType: AuthorType;
}

export interface UpdateArtifactDto {
  /** @maxLength 512000 */
  content: string;
  authorType: AuthorType;
}

export interface RevertArtifactDto {
  /** @minimum 1 */
  versionNumber: number;
}

export interface ExportArtifactQueryDto {
  format: ExportFormatDto;
}

export interface ArtifactVersionResponseDto {
  id: string;
  artifactId: string;
  versionNumber: number;
  content: string;
  authorType: AuthorType;
  /** @nullable */
  authorId?: string | null;
  createdAt: string;
}

export interface ArtifactResponseDto {
  id: string;
  threadId: string;
  userId: string;
  title: string;
  currentVersionNumber: number;
  versions?: ArtifactVersionResponseDto[];
  createdAt: string;
  updatedAt: string;
}

export type SuperAdminModelsControllerGetCatalogModelById200 = LanguageModelResponseDto | EmbeddingModelResponseDto;

export type SuperAdminModelsControllerGetPermittedModels200Item = PermittedLanguageModelResponseDto | PermittedEmbeddingModelResponseDto;

export type SuperAdminModelsControllerUpdatePermittedModel200 = PermittedLanguageModelResponseDto | PermittedEmbeddingModelResponseDto;

export type SuperAdminModelsControllerGetAllCatalogModels200Item = LanguageModelResponseDto | EmbeddingModelResponseDto;

export type SuperAdminOrgsControllerGetAllOrgsParams = {
/**
 * Search organizations by name.
 */
search?: string;
/**
 * Maximum number of organizations to return (default: 50).
 */
limit?: number;
/**
 * Number of organizations to skip (default: 0).
 */
offset?: number;
};

export type UserControllerGetUsersInOrganizationParams = {
/**
 * Search users by name or email
 */
search?: string;
/**
 * Maximum number of users to return (default: 25)
 */
limit?: number;
/**
 * Number of users to skip (default: 0)
 */
offset?: number;
};

export type UserControllerValidateResetTokenParams = {
/**
 * Password reset token from email
 */
token: string;
};

export type UserControllerValidateResetToken200 = {
  valid?: boolean;
};

export type SuperAdminUsersControllerGetUsersByOrgIdParams = {
/**
 * Search users by name or email
 */
search?: string;
/**
 * Maximum number of users to return (default: 25)
 */
limit?: number;
/**
 * Number of users to skip (default: 0)
 */
offset?: number;
};

export type InvitesControllerGetInvitesParams = {
/**
 * Search invites by email
 */
search?: string;
/**
 * Maximum number of invites to return (default: 25)
 */
limit?: number;
/**
 * Number of invites to skip (default: 0)
 */
offset?: number;
};

export type StorageControllerUploadFileBody = {
  /** The file to upload */
  file: Blob;
};

export type ThreadsControllerFindAllParams = {
/**
 * Search threads by title
 */
search?: string;
/**
 * Filter threads by agent ID
 */
agentId?: string;
/**
 * Maximum number of threads to return (default: 50)
 */
limit?: number;
/**
 * Number of threads to skip (default: 0)
 */
offset?: number;
};

export type ThreadsControllerGetThreadSources200Item = FileSourceResponseDto | UrlSourceResponseDto | CSVDataSourceResponseDto;

export type ThreadsControllerAddFileSourceBody = {
  /** The file to upload */
  file: Blob;
  /** The display name for the file source */
  name?: string;
  /** A description of the file source */
  description?: string;
};

export type AgentsControllerAddFileSourceBody = {
  /** The file to upload */
  file: Blob;
};

export type SharesControllerGetSharesParams = {
/**
 * ID of the entity to get shares for
 */
entityId: string;
/**
 * Type of the entity
 */
entityType: SharesControllerGetSharesEntityType;
};

export type SharesControllerGetSharesEntityType = typeof SharesControllerGetSharesEntityType[keyof typeof SharesControllerGetSharesEntityType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SharesControllerGetSharesEntityType = {
  agent: 'agent',
  prompt: 'prompt',
  skill: 'skill',
} as const;

export type TeamsControllerListTeamMembersParams = {
/**
 * Maximum number of items per page
 */
limit?: number;
/**
 * Number of items to skip
 */
offset?: number;
};

export type SkillsControllerAddFileSourceBody = {
  /** The file to upload */
  file: Blob;
};

export type RunsControllerSendMessageBody = {
  threadId: string;
  /** Message text (optional if images provided) */
  text?: string;
  /** Image files to attach (max 10, max 10MB each, 50MB total) */
  images?: Blob[];
  /** JSON array of alt texts matching image order */
  imageAltTexts?: string;
  /** JSON object for tool result input */
  toolResult?: string;
  streaming?: boolean;
};

export type RunsControllerSendMessage200 = RunSessionResponseDto | RunMessageResponseDto | RunErrorResponseDto | RunThreadResponseDto;

export type UsageControllerGetUsageStatsParams = {
/**
 * Start date in ISO format. If provided, must be used with endDate.
 */
startDate?: string;
/**
 * End date in ISO format. If provided, must be used with startDate.
 */
endDate?: string;
};

export type UsageControllerGetProviderUsageParams = {
/**
 * Start date in ISO format
 */
startDate?: string;
/**
 * End date in ISO format
 */
endDate?: string;
/**
 * Whether to include time series data for trend charts. Defaults to true.
 */
includeTimeSeries?: boolean;
/**
 * Filter by provider (e.g., openai, anthropic)
 */
provider?: string;
/**
 * Filter by model ID
 */
modelId?: string;
};

export type UsageControllerGetProviderUsageChartParams = {
startDate?: string;
endDate?: string;
/**
 * Filter by provider (e.g., openai, anthropic)
 */
provider?: string;
/**
 * Filter by model ID
 */
modelId?: string;
};

export type UsageControllerGetModelDistributionParams = {
/**
 * Start date in ISO format
 */
startDate?: string;
/**
 * End date in ISO format
 */
endDate?: string;
/**
 * Maximum number of models to return. Defaults to 10. Frontend can decide how to handle aggregation if needed.
 */
maxModels?: number;
/**
 * Filter by model ID
 */
modelId?: string;
};

export type UsageControllerGetUserUsageParams = {
/**
 * Start date in ISO format
 */
startDate?: string;
/**
 * End date in ISO format
 */
endDate?: string;
/**
 * Number of users per page (1-1000). Defaults to 50.
 */
limit?: number;
/**
 * Number of users to skip for pagination. Defaults to 0.
 */
offset?: number;
/**
 * Search term to filter users by name or email
 */
search?: string;
/**
 * Field to sort users by. Defaults to tokens.
 */
sortBy?: UsageControllerGetUserUsageSortBy;
/**
 * Sort order (ascending or descending). Defaults to desc.
 */
sortOrder?: UsageControllerGetUserUsageSortOrder;
};

export type UsageControllerGetUserUsageSortBy = typeof UsageControllerGetUserUsageSortBy[keyof typeof UsageControllerGetUserUsageSortBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UsageControllerGetUserUsageSortBy = {
  tokens: 'tokens',
  requests: 'requests',
  lastActivity: 'lastActivity',
  userName: 'userName',
} as const;

export type UsageControllerGetUserUsageSortOrder = typeof UsageControllerGetUserUsageSortOrder[keyof typeof UsageControllerGetUserUsageSortOrder];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UsageControllerGetUserUsageSortOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type SuperAdminUsageControllerGetUsageStatsParams = {
startDate?: string;
endDate?: string;
};

export type SuperAdminUsageControllerGetModelDistributionParams = {
startDate?: string;
endDate?: string;
maxModels?: number;
modelId?: string;
};

export type SuperAdminUsageDataControllerGetProviderUsageParams = {
startDate?: string;
endDate?: string;
includeTimeSeries?: boolean;
provider?: string;
modelId?: string;
};

export type SuperAdminUsageDataControllerGetProviderUsageChartParams = {
startDate?: string;
endDate?: string;
provider?: string;
modelId?: string;
};

export type SuperAdminUsageDataControllerGetUserUsageParams = {
startDate?: string;
endDate?: string;
limit?: number;
offset?: number;
search?: string;
sortBy?: SuperAdminUsageDataControllerGetUserUsageSortBy;
sortOrder?: SuperAdminUsageDataControllerGetUserUsageSortOrder;
};

export type SuperAdminUsageDataControllerGetUserUsageSortBy = typeof SuperAdminUsageDataControllerGetUserUsageSortBy[keyof typeof SuperAdminUsageDataControllerGetUserUsageSortBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SuperAdminUsageDataControllerGetUserUsageSortBy = {
  tokens: 'tokens',
  requests: 'requests',
  lastActivity: 'lastActivity',
  userName: 'userName',
} as const;

export type SuperAdminUsageDataControllerGetUserUsageSortOrder = typeof SuperAdminUsageDataControllerGetUserUsageSortOrder[keyof typeof SuperAdminUsageDataControllerGetUserUsageSortOrder];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SuperAdminUsageDataControllerGetUserUsageSortOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type SuperAdminGlobalUsageControllerGetGlobalProviderUsageChartParams = {
startDate?: string;
endDate?: string;
provider?: string;
modelId?: string;
};

export type SuperAdminGlobalUsageControllerGetGlobalModelDistributionParams = {
startDate?: string;
endDate?: string;
modelId?: string;
};

export type TranscriptionsControllerTranscribeBody = {
  /** The audio file to transcribe */
  file: Blob;
  /** Optional language hint (e.g., "en", "de") */
  language?: string;
};

export type ArtifactsControllerExportParams = {
format: ExportFormatDto;
};

