/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * Docling Document Processing API
 * 
Production-ready document processing API powered by Docling.

## Features
- Convert PDF, DOCX, PPTX, XLSX, HTML, and images to Markdown, JSON, or plain text
- Extract tables with structure preservation
- Generate vector embeddings for document chunks
- Async processing with task status tracking
- Webhook notifications for task completion
- Batch processing support

## Authentication
All endpoints require an API key passed via the `X-API-Key` header.

## Monitoring
- Flower Dashboard: Monitor Celery tasks at /flower (if enabled)
- Prometheus metrics: Available at /metrics

 * OpenAPI spec version: 1.0.0
 */
/**
 * Webhook URL to notify when all processing is complete
 */
export type BatchConversionRequestWebhookUrl = string | null;

/**
 * Request model for batch document conversion.
 */
export interface BatchConversionRequest {
  /**
   * List of document URLs to convert
   * @minItems 1
   * @maxItems 100
   */
  urls: string[];
  /** Conversion options applied to all documents */
  options?: ConversionOptions;
  /** Webhook URL to notify when all processing is complete */
  webhook_url?: BatchConversionRequestWebhookUrl;
}

/**
 * Response for batch conversion request.
 */
export interface BatchTaskResponse {
  /** Batch identifier */
  batch_id: string;
  /** Individual task identifiers */
  task_ids: string[];
  /** Total documents in batch */
  total_documents: number;
  /** Overall batch status */
  status: TaskStatus;
  /** Batch creation timestamp */
  created_at: string;
}

export interface BodyConvertDocumentUploadConvertUploadPost {
  /** Document file to convert */
  file: Blob;
}

/**
 * Options for document conversion.
 */
export interface ConversionOptions {
  /** Output format for the converted document */
  output_format?: OutputFormat;
  /** Extract tables from the document */
  extract_tables?: boolean;
  /** Extract and process images from the document */
  extract_images?: boolean;
  /** Enable OCR for scanned documents and images */
  ocr_enabled?: boolean;
  /** Generate vector embeddings for the document chunks */
  generate_embeddings?: boolean;
  /**
   * Size of text chunks for embedding generation
   * @minimum 100
   * @maximum 4096
   */
  chunk_size?: number;
  /**
   * Overlap between consecutive chunks
   * @minimum 0
   * @maximum 500
   */
  chunk_overlap?: number;
}

/**
 * URL of the document to convert
 */
export type ConversionRequestUrl = string | null;

/**
 * Webhook URL to notify when processing is complete
 */
export type ConversionRequestWebhookUrl = string | null;

export type ConversionRequestMetadataAnyOf = { [key: string]: unknown };

/**
 * Custom metadata to attach to the task
 */
export type ConversionRequestMetadata = ConversionRequestMetadataAnyOf | null;

/**
 * Request model for document conversion.
 */
export interface ConversionRequest {
  /** URL of the document to convert */
  url?: ConversionRequestUrl;
  /** Conversion options */
  options?: ConversionOptions;
  /** Webhook URL to notify when processing is complete */
  webhook_url?: ConversionRequestWebhookUrl;
  /** Custom metadata to attach to the task */
  metadata?: ConversionRequestMetadata;
}

/**
 * Original filename
 */
export type ConversionResultFilename = string | null;

/**
 * Detected document type
 */
export type ConversionResultDocumentType = DocumentType | null;

/**
 * Converted content in requested format
 */
export type ConversionResultContent = string | null;

/**
 * Document chunks with optional embeddings
 */
export type ConversionResultChunks = DocumentChunk[] | null;

/**
 * Extracted tables
 */
export type ConversionResultTables = TableData[] | null;

/**
 * Document metadata
 */
export type ConversionResultMetadata = { [key: string]: unknown };

/**
 * Number of pages
 */
export type ConversionResultPageCount = number | null;

/**
 * Processing time in milliseconds
 */
export type ConversionResultProcessingTimeMs = number | null;

/**
 * Error message if failed
 */
export type ConversionResultError = string | null;

/**
 * Task completion timestamp
 */
export type ConversionResultCompletedAt = string | null;

/**
 * Result of document conversion.
 */
export interface ConversionResult {
  /** Task identifier */
  task_id: string;
  /** Task status */
  status: TaskStatus;
  /** Original filename */
  filename?: ConversionResultFilename;
  /** Detected document type */
  document_type?: ConversionResultDocumentType;
  /** Converted content in requested format */
  content?: ConversionResultContent;
  /** Document chunks with optional embeddings */
  chunks?: ConversionResultChunks;
  /** Extracted tables */
  tables?: ConversionResultTables;
  /** Document metadata */
  metadata?: ConversionResultMetadata;
  /** Number of pages */
  page_count?: ConversionResultPageCount;
  /** Processing time in milliseconds */
  processing_time_ms?: ConversionResultProcessingTimeMs;
  /** Error message if failed */
  error?: ConversionResultError;
  /** Task creation timestamp */
  created_at: string;
  /** Task completion timestamp */
  completed_at?: ConversionResultCompletedAt;
}

/**
 * Chunk metadata (page, position, etc.)
 */
export type DocumentChunkMetadata = { [key: string]: unknown };

/**
 * Vector embedding if requested
 */
export type DocumentChunkEmbedding = number[] | null;

/**
 * A chunk of processed document with optional embedding.
 */
export interface DocumentChunk {
  /** Chunk identifier */
  id: string;
  /** Text content of the chunk */
  content: string;
  /** Chunk metadata (page, position, etc.) */
  metadata?: DocumentChunkMetadata;
  /** Vector embedding if requested */
  embedding?: DocumentChunkEmbedding;
}

/**
 * Supported document types.
 */
export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType];

export const DocumentType = {
  pdf: 'pdf',
  docx: 'docx',
  pptx: 'pptx',
  xlsx: 'xlsx',
  html: 'html',
  image: 'image',
  asciidoc: 'asciidoc',
  md: 'md',
} as const;

export interface HTTPValidationError {
  detail?: ValidationError[];
}

/**
 * Health check response.
 */
export interface HealthResponse {
  /** Service status */
  status: string;
  /** API version */
  version: string;
  /** Redis connection status */
  redis_connected: boolean;
  /** Number of active workers */
  workers_active: number;
  /** Service uptime */
  uptime_seconds: number;
}

/**
 * Supported output formats.
 */
export type OutputFormat = (typeof OutputFormat)[keyof typeof OutputFormat];

export const OutputFormat = {
  markdown: 'markdown',
  json: 'json',
  text: 'text',
  doctags: 'doctags',
} as const;

/**
 * Statistics response.
 */
export interface StatsResponse {
  /** Total tasks processed */
  total_tasks: number;
  /** Tasks waiting to be processed */
  pending_tasks: number;
  /** Successfully completed tasks */
  completed_tasks: number;
  /** Failed tasks */
  failed_tasks: number;
  /** Average processing time */
  avg_processing_time_ms: number;
}

/**
 * Page number
 */
export type TableDataPage = number | null;

/**
 * Extracted table data.
 */
export interface TableData {
  /** Table identifier */
  id: string;
  /** Page number */
  page?: TableDataPage;
  /** Table headers */
  headers?: string[];
  /** Table rows */
  rows?: string[][];
  /** Markdown representation */
  markdown: string;
}

/**
 * Response model for task creation.
 */
export interface TaskResponse {
  /** Unique task identifier */
  task_id: string;
  /** Current task status */
  status: TaskStatus;
  /** Task creation timestamp */
  created_at: string;
  /** Status message */
  message: string;
}

/**
 * Task processing status.
 */
export type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus];

export const TaskStatus = {
  pending: 'pending',
  processing: 'processing',
  completed: 'completed',
  failed: 'failed',
} as const;

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

export type ConvertDocumentUploadConvertUploadPostParams = {
  /**
   * Output format
   */
  output_format?: string;
  /**
   * Extract tables
   */
  extract_tables?: boolean;
  /**
   * Extract images
   */
  extract_images?: boolean;
  /**
   * Enable OCR
   */
  ocr_enabled?: boolean;
  /**
   * Generate embeddings
   */
  generate_embeddings?: boolean;
  /**
   * Chunk size
   * @minimum 100
   * @maximum 4096
   */
  chunk_size?: number;
  /**
   * Chunk overlap
   * @minimum 0
   * @maximum 500
   */
  chunk_overlap?: number;
  /**
   * Webhook URL
   */
  webhook_url?: string | null;
};
