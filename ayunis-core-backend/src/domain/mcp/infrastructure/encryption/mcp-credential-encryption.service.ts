import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import * as crypto from 'crypto';
import { McpCredentialEncryptionPort } from '../../application/ports/mcp-credential-encryption.port';

/**
 * Concrete implementation of credential encryption using AES-256-GCM.
 *
 * This service encrypts MCP integration credentials (API keys, bearer tokens)
 * for secure storage at rest in the database. The encryption key is read from
 * the MCP_ENCRYPTION_KEY environment variable.
 *
 * Encryption format:
 * - Algorithm: AES-256-GCM
 * - Key: 32 bytes (256 bits) from hex-encoded environment variable
 * - IV: Random 16 bytes (generated per encryption)
 * - Auth Tag: 16 bytes (generated by GCM mode)
 * - Output: base64(iv + ciphertext + authTag)
 */
@Injectable()
export class McpCredentialEncryptionService extends McpCredentialEncryptionPort {
  private readonly logger = new Logger(McpCredentialEncryptionService.name);
  private readonly algorithm = 'aes-256-gcm';
  private readonly ivLength = 16; // 128 bits
  private readonly authTagLength = 16; // 128 bits
  private readonly encryptionKey: Buffer;

  constructor(private readonly configService: ConfigService) {
    super();

    // Read and validate encryption key from environment
    const keyHex = this.configService.get<string>('MCP_ENCRYPTION_KEY');

    if (!keyHex || keyHex.trim() === '') {
      throw new Error(
        'MCP_ENCRYPTION_KEY environment variable is not configured. ' +
          'Generate a key with: openssl rand -hex 32',
      );
    }

    // Validate key is 64 hex characters (32 bytes)
    if (keyHex.length !== 64 || !/^[0-9a-fA-F]{64}$/.test(keyHex)) {
      throw new Error(
        'MCP_ENCRYPTION_KEY must be a 64-character hex string (32 bytes). ' +
          'Generate a key with: openssl rand -hex 32',
      );
    }

    this.encryptionKey = Buffer.from(keyHex, 'hex');
    this.logger.log('McpCredentialEncryptionService initialized successfully');
  }

  /**
   * Encrypts plaintext credentials using AES-256-GCM.
   *
   * Each encryption generates a random IV, ensuring that encrypting the same
   * plaintext multiple times produces different ciphertext (semantic security).
   *
   * @param plaintext - The credential value to encrypt
   * @returns Promise resolving to base64-encoded encrypted value
   * @throws Error if encryption fails
   */
  async encrypt(plaintext: string): Promise<string> {
    try {
      // Generate random IV for this encryption
      const iv = crypto.randomBytes(this.ivLength);

      // Create cipher
      const cipher = crypto.createCipheriv(
        this.algorithm,
        this.encryptionKey,
        iv,
      );

      // Encrypt the plaintext
      const encrypted = Buffer.concat([
        cipher.update(plaintext, 'utf8'),
        cipher.final(),
      ]);

      // Get the authentication tag
      const authTag = cipher.getAuthTag();

      // Combine IV + ciphertext + authTag and encode as base64
      const combined = Buffer.concat([iv, encrypted, authTag]);
      return Promise.resolve(combined.toString('base64'));
    } catch (error) {
      this.logger.error('Failed to encrypt credential', {
        error: error as Error,
      });
      throw new Error('Failed to encrypt credential');
    }
  }

  /**
   * Decrypts encrypted credentials back to plaintext.
   *
   * @param ciphertext - The base64-encoded encrypted value
   * @returns Promise resolving to original plaintext credential
   * @throws Error if decryption fails (invalid ciphertext, wrong key, corrupted data)
   */
  async decrypt(ciphertext: string): Promise<string> {
    try {
      // Decode from base64
      const combined = Buffer.from(ciphertext, 'base64');

      // Validate minimum length (IV + authTag = 32 bytes minimum)
      if (combined.length < this.ivLength + this.authTagLength) {
        throw new Error('Ciphertext is too short');
      }

      // Extract IV, encrypted data, and auth tag
      const iv = combined.subarray(0, this.ivLength);
      const authTag = combined.subarray(-this.authTagLength);
      const encrypted = combined.subarray(this.ivLength, -this.authTagLength);

      // Create decipher
      const decipher = crypto.createDecipheriv(
        this.algorithm,
        this.encryptionKey,
        iv,
      );
      decipher.setAuthTag(authTag);

      // Decrypt the data
      const decrypted = Buffer.concat([
        decipher.update(encrypted),
        decipher.final(),
      ]);

      return Promise.resolve(decrypted.toString('utf8'));
    } catch (error) {
      this.logger.error('Failed to decrypt credential', {
        error: error as Error,
      });
      throw new Error('Failed to decrypt credential');
    }
  }
}
