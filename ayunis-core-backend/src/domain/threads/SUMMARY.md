Conversation Sessions
Conversation threads linking messages, models, and sources

Threads are conversation containers that hold message histories, bind to a language model and optional agent, and support source attachments and knowledge base assignments for per-conversation RAG context enrichment.

The threads module manages conversation sessions. The `Thread` entity holds a message list, optional `PermittedLanguageModel` reference, optional agent binding, source assignments, knowledge base assignments, title, and anonymous flag. `SourceAssignment` links data sources to individual threads and carries an optional `originSkillId` provenance field that tracks which skill caused the source to be attached â€” this enables cleanup when a skill share is revoked. The `KnowledgeBaseAssignment` entity represents knowledge base assignments on a thread with an `originSkillId` provenance field that tracks which skill caused the knowledge base to be attached; the underlying `thread_knowledge_base_assignments` table implements a `@OneToMany` relation from `ThreadRecord` to `ThreadKnowledgeBaseAssignmentRecord`. The `ThreadKnowledgeBaseAssignmentMapper` handles conversion between `KnowledgeBaseAssignment` domain entities and `ThreadKnowledgeBaseAssignmentRecord` persistence records. Key use cases include creating threads, finding threads (single, all, by org with sources), updating titles, deleting threads, adding/removing sources, adding/removing knowledge bases from threads (`AddKnowledgeBaseToThreadUseCase`, `RemoveKnowledgeBaseFromThreadUseCase`), removing skill-originated sources from threads (`RemoveSkillSourcesFromThreadsUseCase`), removing skill-originated knowledge base assignments from threads (`RemoveKbAssignmentsByOriginSkillUseCase`), removing directly-assigned knowledge bases from threads (`RemoveDirectKbFromThreadsUseCase`), generating titles via AI inference, and replacing models with user defaults. The add-knowledge-base use case validates org-scoping (the knowledge base must belong to the caller's org) and deduplicates; the remove use case is idempotent when the knowledge base is not assigned. Thread title generation uses the language model to auto-summarize conversation content. The `ShareDeletedListener` listens for skill share deletion events and uses `RemoveSkillSourcesFromThreadsUseCase` and `RemoveKbAssignmentsByOriginSkillUseCase` to clean up source and knowledge base assignments that were attached via the revoked skill, targeting only users who lost access. The `ThreadMapper` uses private helper methods (`mapModel`, `mapSourceAssignments`, `mapMcpIntegrationIds`, `mapKnowledgeBaseAssignments`, `mapMessages`) for readability. The HTTP layer exposes `POST /threads/:id/knowledge-bases/:knowledgeBaseId` (add) and `DELETE /threads/:id/knowledge-bases/:knowledgeBaseId` (remove), both returning 204 No Content. The `GetThreadResponseDto` and `GetThreadDtoMapper` include the `knowledgeBases` array (as `KnowledgeBaseSummaryResponseDto`). The module integrates with **messages** for conversation content storage, **models** for model selection per thread, **agents** for agent-bound conversations, **sources** for attaching RAG data, **knowledge-bases** for attaching org-scoped knowledge bases to threads, **runs** which execute within thread context, **shares** indirectly through skill share deletion events, and **IAM** (users, teams) for resolving which users lost access on share revocation.

**Future work:** MCP integrations on threads currently use a bare `@ManyToMany` join table (`thread_mcp_integrations`) without provenance tracking. When user-group-scoped MCP integration access is added, this table should be promoted to a proper entity (like `ThreadSourceAssignmentRecord`) with an `originSkillId` (or similar provenance) column, following the same pattern used for source assignments. This will enable the same cleanup-on-revocation behavior for MCP integrations.
