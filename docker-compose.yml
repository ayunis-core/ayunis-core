services:
  postgres:
    image: pgvector/pgvector:pg16
    container_name: ayunis-postgres-prod
    restart: unless-stopped
    env_file:
      - ./ayunis-core-backend/.env
    volumes:
      - postgres-data:/var/lib/postgresql/data
      - ./ayunis-core-backend/docker/postgres/init.sql:/docker-entrypoint-initdb.d/init.sql
    networks:
      - ayunis-network
    healthcheck:
      test:
        [
          "CMD-SHELL",
          "pg_isready -U $${POSTGRES_USER:-postgres} -d $${POSTGRES_DB:-$${POSTGRES_USER:-postgres}}",
        ]
      interval: 10s
      timeout: 5s
      retries: 5
    logging:
      driver: json-file
      options:
        max-size: "50m"
        max-file: "5"
    deploy:
      resources:
        limits:
          memory: 1G
          cpus: "1"
        reservations:
          memory: 512M

  minio:
    image: quay.io/minio/minio:latest
    container_name: ayunis-minio-prod
    restart: unless-stopped
    env_file:
      - ./ayunis-core-backend/.env
    volumes:
      - minio-data:/data
    networks:
      - ayunis-network
    command: server /data --console-address ":9001"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 10s
      timeout: 5s
      retries: 5
    # Only expose console port externally if needed
    ports:
      - "9001:9001"
    logging:
      driver: json-file
      options:
        max-size: "50m"
        max-file: "5"
    deploy:
      resources:
        limits:
          memory: 512M
          cpus: "0.5"
        reservations:
          memory: 256M

  docker-socket-proxy:
    image: tecnativa/docker-socket-proxy:latest
    container_name: ayunis-docker-proxy-prod
    restart: unless-stopped
    privileged: true
    environment:
      # Restrict to only the operations needed for code execution
      - CONTAINERS=1 # Allow container operations
      - EXEC=1 # Allow exec operations inside containers
      - PUT=1 # Allow PUT requests (copy archive into containers)
      - POST=1 # Allow POST requests (create containers)
      - DELETE=1 # Allow DELETE requests (remove containers)
      - BUILD=1 # Allow image building
      - IMAGES=1 # Allow image operations
      # Allow volume operations (needed for per-execution ephemeral volumes)
      - VOLUMES=1
      # Deny everything else for security
      - AUTH=0
      - SECRETS=0
      - SERVICES=0
      - SWARM=0
      - NETWORKS=0
      - INFO=1 # Allow info queries
      - PING=1 # Allow health checks
      # HAProxy timeout configurations (in milliseconds)
      - TIMEOUT_CLIENT=0 # 0 = no timeout for long-lived connections
      - TIMEOUT_SERVER=0 # 0 = no timeout for streaming responses
      - TIMEOUT_CONNECT=10000 # 10 seconds for initial connection
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro # Read-only mount
    networks:
      - docker-proxy-network
    # No need to expose ports - only accessed internally
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"
    deploy:
      resources:
        limits:
          memory: 128M
          cpus: "0.25"

  code-execution:
    build:
      context: ./ayunis-core-code-execution
      dockerfile: Dockerfile
    container_name: ayunis-code-execution-prod
    restart: unless-stopped
    depends_on:
      - docker-socket-proxy
    environment:
      - HOST=0.0.0.0
      - PORT=8080
      - EXECUTION_TIMEOUT=30
      - MAX_MEMORY=512m
      - MAX_CPU=1.0
      - DOCKER_IMAGE=python-sandbox:latest
      # Point Docker client to the proxy instead of direct socket
      - DOCKER_HOST=tcp://docker-socket-proxy:2375
    networks:
      - ayunis-network
      - docker-proxy-network # Also connect to proxy network
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:8080/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s
    # Now running with restricted Docker access through proxy
    logging:
      driver: json-file
      options:
        max-size: "50m"
        max-file: "5"
    deploy:
      resources:
        limits:
          memory: 256M
          cpus: "0.5"

  anonymize:
    build:
      context: ./ayunis-core-anonymize
      dockerfile: Dockerfile
    container_name: ayunis-anonymize-prod
    restart: unless-stopped
    networks:
      - ayunis-network
    healthcheck:
      test:
        [
          "CMD-SHELL",
          "python -c 'import urllib.request; urllib.request.urlopen(\"http://localhost:8000/health\")' || exit 1",
        ]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s # Longer start period for model loading
    logging:
      driver: json-file
      options:
        max-size: "50m"
        max-file: "5"
    deploy:
      resources:
        limits:
          memory: 2G
          cpus: "2"
        reservations:
          memory: 1G

  app:
    build:
      context: .
      dockerfile: Dockerfile
      target: production
    container_name: ayunis-app-prod
    restart: unless-stopped
    ports:
      - "${HOST_PORT:-3000}:${CONTAINER_PORT:-3000}"
    depends_on:
      postgres:
        condition: service_healthy
      minio:
        condition: service_healthy
      code-execution:
        condition: service_healthy
      anonymize:
        condition: service_healthy
    env_file:
      - ./ayunis-core-backend/.env
      - ./ayunis-core-frontend/.env
    environment:
      CODE_EXECUTION_SERVICE_URL: http://code-execution:8080
      ANONYMIZE_SERVICE_URL: http://anonymize:8000
    volumes:
      - app-uploads:/app/uploads
    networks:
      - ayunis-network
    healthcheck:
      test:
        [
          "CMD",
          "node",
          "-e",
          "require('http').get('http://localhost:' + (process.env.CONTAINER_PORT || 3000) + '/health', (res) => { process.exit(res.statusCode === 200 ? 0 : 1) })",
        ]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    logging:
      driver: json-file
      options:
        max-size: "50m"
        max-file: "5"
    deploy:
      resources:
        limits:
          memory: 1G
          cpus: "2"
        reservations:
          memory: 512M

  dozzle:
    image: amir20/dozzle:latest
    container_name: ayunis-dozzle-prod
    restart: unless-stopped
    ports:
      - "127.0.0.1:8888:8080" # localhost only for security
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
    # No network needed - Dozzle only requires the Docker socket.
    # Keeping it off ayunis-network ensures the 127.0.0.1 port binding
    # is the only access path (other containers cannot reach dozzle:8080).
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"
    deploy:
      resources:
        limits:
          memory: 128M
          cpus: "0.25"

volumes:
  postgres-data:
    driver: local
  minio-data:
    driver: local
  app-uploads:
    driver: local

networks:
  ayunis-network:
    driver: bridge
  docker-proxy-network:
    driver: bridge
    internal: true # Internal network for Docker proxy communication
