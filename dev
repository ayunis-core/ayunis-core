#!/usr/bin/env bash
# ---------------------------------------------------------------------------
# dev — manage a per-worktree development stack for ayunis-core
#
# Usage:
#   ./dev up   [--slot N]   Start infra (Docker) + backend + frontend in background
#   ./dev down [--slot N]   Stop everything
#   ./dev status [--slot N] Show what's running and on which ports
#   ./dev logs [--slot N] [--tail N] [backend|frontend|infra|all]
#                           Print recent logs (default: all, last 80 lines)
#
# The --slot flag is required on first use (./dev up --slot N). After that,
# the slot is remembered in .dev/slot and all commands work without --slot.
# ---------------------------------------------------------------------------
set -euo pipefail

REPO_DIR="$(cd "$(dirname "$0")" && pwd)"
COMPOSE_FILE="$REPO_DIR/compose.dev.yml"

# ── Helpers ────────────────────────────────────────────────────────────────

die()  { echo "ERROR: $*" >&2; exit 1; }
info() { echo "==> $*"; }
warn() { echo "⚠️  $*" >&2; }

# ── Parse arguments ────────────────────────────────────────────────────────

SLOT=""
COMMAND="${1:-help}"
shift || true

while [[ $# -gt 0 ]]; do
  case "$1" in
    --slot) SLOT="${2:?--slot requires a number}"; shift 2 ;;
    *)      break ;;
  esac
done

# ── Resolve slot: explicit flag > saved file > error ──────────────────────

SLOT_FILE="$REPO_DIR/.dev/slot"

if [ -n "$SLOT" ]; then
  # Slot provided explicitly — save it for future commands
  mkdir -p "$REPO_DIR/.dev"
  echo "$SLOT" > "$SLOT_FILE"
elif [ -f "$SLOT_FILE" ]; then
  SLOT="$(cat "$SLOT_FILE")"
else
  # No slot given and none saved — only help works without a slot
  if [[ "$COMMAND" != "help" && "$COMMAND" != "--help" && "$COMMAND" != "-h" ]]; then
    die "No slot specified and none previously saved. Run: ./dev up --slot N"
  fi
  SLOT=0  # dummy for help
fi

# ── Derived port mappings (offset = SLOT * 10) ────────────────────────────

OFFSET=$((SLOT * 10))

export POSTGRES_HOST_PORT=$((5432 + OFFSET))
export MINIO_HOST_PORT=$((9000 + OFFSET))
export MINIO_CONSOLE_HOST_PORT=$((9001 + OFFSET))
export MAILCATCHER_SMTP_HOST_PORT=$((1025 + OFFSET))
export MAILCATCHER_WEB_HOST_PORT=$((1080 + OFFSET))
export CODE_EXEC_HOST_PORT=$((8080 + OFFSET))
export ANONYMIZE_HOST_PORT=$((8001 + OFFSET))

BACKEND_PORT=$((3000 + OFFSET))
FRONTEND_PORT=$((3001 + OFFSET))

PROJECT_NAME="ayunis-dev-${SLOT}"
STATE_DIR="$REPO_DIR/.dev/slot-${SLOT}"

# ── Docker compose wrapper ─────────────────────────────────────────────────

dc() {
  docker compose -f "$COMPOSE_FILE" -p "$PROJECT_NAME" "$@"
}

# ── Ensure state dir exists ───────────────────────────────────────────────

mkdir -p "$STATE_DIR"

# ── Commands ──────────────────────────────────────────────────────────────

cmd_up() {
  info "Starting slot $SLOT  (port offset +$OFFSET)"

  # -- 1. Docker infrastructure -------------------------------------------
  info "Starting Docker infrastructure …"
  dc up -d --build --wait 2>&1 | tail -5

  # -- 2. Generate .env.dev for backend ------------------------------------
  local env_dev="$REPO_DIR/ayunis-core-backend/.env.dev"
  info "Writing $env_dev (slot $SLOT) …"
  cat > "$env_dev" <<EOF
# Auto-generated by ./dev up --slot $SLOT
# Connection config for native dev — overrides .env when loaded.
# Do not edit manually; re-run ./dev up to regenerate.
PORT=$BACKEND_PORT
POSTGRES_HOST=localhost
POSTGRES_PORT=$POSTGRES_HOST_PORT
POSTGRES_USER=${POSTGRES_USER:-postgres}
POSTGRES_PASSWORD=${POSTGRES_PASSWORD:-postgres}
POSTGRES_DB=${POSTGRES_DB:-ayunis}
MINIO_ENDPOINT=localhost
MINIO_PORT=$MINIO_HOST_PORT
MINIO_ACCESS_KEY=${MINIO_ROOT_USER:-minio}
MINIO_SECRET_KEY=${MINIO_ROOT_PASSWORD:-minio123}
SMTP_HOST=localhost
SMTP_PORT=$MAILCATCHER_SMTP_HOST_PORT
CODE_EXECUTION_SERVICE_URL=http://localhost:$CODE_EXEC_HOST_PORT
ANONYMIZE_SERVICE_URL=http://localhost:$ANONYMIZE_HOST_PORT
FRONTEND_BASEURL=http://localhost:$FRONTEND_PORT
CORS_ALLOWED_ORIGINS=http://localhost:$FRONTEND_PORT,http://localhost:$BACKEND_PORT
EOF

  # -- 3. Run database migrations ------------------------------------------
  info "Running database migrations …"
  (cd "$REPO_DIR/ayunis-core-backend" && npm run migration:run:dev 2>&1) | tail -3

  # -- 4. Backend (native) ------------------------------------------------
  if _pid_alive "$STATE_DIR/backend.pid"; then
    info "Backend already running (PID $(cat "$STATE_DIR/backend.pid"))"
  else
    _kill_port "$BACKEND_PORT" "Backend (stale)"
    info "Starting backend on port $BACKEND_PORT …"
    : > "$STATE_DIR/backend.log"
    (
      cd "$REPO_DIR/ayunis-core-backend"
      exec npm run start:dev \
        >> "$STATE_DIR/backend.log" 2>&1
    ) &
    echo $! > "$STATE_DIR/backend.pid"
  fi

  # -- 5. Frontend (native) -----------------------------------------------
  if _pid_alive "$STATE_DIR/frontend.pid"; then
    info "Frontend already running (PID $(cat "$STATE_DIR/frontend.pid"))"
  else
    _kill_port "$FRONTEND_PORT" "Frontend (stale)"
    info "Starting frontend on port $FRONTEND_PORT …"
    : > "$STATE_DIR/frontend.log"
    (
      cd "$REPO_DIR/ayunis-core-frontend"
      export VITE_API_BASE_URL="http://localhost:$BACKEND_PORT/api"
      exec npx vite --port "$FRONTEND_PORT" \
        >> "$STATE_DIR/frontend.log" 2>&1
    ) &
    echo $! > "$STATE_DIR/frontend.pid"
  fi

  # -- 6. Wait for backend health -----------------------------------------
  info "Waiting for backend to become healthy …"
  local url="http://localhost:$BACKEND_PORT/api/health"
  local attempts=0
  local max_attempts=90
  while ! curl -sf "$url" > /dev/null 2>&1; do
    attempts=$((attempts + 1))
    if [ $attempts -ge $max_attempts ]; then
      echo ""
      die "Backend did not become healthy after $((max_attempts * 2))s. Check logs:  ./dev logs --slot $SLOT backend"
    fi
    printf "."
    sleep 2
  done
  echo ""

  # -- 7. Summary ----------------------------------------------------------
  echo ""
  echo "✅ Slot $SLOT is ready"
  echo ""
  echo "  Backend:      http://localhost:$BACKEND_PORT"
  echo "  Frontend:     http://localhost:$FRONTEND_PORT"
  echo "  API docs:     http://localhost:$BACKEND_PORT/api/docs"
  echo "  Postgres:     localhost:$POSTGRES_HOST_PORT"
  echo "  MinIO:        localhost:$MINIO_HOST_PORT  (console: $MINIO_CONSOLE_HOST_PORT)"
  echo "  Mailcatcher:  smtp :$MAILCATCHER_SMTP_HOST_PORT  web :$MAILCATCHER_WEB_HOST_PORT"
  echo "  Code exec:    localhost:$CODE_EXEC_HOST_PORT"
  echo "  Anonymize:    localhost:$ANONYMIZE_HOST_PORT"
  echo ""
  echo "  Logs dir:     $STATE_DIR/"
  echo ""
}

cmd_down() {
  info "Stopping slot $SLOT …"

  # Stop native processes (pass ports to kill orphaned grandchild processes)
  _kill_pid "$STATE_DIR/frontend.pid" "Frontend" "$FRONTEND_PORT"
  _kill_pid "$STATE_DIR/backend.pid"  "Backend"  "$BACKEND_PORT"

  # Stop Docker infrastructure
  dc down

  info "Slot $SLOT stopped."
}

cmd_status() {
  echo "Slot $SLOT"
  echo ""

  # Docker services
  local services
  services=$(dc ps --format json 2>/dev/null || echo "")
  if [ -n "$services" ]; then
    dc ps --format "table {{.Service}}\t{{.Status}}\t{{.Ports}}"
  else
    echo "  Docker infra:  not running"
  fi
  echo ""

  # Backend
  if _pid_alive "$STATE_DIR/backend.pid"; then
    echo "  Backend:   running  PID $(cat "$STATE_DIR/backend.pid")  http://localhost:$BACKEND_PORT"
  else
    echo "  Backend:   stopped"
  fi

  # Frontend
  if _pid_alive "$STATE_DIR/frontend.pid"; then
    echo "  Frontend:  running  PID $(cat "$STATE_DIR/frontend.pid")  http://localhost:$FRONTEND_PORT"
  else
    echo "  Frontend:  stopped"
  fi
  echo ""
}

cmd_logs() {
  local tail_lines=80
  local target="all"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --tail) tail_lines="${2:?--tail requires a number}"; shift 2 ;;
      backend|frontend|infra|all) target="$1"; shift ;;
      *) die "Unknown logs argument: $1" ;;
    esac
  done

  case "$target" in
    backend)
      _show_log "$STATE_DIR/backend.log" "Backend" "$tail_lines"
      ;;
    frontend)
      _show_log "$STATE_DIR/frontend.log" "Frontend" "$tail_lines"
      ;;
    infra)
      dc logs --tail "$tail_lines"
      ;;
    all)
      _show_log "$STATE_DIR/backend.log" "Backend" "$tail_lines"
      echo ""
      _show_log "$STATE_DIR/frontend.log" "Frontend" "$tail_lines"
      echo ""
      info "Docker infrastructure logs (last $tail_lines lines):"
      dc logs --tail "$tail_lines"
      ;;
  esac
}

# ── Utilities ──────────────────────────────────────────────────────────────

_pid_alive() {
  local pidfile="$1"
  [ -f "$pidfile" ] && kill -0 "$(cat "$pidfile")" 2>/dev/null
}

_kill_pid() {
  local pidfile="$1"
  local label="${2:-process}"
  local port="${3:-}"
  if _pid_alive "$pidfile"; then
    local pid
    pid=$(cat "$pidfile")
    info "Stopping $label (PID $pid) …"
    # The PID is a subshell that is a process group leader.
    # Kill the whole group, then fall back to pkill -P for any stragglers.
    kill -TERM -- -"$pid" 2>/dev/null || true
    pkill -TERM -P "$pid" 2>/dev/null || true
    kill -TERM "$pid" 2>/dev/null || true
    # Wait briefly, then force-kill stragglers
    sleep 1
    kill -9 -- -"$pid" 2>/dev/null || true
    pkill -9 -P "$pid" 2>/dev/null || true
    kill -9 "$pid" 2>/dev/null || true
    rm -f "$pidfile"
  fi
  # Safety net: kill any process still listening on the port.
  # Handles orphaned grandchild processes (e.g., node spawned by npm).
  if [ -n "$port" ]; then
    _kill_port "$port" "$label"
  fi
}

_is_repo_process() {
  local pid="$1"
  local proc_cwd
  # Try to get process cwd via /proc (Linux)
  proc_cwd=$(readlink "/proc/$pid/cwd" 2>/dev/null || true)
  if [ -n "$proc_cwd" ]; then
    [[ "$proc_cwd" == "$REPO_DIR"* ]]
  else
    # Fallback for non-Linux or if /proc read fails: check command line
    local cmd
    cmd=$(ps -p "$pid" -o args= 2>/dev/null || true)
    [[ "$cmd" == *"$REPO_DIR"* ]] || [[ "$cmd" == *"ayunis-core"* ]]
  fi
}

_kill_port() {
  local port="$1"
  local label="${2:-process}"
  local pids
  pids=$(lsof -ti :"$port" 2>/dev/null || true)
  if [ -n "$pids" ]; then
    for pid in $pids; do
      if _is_repo_process "$pid"; then
        warn "Killing orphaned $label process on port $port (PID $pid)"
        kill -9 "$pid" 2>/dev/null || true
      else
        warn "Port $port occupied by unrelated process (PID $pid) — not killing"
      fi
    done
    sleep 1
  fi
}

_show_log() {
  local logfile="$1"
  local label="$2"
  local lines="$3"
  info "$label logs (last $lines lines):"
  if [ -f "$logfile" ]; then
    tail -n "$lines" "$logfile"
  else
    echo "  (no log file yet)"
  fi
}

# ── Dispatch ──────────────────────────────────────────────────────────────

case "$COMMAND" in
  up)     cmd_up ;;
  down)   cmd_down ;;
  status) cmd_status ;;
  logs)   cmd_logs "$@" ;;
  help|--help|-h)
    echo "Usage: ./dev <up|down|status|logs> [--slot N] [logs options]"
    echo ""
    echo "Commands:"
    echo "  up     --slot N                            Start the full dev stack in background"
    echo "  down   [--slot N]                          Stop everything"
    echo "  status [--slot N]                          Show what's running"
    echo "  logs   [--slot N] [--tail N] [backend|frontend|infra|all]"
    echo "                                             Print recent logs (default: all, 80 lines)"
    echo ""
    echo "The --slot flag is required on first use (./dev up --slot N)."
    echo "After that, the slot is saved to .dev/slot and all commands work without --slot."
    echo "Slots assign port offsets (+10 per slot) so multiple worktrees can coexist."
    ;;
  *)
    die "Unknown command: $COMMAND.  Run ./dev help for usage."
    ;;
esac
